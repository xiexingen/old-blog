<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git提交规范</title>
      <link href="2020/12/23/tools/gitcommit/"/>
      <url>2020/12/23/tools/gitcommit/</url>
      
        <content type="html"><![CDATA[<p>git提交规范</p><a id="more"></a><h1 id="Commit-Message-格式"><a href="#Commit-Message-格式" class="headerlink" title="Commit Message 格式"></a>Commit Message 格式</h1><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>scope<span class="token operator">></span><span class="token punctuation">)</span>: <span class="token operator">&lt;</span>subject<span class="token operator">></span><span class="token operator">&lt;</span>空一行<span class="token operator">></span><span class="token operator">&lt;</span>body<span class="token operator">></span><span class="token operator">&lt;</span>空一行<span class="token operator">></span><span class="token operator">&lt;</span>footer<span class="token operator">></span></code></pre><ul><li><p><code>&lt;type&gt;</code></p><ul><li>feat: 新功能（feature）</li><li>fix: 修补bug</li><li>docs: 文档（documentation）</li><li>style: 格式（不影响代码运行的变动）</li><li>refactor: 重构（即不是新增功能，也不是修改bug的代码变动）</li><li>perf: 更改代码以提高性能</li><li>test: 添加测试</li><li>chore: 构建过程或辅助工具的变动</li></ul></li><li><p><code>&lt;scope&gt;</code> 选填项，用来说明本次提交的影响的范围，如 $location, $browser。当更改影响的范围不止一个时，可以使用 *</p></li><li><p><code>&lt;subject&gt;</code>: 用来简要描述本次改动，尽量遵循:</p><ul><li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</li><li>首字母不要大写</li><li>结尾不用句号 .</li></ul></li><li><p><code>&lt;body&gt;</code> : 对 <code>&lt;subject&gt;</code> 的描述</p></li><li><p><code>&lt;footer&gt;</code>: 主要放置不兼容变更和关闭Issue的信息</p><ul><li>不兼容变更: 以 BREAKING CHANGE: 开头，描述变动、变动理由和迁移方法。</li><li>关闭Issue: 如close #666</li></ul></li></ul><h2 id="特殊格式"><a href="#特殊格式" class="headerlink" title="特殊格式"></a>特殊格式</h2><ul><li>Revert: 此外如果需要撤销之前的Commit，那么本次Commit Message中必须以 revert： 开头，后面紧跟前面描述的Header部分，格式不变。并且，<body>部分的格式也是固定的，必须要记录撤销前Commit的SHA值。</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><ul><li><p>feat</p><pre class=" language-bash"><code class="language-bash">feat<span class="token punctuation">(</span><span class="token variable">$browser</span><span class="token punctuation">)</span>: onUrlChange event <span class="token punctuation">(</span>popstate/hashchange/polling<span class="token punctuation">)</span>Added new event to <span class="token variable">$browser</span><span class="token keyword">:</span>- forward popstate event <span class="token keyword">if</span> available- forward hashchange event <span class="token keyword">if</span> popstate not available- <span class="token keyword">do</span> polling when neither popstate nor hashchange availableBreaks <span class="token variable">$browser</span>.onHashChange, <span class="token function">which</span> was removed <span class="token punctuation">(</span>use onUrlChange instead<span class="token punctuation">)</span></code></pre><pre class=" language-bash"><code class="language-bash">feat<span class="token punctuation">(</span>directive<span class="token punctuation">)</span>: ng:disabled, ng:checked, ng:multiple, ng:readonly, ng:selectedNew directives <span class="token keyword">for</span> proper binding these attributes <span class="token keyword">in</span> older browsers <span class="token punctuation">(</span>IE<span class="token punctuation">)</span>.Added coresponding description, live examples and e2e tests.Closes <span class="token comment" spellcheck="true">#351</span></code></pre></li><li><p>fix</p><pre class=" language-bash"><code class="language-bash">fix<span class="token punctuation">(</span><span class="token variable">$compile</span><span class="token punctuation">)</span>: couple of unit tests <span class="token keyword">for</span> IE9Older IEs serialize html uppercased, but IE9 does not<span class="token punctuation">..</span>.Would be better to <span class="token function">expect</span> <span class="token keyword">case</span> insensitive, unfortunately jasmine doesnot allow to user regexps <span class="token keyword">for</span> throw expectations.Closes <span class="token comment" spellcheck="true">#392</span>Breaks foo.bar api, foo.baz should be used instead</code></pre></li></ul><ul><li><p>docs</p><pre class=" language-bash"><code class="language-bash">docs<span class="token punctuation">(</span>guide<span class="token punctuation">)</span>: updated fixed docs from Google DocsCouple of typos fixed:- indentation- batchLogbatchLog -<span class="token operator">></span> batchLog- start periodic checking- missing brace</code></pre><pre class=" language-bash"><code class="language-bash">docs: fix grammardocs: corrections and further clarifications docs: update broken <span class="token function">link</span>docs<span class="token punctuation">(</span>README<span class="token punctuation">)</span>: update version numberdocs<span class="token punctuation">(</span>README<span class="token punctuation">)</span>: place badgedocs<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>: remove redundant defaults</code></pre></li><li><p>style</p><pre class=" language-bash"><code class="language-bash">style: fix table indentationstyle<span class="token punctuation">(</span><span class="token variable">$location</span><span class="token punctuation">)</span>: add couple of missing semi colons</code></pre></li><li><p>refactor</p><pre class=" language-bash"><code class="language-bash">refactor: remove unnecessary object destructuringrefactor: use <span class="token variable"><span class="token variable">`</span>Object.entries<span class="token variable">`</span></span> rather than <span class="token variable"><span class="token variable">`</span>Object.keys<span class="token variable">`</span></span></code></pre></li><li><p>perf</p><pre class=" language-bash"><code class="language-bash">perf<span class="token punctuation">(</span>*<span class="token punctuation">)</span>: Update network configuration</code></pre></li><li><p>test</p><pre class=" language-bash"><code class="language-bash">test: clarify variables nametest<span class="token punctuation">(</span>testRelease<span class="token punctuation">)</span>: <span class="token keyword">set</span> schedule <span class="token function">test</span></code></pre></li><li><p>chore</p><pre class=" language-bash"><code class="language-bash">chore<span class="token punctuation">(</span>package<span class="token punctuation">)</span>: update xo to version 0.25.0chore<span class="token punctuation">(</span>package<span class="token punctuation">)</span>: remove commitizen from our dependencieschore<span class="token punctuation">(</span>*<span class="token punctuation">)</span>: transfer repo to cycjimmy</code></pre></li><li><p>revert</p><pre class=" language-bash"><code class="language-bash">revert: <span class="token string">"fix: do not convert ssh <span class="token variable"><span class="token variable">`</span>repositoryUrl<span class="token variable">`</span></span> to https"</span>This reverts commit b895231.</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx开篇</title>
      <link href="2019/11/30/nginx/01-introduct/"/>
      <url>2019/11/30/nginx/01-introduct/</url>
      
        <content type="html"><![CDATA[<p>Docker基础开篇<br><a id="more"></a></p><h2 id="centos-7安装nginx"><a href="#centos-7安装nginx" class="headerlink" title="centos 7安装nginx"></a>centos 7安装nginx</h2><ul><li><p>更新yum</p><pre class=" language-bash"><code class="language-bash">yum -y update  </code></pre></li><li><p>通过yum安装</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> epel-releaseyum <span class="token function">install</span> nginx </code></pre></li><li><p>配置nginx自动启动</p><pre class=" language-bash"><code class="language-bash">systemctl start nginxsystemctl <span class="token function">enable</span> nginxsystemctl status nginx</code></pre></li><li><p>配置防火墙<br><code>bashfirewall-cmd --zone=public --permanent --add-service=httpfirewall-cmd --zone=public --permanent --add-service=httpsfirewall-cmd --reload</code> bash</p></li></ul><h2 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h2><ul><li><p>worker_processer<br>配置支持的并发数量</p></li><li><p>events</p><pre class=" language-bash"><code class="language-bash">配置网络连接数量events:<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>  worker_connections:1024 <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre></li><li><p>http</p></li></ul><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 基础案例</span>server <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    listen 80<span class="token punctuation">;</span>    server_name test.xxgtalk.cn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># listen [::]:80 ipv6only=on;</span>    <span class="token comment" spellcheck="true"># root /var/www/mywebsite2;</span>    <span class="token comment" spellcheck="true"># index index.html index.htm;</span>    location / <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        proxy_pass http://localhost:9001<span class="token punctuation">;</span>        proxy_http_version 1.1<span class="token punctuation">;</span>        proxy_set_header Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        proxy_set_header Connection <span class="token string">'upgrade'</span><span class="token punctuation">;</span>        proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>        proxy_cache_bypass <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    <span class="token comment" spellcheck="true"># error_page 404 /404.html;</span>    <span class="token comment" spellcheck="true"># error_page 500 502 503 504 /50x.html;</span>    <span class="token comment" spellcheck="true"># location = /50x.html &amp;#123;</span>    <span class="token comment" spellcheck="true">#     root /var/www/mywebsite1;</span>    <span class="token comment" spellcheck="true"># &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; </span></code></pre><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 负载均衡案例</span>upstream myserver <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span> server 192.168.20.23:8080<span class="token punctuation">;</span> server 192.168.20.23:8081<span class="token punctuation">;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>server <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    listen 80<span class="token punctuation">;</span>    server_name test.xxgtalk.cn<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true"># listen [::]:80 ipv6only=on;</span>    <span class="token comment" spellcheck="true"># root /var/www/mywebsite2;</span>    <span class="token comment" spellcheck="true"># index index.html index.htm;</span>    location / <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        proxy_pass http://myserver<span class="token punctuation">;</span>        proxy_http_version 1.1<span class="token punctuation">;</span>        proxy_set_header Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        proxy_set_header Connection <span class="token string">'upgrade'</span><span class="token punctuation">;</span>        proxy_set_header Host <span class="token variable">$host</span><span class="token punctuation">;</span>        proxy_cache_bypass <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    <span class="token comment" spellcheck="true"># error_page 404 /404.html;</span>    <span class="token comment" spellcheck="true"># error_page 500 502 503 504 /50x.html;</span>    <span class="token comment" spellcheck="true"># location = /50x.html &amp;#123;</span>    <span class="token comment" spellcheck="true">#     root /var/www/mywebsite1;</span>    <span class="token comment" spellcheck="true"># &amp;#125;</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125; </span></code></pre><h2 id="动静分离-跟基础类似"><a href="#动静分离-跟基础类似" class="headerlink" title="动静分离(跟基础类似)"></a>动静分离(跟基础类似)</h2><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p><img src="http://qiniu.xxgtalk.cn/blog/images/20191130225646.png" alt="20191130225646.png"></p><ol><li>需要在轮胎服务器安装nginx</li><li>需要再两台服务器上安装keepalived<br><code>`</code> bash<br>yum install keepalived -y</li></ol><h2 id="修改每台机器上的keepalived配置文件"><a href="#修改每台机器上的keepalived配置文件" class="headerlink" title="修改每台机器上的keepalived配置文件"></a>修改每台机器上的keepalived配置文件</h2><h2 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h2><p>rpm -q -q keepalived</p><h2 id="目录位置"><a href="#目录位置" class="headerlink" title="目录位置"></a>目录位置</h2><p>/etc/keepalived<br><code>`</code></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 09 待改进&amp;交流</title>
      <link href="2019/10/05/dotnetcore/signalr/09-todo/"/>
      <url>2019/10/05/dotnetcore/signalr/09-todo/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 09 待改进&amp;交流</p><a id="more"></a><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>写博客真的比写代码累，膜拜那些坚持写博客的大佬！<br>有时候零散的片段比较多，没写之前感觉有千千万万要写的东西，实际写的时候发现， 好像这个没啥说的，然后就帖了个图，或者一笔带过了</p><h2 id="待改进-amp-交流"><a href="#待改进-amp-交流" class="headerlink" title="待改进&amp;交流"></a>待改进&amp;交流</h2><ul><li>使用消息队列替换目前的api调用形式，同时消息队列支持定义推送优先级</li><li>使用polly来重试失败的调用</li><li>将连接中传递的userId改成token</li><li>多个客户端同时关闭，IsLast不准确</li><li>服务器端需要有定时任务去清除redis中的无效数据(看造化)</li><li>连接的监控</li><li>连接的并发数量测试</li></ul><p>更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/10/05/dotnetcore/signalr/08-clientdemo/">.net core 3.0 Signalr - 08 业务实现-客户端demo</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 08 业务实现-客户端demo</title>
      <link href="2019/10/05/dotnetcore/signalr/08-clientdemo/"/>
      <url>2019/10/05/dotnetcore/signalr/08-clientdemo/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 08 业务实现-客户端demo</p><a id="more"></a><p>由于signalr作为一个单独的推送系统，跟业务系统是分离开的，所以此处模拟一个业务系统，新建一个.net core app项目</p><h2 id="模拟实现一个登录功能"><a href="#模拟实现一个登录功能" class="headerlink" title="模拟实现一个登录功能"></a>模拟实现一个登录功能</h2><p>我们的登录很简单，当进入系统，如果检测到用户未登录则跳转到登录页面，用户只需要输入用户名点击登录即算登录成功  </p><ul><li>配置ConfigServices方法 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Startup.cs#L41-L47">查看代码</a><pre class=" language-C#"><code class="language-C#">services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, cookieOption =>&#123;    cookieOption.LoginPath = "/Account/Login";    cookieOption.AccessDeniedPath = "/Account/Login";&#125;);</code></pre></li><li>配置Config方法，配置认证、授权的请求管道 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Startup.cs#L73-L74">查看代码</a><pre class=" language-C#"><code class="language-C#">app.UseRouting();app.UseAuthentication();app.UseAuthorization();</code></pre></li><li>接收登录的post请求，写cookie，跳转 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Controllers/AccountController.cs#L33-L59">查看代码</a></li></ul><h2 id="前端页面实现"><a href="#前端页面实现" class="headerlink" title="前端页面实现"></a>前端页面实现</h2><p>首先在Layout页面引入需要的js文件(vue、signalr、msgpack5、signalr-protocol-msgpack)   <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Shared/_Layout.cshtml#L78-L81">查看代码</a>  </p><h3 id="封装signalr连接相关js"><a href="#封装signalr连接相关js" class="headerlink" title="封装signalr连接相关js"></a>封装signalr连接相关js</h3><p>signalr客户端js的操作就是，创建连接、监听推送,封装后端js如下   <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/wwwroot/js/initSignalr.js">查看代码</a>  </p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">/** * 初始化连接 * @param &amp;#123;object&amp;#125; option 参数 * @param &amp;#123;string&amp;#125; option.url 连接的url地址 * @param &amp;#123;string&amp;#125; option.loggingLevel 日志级别,默认为 Error * @param &amp;#123;number&amp;#125; option.delay 延迟连接 默认为3000毫秒 * @param &amp;#123;function&amp;#125; option.onStarted 启动时触发 * @param &amp;#123;function&amp;#125; option.onLine 启动时触发 * @param &amp;#123;function&amp;#125; option.offLine 启动时触发 * @returns &amp;#123;object&amp;#125; 连接的实例 */</span><span class="token keyword">function</span> <span class="token function">initSignalr</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> config <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        loggingLevel<span class="token punctuation">:</span> signalR<span class="token punctuation">.</span>LogLevel<span class="token punctuation">.</span>Error<span class="token punctuation">,</span>        delay<span class="token punctuation">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">''</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> option<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> connection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">signalR<span class="token punctuation">.</span>HubConnectionBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">configureLogging</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>loggingLevel<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withUrl</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>url<span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            accessTokenFactory<span class="token punctuation">:</span> option<span class="token punctuation">.</span>accessTokenFactory        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withHubProtocol</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">signalR<span class="token punctuation">.</span>protocols<span class="token punctuation">.</span>msgpack<span class="token punctuation">.</span>MessagePackHubProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">withAutomaticReconnect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">onreconnecting</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'----------------------------------signalr-- onreconnecting'</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">onclose</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'--------------------------------signalr-- onclose'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'OnNotify'</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>onNotify<span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'OnLine'</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>onLine<span class="token punctuation">)</span><span class="token punctuation">;</span>    connection<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'OffLine'</span><span class="token punctuation">,</span> config<span class="token punctuation">.</span>offLine<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            option<span class="token punctuation">.</span>onStarted <span class="token operator">&amp;&amp;</span> option<span class="token punctuation">.</span><span class="token function">onStarted</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> option<span class="token punctuation">.</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> connection<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="调用封装的js初始化连接-查看代码"><a href="#调用封装的js初始化连接-查看代码" class="headerlink" title="调用封装的js初始化连接 查看代码"></a>调用封装的js初始化连接 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L183">查看代码</a></h3><ul><li><p>然后在Home/Index.cshtml中引入上面的js  </p></li><li><p>在页面加载完后，调用初始化(案例中使用了vue)<br>在进入页面后会弹窗让用户输入加入的组，可以不输入也可以多个 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">initConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#collectionUserInfo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">modal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      keyboard<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      show<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>      backdrop<span class="token punctuation">:</span> <span class="token string">'static'</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#collectionUserInfo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'hidden.bs.modal'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">var</span> groups <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#groups"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token string">''</span><span class="token punctuation">;</span>      connect<span class="token operator">=</span><span class="token function">initSignalr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          delay<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          url<span class="token punctuation">:</span><span class="token template-string"><span class="token string">`$&amp;#123;notifyUrl&amp;#125;notify-hub?userId=$&amp;#123;vm.userInfo.userName&amp;#125;&amp;group=$&amp;#123;groups&amp;#125;`</span></span><span class="token punctuation">,</span>          loggingLevel<span class="token punctuation">:</span> signalR<span class="token punctuation">.</span>LogLevel<span class="token punctuation">.</span>Error<span class="token punctuation">,</span>          onNotify<span class="token punctuation">:</span> dealNotify<span class="token punctuation">,</span>          onLine<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>IsFirst<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                  <span class="token function">getOnlineUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>              <span class="token function">getOnlineGroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              vm<span class="token punctuation">.</span>logs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`新连接上线：$&amp;#123;JSON.stringify(data)&amp;#125;`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>          offLine<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>IsLast<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                  <span class="token function">getOnlineUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>              <span class="token function">getOnlineGroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              vm<span class="token punctuation">.</span>logs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`连接下线：$&amp;#123;JSON.stringify(data)&amp;#125;`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>          onStarted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              <span class="token function">getOnlineUsers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">getOnlineGroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              vm<span class="token punctuation">.</span>$<span class="token keyword">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>userInfo<span class="token punctuation">,</span> <span class="token string">'connectionId'</span><span class="token punctuation">,</span> connect<span class="token punctuation">.</span>connectionId<span class="token punctuation">)</span><span class="token punctuation">;</span>              vm<span class="token punctuation">.</span>$<span class="token keyword">set</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>userInfo<span class="token punctuation">,</span> <span class="token string">'groups'</span><span class="token punctuation">,</span> groups<span class="token punctuation">)</span><span class="token punctuation">;</span>              vm<span class="token punctuation">.</span>logs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'连接成功'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>onNotify方法，如果仔细的话会看到里面的onNotify方法，所有的推送最终都会调用到该方法来进行分发。<a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L200">查看代码</a><br>offLine，当有客户端下线的时候会触发，data里面包含有用户Id、连接Id、是否该用户的最后一个连接,可根据需要使用<a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L201-L207">查看代码</a><br>onLine,当用户连接的时候会触发，data里面包含有用户Id、连接Id、是否该用户的第一个连接(用于用户上线后的逻辑处理)，可根据需要使用  <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L208-L214">查看代码</a><br>onStarted，当成功连接后触发，可用于做一些连接后的业务逻辑处理，可根据需要使用 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L215-L221">查看代码</a>  </p></li></ul><h3 id="获取当前用户信息、在线列表"><a href="#获取当前用户信息、在线列表" class="headerlink" title="获取当前用户信息、在线列表"></a>获取当前用户信息、在线列表</h3><p>在用户连接成功后，获取当前在线用户、用户组、当前用户信息,并设置到vue的data中 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L216-L217">查看代码</a>  </p><h3 id="模拟一个任务分配"><a href="#模拟一个任务分配" class="headerlink" title="模拟一个任务分配"></a>模拟一个任务分配</h3><p>在项目中心中，点击”模拟推送待办”按钮，将会向当前用户所在组中推送一条代码消息，可以登录不同账号、开多个tab页体验<br>点击事件代码位置 <a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L132-L141">查看代码</a> </p><pre class=" language-js"><code class="language-js">assignTaskToUser<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        type<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>        url<span class="token punctuation">:</span> <span class="token string">'/api/ServerProxy/AssignTaskToUser'</span><span class="token punctuation">,</span>        data<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            groups<span class="token punctuation">:</span>that<span class="token punctuation">.</span>userInfo<span class="token punctuation">.</span>groups        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>对应的推送解析代码 </p><blockquote><p>首先当有推送过来的时候，会首先进到onNotify方法，然后根据不同类型在分配到不同的js方法中<br><a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L268-L279">查看代码</a><br>效果图<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190927212304.png" alt="20190927212304.png"></p></blockquote><h3 id="模拟发送消息"><a href="#模拟发送消息" class="headerlink" title="模拟发送消息"></a>模拟发送消息</h3><p>消息发送，可以选定组、人进行消息发送<br><a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L145-L157">发送端代码</a><br><a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Client/Views/Home/Index.cshtml#L281-L290">解析端</a></p><h3 id="登录互斥"><a href="#登录互斥" class="headerlink" title="登录互斥"></a>登录互斥</h3><p>登录互斥是指，当一个账号在A电脑登录，然后再在B电脑登录，最后的登录会排斥掉开始的登录，即，将A上的挤下线<br>首先用谷歌浏览器登录，输入用户名：xiexingen，然后连接<br>接着使用360急速浏览器登录，输入用户名:xiexingen 这个时候会发现谷歌浏览器中的登录已经退出，如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190927213637.png" alt="20190927213637.png"></p><blockquote><p>必要条件: 不同浏览器、同一用户,比如:同一个浏览器，不同tab就不算(能共用cookie)</p></blockquote><h3 id="文件下载-指定连接推送"><a href="#文件下载-指定连接推送" class="headerlink" title="文件下载(指定连接推送)"></a>文件下载(指定连接推送)</h3><p>文件下载的场景，用户在操作页面上选择了上千个文件，然后点击打包下载，这个时候可能需要很久时间才反应回来，那么这段时间如果让用户一直等待显然不妥，所以，当用户点击打包下载的时候，后端启用一个后台线程去打包、压缩，然后立即返回；用户可以继续操作，当服务器端打包好后推送给用户端，用户点击下载即可。<br>此处分两种情况  </p><ol><li>单连接推送<br>用户开了多个tab页，在其中一个上下载文件，如果后端推送的时候，直接给该用户推，显然不妥；正确的做法一个是只给操作的那个tab页推，这就需要，调用服务器端业务api的时候，需要把当前tab页对应的连接id发送到服务器端，服务器端处理完业务后，调用推送服务器，告诉推送服务器只推我给你的这个连接的客户端，这样就能指定连接推送。</li><li>单用户排除某个连接的其他连接推送<br>这种情况比较少见，告诉推送服务器，给这个用户，除了某个连接外的其他所有连接推送</li></ol><p>模拟操作<br>点击第一个图中的”打包下载文件” 按钮，当前页面会受到文件下载的推送<br>在点击图二中的”推送当前用户其他页面更新操作”按钮，会发现出了当前tab页外，其他tab也都收到了推送消息，如下图<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190927214530.png" alt="20190927214530.png"></p><p>至此，signalr相关文章算是到此结束了，下一篇谈谈个人的一点心得以及里面存着的一些问题。</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/10/04/dotnetcore/signalr/07-self-manager/">.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/05/dotnetcore/signalr/09-todo/">.net core 3.0 Signalr - 09 待改进&amp;交流</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接</title>
      <link href="2019/10/04/dotnetcore/signalr/07-self-manager/"/>
      <url>2019/10/04/dotnetcore/signalr/07-self-manager/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接</p><a id="more"></a><h2 id="Hub的管理"><a href="#Hub的管理" class="headerlink" title="Hub的管理"></a>Hub的管理</h2><ul><li><p>重写OnConnectedAsync<br>从连接信息中获取UserId、Groups,ConnectId，并实现这三者的关系，存放于redis中<br><a href="https://github.com/xiexingen/CTS.Signalr/blob/master/CTS.Signalr.Server/Hubs/NotifyHub.cs">代码请查看</a></p><pre class=" language-C#"><code class="language-C#">using CTS.Signalr.Server.Cores;using CTS.Signalr.Server.Dtos;using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.SignalR;using Microsoft.Extensions.Logging;using System;using System.Linq;using System.Threading.Tasks;namespace CTS.Signalr.Server.Hubs&#123;    /// <summary>    /// 服务端接口    /// </summary>    public interface IServerNotifyHub    &#123;    &#125;    /// <summary>    /// 客户端使用的接口    /// </summary>    public interface IClientNotifyHub    &#123;        Task OnNotify(object data);        Task OnLine(object data);        Task OffLine(object data);    &#125;</code></pre></li></ul><pre><code>  [Authorize]  public class NotifyHub : Hub&lt;IClientNotifyHub&gt;,IServerNotifyHub  &#123;      private readonly SignalrRedisHelper _signalrRedisHelper;      private readonly ILogger _logger;      public NotifyHub(SignalrRedisHelper signalrRedisHelper, ILogger&lt;NotifyHub&gt; logger)      &#123;          _signalrRedisHelper = signalrRedisHelper;          _logger = logger;      &#125;      public override async Task OnConnectedAsync()      &#123;          //await Clients.All.OnNotify(new &#123; UserId= Context.User.Identity.Name, Name=Context.User.Identity.Name, ConnectId = Context.ConnectionId &#125;);          var userId= Context.User.Identity.Name;          var groups=Context.GetHttpContext().Request.Query[&quot;group&quot;].FirstOrDefault();          _logger.LogDebug($&quot;OnConnectedAsync----userId:&#123;userId&#125;,groups:&#123;groups&#125;,connectionId:&#123; Context.ConnectionId&#125;&quot;);          if (!string.IsNullOrWhiteSpace(userId))          &#123;              await _signalrRedisHelper.AddConnectForUserAsync(userId, Context.ConnectionId);              await JoinToGroup(userId, Context.ConnectionId, groups?.Split(&#39;,&#39;));              await DealOnLineNotify(userId, Context.ConnectionId);          &#125;          await base.OnConnectedAsync();      &#125;      public override async Task OnDisconnectedAsync(Exception exception)      &#123;          var userId = Context.User.Identity.Name;          var groups = Context.GetHttpContext().Request.Query[&quot;group&quot;].FirstOrDefault();          _logger.LogDebug($&quot;OnDisconnectedAsync----userId:&#123;userId&#125;,groups:&#123;groups&#125;,connectionId:&#123; Context.ConnectionId&#125;&quot;);          if (!string.IsNullOrWhiteSpace(userId))          &#123;              await _signalrRedisHelper.RemoveConnectForUserAsync(userId, Context.ConnectionId);              await DealOffLineNotify(userId,Context.ConnectionId);          &#125;          await LeaveFromGroup(Context.ConnectionId, groups?.Split(&#39;,&#39;));          await base.OnDisconnectedAsync(exception);      &#125;      /// &lt;summary&gt;      /// 加入组      /// &lt;/summary&gt;      /// &lt;param name=&quot;groupName&quot;&gt;&lt;/param&gt;      /// &lt;returns&gt;&lt;/returns&gt;      private async Task JoinToGroup(string userId,string connectionId,params string[] groups)      &#123;          if (!string.IsNullOrWhiteSpace(userId)&amp;&amp; groups!=null&amp;&amp;groups.Length&gt;0)          &#123;              foreach (var group in groups)              &#123;                  await Groups.AddToGroupAsync(connectionId, group);                  await _signalrRedisHelper.AddUserForGroupAsync(group, connectionId, userId);                  // await Clients.Group(group).OnJoinGroup(new &#123; ConnectId = connectionId, UserId = userId, GroupName = group &#125;);              &#125;          &#125;      &#125;      /// &lt;summary&gt;      /// 从组中移除      /// &lt;/summary&gt;      /// &lt;param name=&quot;groupName&quot;&gt;&lt;/param&gt;      /// &lt;returns&gt;&lt;/returns&gt;      private async Task LeaveFromGroup(string connectionId,params string[] groups)      &#123;          if (groups != null &amp;&amp; groups.Length &gt; 0)          &#123;              foreach (var group in groups)              &#123;                  await Groups.RemoveFromGroupAsync(connectionId, group);                  await _signalrRedisHelper.RemoveConnectFromGroupAsync(group,connectionId);                  // await Clients.Group(group).OnLeaveGroup(new &#123; ConnectId = connectionId, GroupName = group &#125;);              &#125;          &#125;      &#125;      /// &lt;summary&gt;      /// 处理上线通知(只有用户第一个连接才通知)      /// &lt;/summary&gt;      /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;      /// &lt;param name=&quot;connectionId&quot;&gt;&lt;/param&gt;      /// &lt;returns&gt;&lt;/returns&gt;      private async Task DealOnLineNotify(string userId,string connectionId)       &#123;          var userConnectCount = await _signalrRedisHelper.GetConnectsCountByUserAsync(userId);          await Clients.All.OnLine(new OnLineData()          &#123;              UserId = userId,              ConnectionId = connectionId,              IsFirst = userConnectCount == 1          &#125;);      &#125;      /// &lt;summary&gt;      /// 处理下线通知(只有当用户一个连接都没了 才算下线)      /// &lt;/summary&gt;      /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt;      /// &lt;param name=&quot;connectionId&quot;&gt;&lt;/param&gt;      /// &lt;returns&gt;&lt;/returns&gt;      private async Task DealOffLineNotify(string userId,string connectionId)      &#123;          var userConnectCount = await _signalrRedisHelper.GetConnectsCountByUserAsync(userId);          await Clients.All.OffLine(new OffLineData()          &#123;              UserId = userId,              ConnectionId = connectionId,              IsLast = userConnectCount == 0          &#125;);      &#125;  &#125;</code></pre><p>  }</p><pre><code>## 提供给业务系统调用的API- [POST] api/notify/post application/json形式 提交，数据格式如下``` json&#123;  GroupIds:&#39;&#39;, // [可空] 组id集合，多个用,隔开  UserIds:&#39;&#39;,// [可空] 用户id集合，多个用,隔开  ExcludeUsers:boolean, // 是否排除用户列表中的用户  NotifyObj:Object // 通知的对象，任意类型(总大小不要超过36k)&#125;</code></pre><ul><li><p>有GroupIds</p><ul><li><p>ExcludeUsers=true<br>推送给指定的组中所有用户(排除掉UserIds部分)</p></li><li><p>ExcludeUsers=false<br>推送给组中指定(UserIds中指定的)的这些用户</p></li></ul></li><li><p>无GroupIds</p><ul><li><p>ExcludeUsers=true<br>推送给当前所有连接(排除掉UserIds部分的用户)</p></li><li><p>ExcludeUsers=false<br>推送给指定用户(UserIds中指定的用户)</p></li></ul></li></ul><ul><li><p>[POST] api/notify/postConnects<br>application/json提交，数据格式如下</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>  Connects<span class="token operator">:</span>''<span class="token punctuation">,</span> // 连接Id集合，多个用，隔开  NotifyObj<span class="token operator">:</span>Object // 通知的对象，任意类型(总大小不要超过36k<span class="token punctuation">)</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>有UserId<ul><li>ExcludeConnectId=true<br>给改用户除指定的ConnectId外的所有连接端推送</li><li>ExcludeConnectId=false<br>跟没指定UserId一致</li></ul></li><li>无UserId<br>给指定连接Id推送</li></ul></li><li><p>[GET] api/users<br>获取在线用户Id列表</p></li><li><p>[GET] api/groups<br>获取在线组列表</p></li></ul><h2 id="增加日志记录"><a href="#增加日志记录" class="headerlink" title="增加日志记录"></a>增加日志记录</h2><p>为了方便分析和定位问题，使用log4net来作为日志记录器。</p><ul><li><p>nuget 安装log4net<br>nuget 搜索 log4net，安装</p></li><li><p>Config中配置<br>在Config中注入ILoggerFactory，然后使用添加Log4Net,代码如下所示</p><pre class=" language-C#"><code class="language-C#">public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory)&#123;  if (env.IsDevelopment())  &#123;      app.UseDeveloperExceptionPage();  &#125;  app.UseHsts();  loggerFactory.AddLog4Net();  ...&#125;</code></pre></li><li><p>添加log4net配置文件<br>更多配置请自行查找log4net官方配置文档</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token comment" spellcheck="true">&lt;!--LOG4日志级别   0：TRACE；记录一些对程序员调试问题有帮助的信息, 其中可能包含一些敏感信息, 所以应该避免在生产环境中启用Trace日志。  1：DEBUG；记录一些在开发和调试阶段有用的短时变量(Short-term usefulness), 所以除非为了临时排除生产环境的故障，开发人员应该尽量避免在生产环境中启用Debug日志。  2：INFO；信息日志，记录应用程序的一些流程, 例如，记录当前api请求的url，请求参数等。  3：WARN；警告日志；记录应用程序中发生的不正常或者未预期的事件信息。这些信息中可能包含错误消息或者错误产生的条件, 例如, 文件未找到，用户不存在。  4：ERROR；错误日志；记录应用程序中某个操作产生的错误和异常信息，如对空值进行操作等。  5：FATAL；毁灭性错误；记录一些需要立刻修复的问题。例如数据丢失，磁盘空间不足。trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>log4net</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ErrorRollingFileAppender<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>log4net.Appender.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AppData\\logs\\<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appendToFile</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingStyle</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Date<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>datePattern</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yyyy-MM-dd-<span class="token punctuation">'</span>error.log<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxSizeRollBackups</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>staticLogFileName</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>log4net.Layout.PatternLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>conversionPattern</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>%-5level %date [%-5.5thread] %-40.40logger - %message%newline<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>log4net.Filter.LevelRangeFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>levelMin</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ERROR<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>levelMax</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FATAL<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>All<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ErrorRollingFileAppender<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>log4net</span><span class="token punctuation">></span></span></code></pre><p>至此，log4net配置完毕</p></li></ul><p>更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/10/03/dotnetcore/signalr/06-analysis/">.net core 3.0 Signalr - 06 业务实现-业务分析</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/05/dotnetcore/signalr/08-clientdemo/">.net core 3.0 Signalr - 08 业务实现-客户端demo</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 06 业务实现-业务分析</title>
      <link href="2019/10/03/dotnetcore/signalr/06-analysis/"/>
      <url>2019/10/03/dotnetcore/signalr/06-analysis/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 06 业务实现-业务分析</p><a id="more"></a><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ol><li>人-项目关系<br>一个人可以属于多个项目，一个项目可以有多个人加入，通知的时候，可以通知项目内的所有人，也可以通知部分人或者某个责任人。</li><li>登录互斥<br>同一个人不允许登录两次(不同浏览器或者不同电脑登)，后面登录的会将前面登录的人挤下线。</li><li>聊天<br>可以私聊、也可以创建群聊、上线通知(多个连接的情况)</li><li>文件下载<br>用户在界面上选择了多个文件，然后选择批量打包下载，后端后台线程进行压缩、压缩完成后通过signalr通知该用户(的某个连接,比如当前用户开了多个tab页，应该只能推送给操作的那个tab页)</li></ol><h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><blockquote><p>名词解释: 业务系统:具体业务功能的系统     推送系统:实际的Signalr系统，跟业务系统分开部署</p></blockquote><ol><li>将推送单独成一个子系统；支持单独部署，可一台服务器也可以多台，通过redis作为底板来分发到服务器</li><li>推送子系统端自定义管理用户、连接、组，业务系统调用的时候</li><li>推送系统开发一个api，给业务系统直接调用(当然这不是最佳选择，可以通过消息队列，支持重试、优先级等，性能会比http形式好很多)<br>业务系统调用推送系统的时候传递参数包括，组、用户、推送数据对象，比如如下代码  <pre class=" language-C#"><code class="language-C#">var send = new Send()&#123;   // 推送的组，多个用,隔开   GroupId = GroupId,   // 关联的UserId 多个用,隔开   UserIds= UserIds,   // 是否排除用户   ExcludeUsers=ExcludeUsers,   // 实际推送的对象   NotifyObj = new NotifyObj()   &#123;       Data = Data,       NotifyType = NotifyType,       OpType= OpType   &#125;,&#125;;</code></pre></li></ol><ul><li><p>有GroupId</p><ul><li><p>ExcludeUsers=true<br>推送给指定的组中所有用户(排除掉UserIds部分)</p></li><li><p>ExcludeUsers=false<br>推送给组中指定(UserIds中指定的)的这些用户</p></li></ul></li><li><p>无GroupId</p><ul><li><p>ExcludeUsers=true<br>推送给当前所有连接(排除掉UserIds部分的用户)</p></li><li><p>ExcludeUsers=false<br>推送给指定用户(UserIds中指定的用户)</p></li></ul></li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ol><li>组、用户、连接的关系</li></ol><ul><li>用户:[连接Id]<br>一个用户用多个连接、以Set形式存redis中</li><li>组:[连接Id:用户Id]<br>以Redis中的Hash格式存储，以Group为Key，以连接Id为Name，以UserId为值，一个用户在组中可能多个连接(开多个浏览器tab页),这样设计的好处是可以满足以下的几种情况<ul><li>给某个人推送<br>从redis中直接根据该用户的UserId查询该用户的所有连接，然后通过连接推送即可</li><li>给某个组推送<br>从redis中根据组名查询出所有的连接Id，通过连接直接推送</li><li>给某个组中的某些人推<br>这个时候不能根据人查连接Id，需要先根据组得到组中的人、连接Id，然后只给组中这些人对应的连接推送</li><li>用户上线的时候<br>在redis中存储一份用户与连接的关系；如果有组的情况，同时以Hash形式存储组、连接Id、用户Id</li><li>用户再开一个浏览器tab页<br>在redis中该用户对应的连接中增加新的连接Id；如果有组的情况，同时以Hash形式存储组、连接Id、用户Id(因为是一连接Id为name的，然而连接Id是不重复的，所以是可以存着同一个组、同一个用户不同连接这种情况的)</li><li>用户退出页面<br>在redis中找到该用户，从redis中删除改用户的找个连接Id，组的情况同样处理</li><li>给某个用户的某个连接Id推送<br>比如:用户点击打包下载，服务器端后台线程进行打包、压缩，完成后推送给指定的连接Id，前端界面再进行处理下载</li></ul></li></ul><p>至此，业务分析完毕，更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/10/02/dotnetcore/signalr/05-jwt/">.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/04/dotnetcore/signalr/07-self-manager/">.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联</title>
      <link href="2019/10/02/dotnetcore/signalr/05-jwt/"/>
      <url>2019/10/02/dotnetcore/signalr/05-jwt/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联</p><a id="more"></a><p>Signalr是以Group、Connect为核心来进行推送，比如，给某个组、某个连接来推送，但实际场景中，核心应该是某个组、某个人；然而一个人可以对应多个连接(浏览器多个tab页)；本节就来介绍下自行管理人、组、连接这些关系<br>由于signalr连接的时候不那么方便附带header和cookie(因为推送独立成一个子系统了)，实际实现中采用以url query的形式附带上token，然后服务器端自定义解析token得到用户信息；</p><h2 id="服务器端实现"><a href="#服务器端实现" class="headerlink" title="服务器端实现"></a>服务器端实现</h2><ul><li><p>ConfigureServices中添加服务相关方法，代码如下,完整代码</p><pre class=" language-C#"><code class="language-C#">public void ConfigureServices(IServiceCollection services)&#123;    var appSection = Configuration.GetSection("App");    services.Configure<AppSetting>(option => appSection.Bind(option));    var appSetting = appSection.Get<AppSetting>();    services.AddSingleton<SignalrRedisHelper>();    // services.AddHostedService<ClearBackGroundService>();    services.AddAuthentication(options =>    &#123;        options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;        options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;        options.DefaultForbidScheme = JwtBearerDefaults.AuthenticationScheme;    &#125;)    .AddJwtBearer(option =>    &#123;        option.SecurityTokenValidators.Clear();        option.SecurityTokenValidators.Add(new UserTokenValidation()); ;        option.Events = new JwtBearerEvents()        &#123;            OnMessageReceived = context =>            &#123;                var userId = context.Request.Query["userId"].FirstOrDefault();                if (!string.IsNullOrWhiteSpace(userId))                &#123;                    context.Token = userId;                &#125;                return Task.CompletedTask;            &#125;        &#125;;    &#125;);    services.AddCors(options => options.AddPolicy(corsPolicy, builder =>    &#123;        builder              .SetIsOriginAllowedToAllowWildcardSubdomains()              .WithOrigins(appSetting.CORS.Split(","))              .AllowAnyMethod()              .AllowCredentials()              .AllowAnyHeader()              .Build();    &#125;));    services.AddControllers()        .AddNewtonsoftJson(options => options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver())        .ConfigureApiBehaviorOptions(options =>        &#123;            options.InvalidModelStateResponseFactory = context =>            &#123;                var result = new BadRequestObjectResult(context.ModelState);                result.ContentTypes.Add(MediaTypeNames.Application.Json);                // result.ContentTypes.Add(MediaTypeNames.Application.Xml);                return result;            &#125;;        &#125;)        .SetCompatibilityVersion(CompatibilityVersion.Version_3_0);    // 添加Signalr    services.AddSignalR(config =>    &#123;        if (_webEnv.IsDevelopment())        &#123;            config.EnableDetailedErrors = true;        &#125;    &#125;)    // 支持MessagePack    .AddMessagePackProtocol()    // 使用redis做底板 支持横向扩展 Scale-out    .AddStackExchangeRedis(o =>      &#123;          o.ConnectionFactory = async writer =>          &#123;              var config = new ConfigurationOptions              &#123;                  AbortOnConnectFail = false,                  // Password = "changeme",                  ChannelPrefix = "__signalr_",              &#125;;              //config.EndPoints.Add(IPAddress.Loopback, 0);              //config.SetDefaultPorts();              config.DefaultDatabase = appSetting.SignalrRedisCache.DatabaseId;              var connection = await ConnectionMultiplexer.ConnectAsync(appSetting.SignalrRedisCache.ConnectionString, writer);              connection.ConnectionFailed += (_, e) =>              &#123;                  Console.WriteLine("Connection to Redis failed.");              &#125;;              if (connection.IsConnected)              &#123;                  Console.WriteLine("connected to Redis.");              &#125;              else              &#123;                  Console.WriteLine("Did not connect to Redis");              &#125;              return connection;          &#125;;      &#125;);&#125;</code></pre><p>其中，SignalrRedisHelper 为redis辅助方法，<a href="https://github.com/xiexingen/CTS.Signalr/blob/master/Core.Signalr.Template.Web/Cores/SignalrRedisHelper.cs">详情请参见</a><br>UserTokenValidation 为自定义token解析方法，<a href="https://github.com/xiexingen/CTS.Signalr/blob/master/Core.Signalr.Template.Web/Cores/UserTokenValidation.cs">详情请参见</a>,由于历史遗留问题，此处直接使用了userId，建议的做法是传递jwttoken，然后服务器端解析jwt token得到用户信息    </p></li></ul><h2 id="Hub中跟用户关联"><a href="#Hub中跟用户关联" class="headerlink" title="Hub中跟用户关联"></a>Hub中跟用户关联</h2><p>在Hub中通过Context.User.Identity.Name可以获取到解析的值，通过这种关系来跟用户关联上，当然，也可以自定义修改使用其他信息，比如Email或其他自定义的名称，具体请google</p><p>更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/10/01/dotnetcore/signalr/04-redis/">.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/03/dotnetcore/signalr/06-analysis/">.net core 3.0 Signalr - 06 业务实现-业务分析</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展</title>
      <link href="2019/10/01/dotnetcore/signalr/04-redis/"/>
      <url>2019/10/01/dotnetcore/signalr/04-redis/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展</p><a id="more"></a><p>在实际的系统中，可能需要多台机器部署;然而，Signalr的连接信息是跟站点走的，举个例子<br>推送系统部署了A、B两个服务器，张三访问A服务器，李四访问B服务器，当张三通过A服务器向李四推送的时候，A服务器上是找不到李四的连接信息的，自然也就推送不过了，这个时候就需要有一个统一协调的玩意，signalr支持多种，Azure、Redis等，本节以Redis作为底板，介绍如何在Signalr中使用Redis作为底板来支持横向扩展。</p><h2 id="引入Redis"><a href="#引入Redis" class="headerlink" title="引入Redis"></a>引入Redis</h2><ul><li><p>先引入NuGet包<br>Microsoft.AspNetCore.SignalR.StackExchangeRedis</p></li><li><p>修改Startup中的ConfigureServices方法</p><pre class=" language-C#"><code class="language-C#">var appSection = Configuration.GetSection("App");services.Configure<AppSetting>(option => appSection.Bind(option));var appSetting = appSection.Get<AppSetting>();// 添加Signalrservices.AddSignalR(config =>&#123;    if (_webEnv.IsDevelopment())    &#123;        config.EnableDetailedErrors = true;    &#125;&#125;)// 支持MessagePack.AddMessagePackProtocol()// 使用redis做底板 支持横向扩展 Scale-out.AddStackExchangeRedis(o =>  &#123;      o.ConnectionFactory = async writer =>      &#123;          var config = new ConfigurationOptions          &#123;              AbortOnConnectFail = false,              ChannelPrefix = "__signalr_",          &#125;;          config.DefaultDatabase = appSetting.SignalrRedisCache.DatabaseId;          var connection = await ConnectionMultiplexer.ConnectAsync(appSetting.SignalrRedisCache.ConnectionString, writer);          connection.ConnectionFailed += (_, e) =>          &#123;              Console.WriteLine("Connection to Redis failed.");          &#125;;          if (connection.IsConnected)          &#123;              Console.WriteLine("connected to Redis.");          &#125;          else          &#123;              Console.WriteLine("Did not connect to Redis");          &#125;          return connection;      &#125;;  &#125;);</code></pre><p>可以自定义Redis相关配置，此处的appSetting为已经定义好的配置实体，包括了，主要配置、CROS配置、Jwt配置、redis配置等详情如下</p><pre class=" language-C#"><code class="language-C#">/// <summary>/// 对应appsettings中的App节点的配置信息/// </summary>public class AppSetting&#123;    public JwtSetting JwtSetting &#123; set;get;&#125;    public RedisCache RedisCache &#123; set;get;&#125;    public RedisCache SignalrRedisCache &#123; set; get; &#125;    public string CORS &#123; set;get;&#125;    /// <summary>    /// 是否主站点(用于运行清理任务等)    /// </summary>    public bool MainSite &#123; set;get;&#125;&#125;/// <summary>/// JWT设置/// </summary>public class JwtSetting&#123;    /// <summary>    /// 发行者 表示token是谁颁发的    /// </summary>    public string Issuer &#123; set; get; &#125;    /// <summary>    /// 表示哪些客户端可以使用这个token    /// </summary>    public string Audience &#123; set; get; &#125;    /// <summary>    /// 加密的Key 必须大于16位    /// </summary>    public string SecretKey &#123; set; get; &#125;&#125;public class RedisCache&#123;    public string ConnectionString &#123; set;get;&#125;    public int DatabaseId &#123; set; get; &#125;&#125;</code></pre><p>对应的配置文件如下</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span><span class="token property">"Logging"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token property">"LogLevel"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"Default"</span><span class="token operator">:</span> <span class="token string">"Debug"</span><span class="token punctuation">,</span>    <span class="token property">"System"</span><span class="token operator">:</span> <span class="token string">"Information"</span><span class="token punctuation">,</span>    <span class="token property">"Microsoft"</span><span class="token operator">:</span> <span class="token string">"Information"</span><span class="token punctuation">,</span>    <span class="token property">"Microsoft.AspNetCore.SignalR"</span><span class="token operator">:</span> <span class="token string">"Trace"</span><span class="token punctuation">,</span>    <span class="token property">"Microsoft.AspNetCore.Http.Connections"</span><span class="token operator">:</span> <span class="token string">"Trace"</span>  &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token property">"App"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token property">"RedisCache"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"ConnectionString"</span><span class="token operator">:</span> <span class="token string">"127.0.0.1:6379,password=#####,ssl=false,abortConnect=true,connectTimeout=5000"</span><span class="token punctuation">,</span>    <span class="token property">"DatabaseId"</span><span class="token operator">:</span> <span class="token number">10</span>  &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token property">"SignalrRedisCache"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"ConnectionString"</span><span class="token operator">:</span> <span class="token string">"127.0.0.1:6379,password=#####,ssl=false,abortConnect=true,connectTimeout=5000"</span><span class="token punctuation">,</span>    <span class="token property">"DatabaseId"</span><span class="token operator">:</span> <span class="token number">10</span>  &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token property">"CORS"</span><span class="token operator">:</span> <span class="token string">"https://localhost:60000,http://localhost:60001"</span><span class="token punctuation">,</span>  <span class="token property">"MainSite"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"JwtSetting"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"Issuer"</span><span class="token operator">:</span> <span class="token string">"http://localhost:50000"</span><span class="token punctuation">,</span> //颁发者    <span class="token property">"Audience"</span><span class="token operator">:</span> <span class="token string">"http://localhost:50000"</span><span class="token punctuation">,</span> //使用者    <span class="token property">"SecretKey"</span><span class="token operator">:</span> <span class="token string">"Wetrial20196666666"</span> // key 大于<span class="token number">16</span>位  &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>首先，将配置文件跟实体对象映射，下次在其他地方使用的时候可以直接通过DI注入，然后通过AddStackExchangeRedis配置使用redis作为底板</p></li></ul><p>更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/09/29/dotnetcore/signalr/03-message-pack/">.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/02/dotnetcore/signalr/05-jwt/">.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/signalr/redis-backplane?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容</title>
      <link href="2019/09/29/dotnetcore/signalr/03-message-pack/"/>
      <url>2019/09/29/dotnetcore/signalr/03-message-pack/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容</p><a id="more"></a><h2 id="MessagePack基础介绍"><a href="#MessagePack基础介绍" class="headerlink" title="MessagePack基础介绍"></a>MessagePack基础介绍</h2><p>Signalr默认使用的是json形式传递数据，但是signalr提供了灵活的扩展，支持MessagePack形式序列化数据，以增加性能降低网络传输的效果，极大的提高响应速度。</p><p>先看一个MessagePack自定义序列化的例子,以一个自定义的实体对象为例，可以使用MessagepackObject标记为序列化的对象，同时定义使用属性名作为key(区分大小写)，同时可以定义忽略某个属性等、以及自定义key等</p><pre class=" language-C#"><code class="language-C#">  [MessagePackObject(keyAsPropertyName: true)]  public class OffLineData  &#123;      /// <summary>      /// 用户Id      /// </summary>      public string UserId &#123; set; get; &#125;      /// <summary>      /// 连接Id      /// </summary>      public string ConnectionId &#123; set; get; &#125;      /// <summary>      /// 是否该用户的最后一个连接      /// </summary>      public bool IsLast &#123; set; get; &#125;      [IgnoreMember]      public string Test &#123; set;get;&#125;  &#125;  // 比如对象，new OffLineData()&#123;UserId="1000",ConnectionId="AZDEFASDFASDF",IsLast:true&#125;通过MessagePack序列化后应该会是&#123;UserId:"1000",ConnectionId:"AZDEFASDFASDF",IsLast:true&#125;,这个跟常用的json基本相同</code></pre><p>同时MessagePack还可以定义序列化成数组形式，代码如下</p><pre class=" language-C#"><code class="language-C#">  [MessagePackObject]  public class OffLineData    &#123;        /// <summary>        /// 用户Id        /// </summary>        [Key(0)]        public string UserId &#123; set; get; &#125;        /// <summary>        /// 连接Id        /// </summary>        [Key(0)]        public string ConnectionId &#123; set; get; &#125;        /// <summary>        /// 是否该用户的最后一个连接        /// </summary>        [Key(0)]        public bool IsLast &#123; set; get; &#125;    &#125;  // 比如对象，new OffLineData()&#123;UserId="1000",ConnectionId="AZDEFASDFASDF",IsLast:true&#125;通过MessagePack序列化后应该会是["10000","AZDEFASDFASDF",true]</code></pre><p>更多MessagePack的内容可以自行结尾的文档，此处不再过多介绍.</p><h2 id="为Signalr添加MessagePack支持"><a href="#为Signalr添加MessagePack支持" class="headerlink" title="为Signalr添加MessagePack支持"></a>为Signalr添加MessagePack支持</h2><ul><li><p>引入需要的Nuget包<br>Microsoft.AspNetCore.SignalR.Protocols.MessagePack  </p></li><li><p>修改之前的ConfigureServices</p><pre class=" language-C#"><code class="language-C#">  // 添加Signalr  services.AddSignalR(config =>  &#123;      if (_webEnv.IsDevelopment())      &#123;          config.EnableDetailedErrors = true;      &#125;  &#125;)  // 支持MessagePack  .AddMessagePackProtocol();</code></pre></li><li><p>前端引入messagepack解析库<br>由于MessagePack传输是以二进制形式进行传输，降低了带宽，但是同时也增加到了代码的复杂度，原本直接获取数据就可以用的，现在需要先将二进制数据转换成正常数据，好在官方提供了对应的js库<em>msgpack5</em>、<em>signalr-protocol-msgpack</em><br>可以通过vs的包管理工具或者npm安装，然后拷贝需要的文件到项目的lib文件夹,比如我的结构是</p><pre class=" language-bash"><code class="language-bash">  signalr-protocol-msgpack  <span class="token operator">|</span>-msgpack5.js  <span class="token operator">|</span>-msgpack5.min.js  <span class="token operator">|</span>-signalr-protocol-msgpack.js  <span class="token operator">|</span>-signalr-protocol-msgpack.min.js</code></pre><p>前端页面引入这两个js(注意顺序:signalr、msgpack5、signalr-protocol-msgpack)  </p></li><li><p>修改js连接对象，支持上MessagePack</p><pre class=" language-js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">signalR<span class="token punctuation">.</span>HubConnectionBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">configureLogging</span><span class="token punctuation">(</span>signalR<span class="token punctuation">.</span>LogLevel<span class="token punctuation">.</span>Error<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 前端控制台的日志级别，根据需要配置</span>  <span class="token punctuation">.</span><span class="token function">withUrl</span><span class="token punctuation">(</span><span class="token string">'http://localhost:50001/notify-hub'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 连接地址,这个地址是signalr项目的地址</span>  <span class="token punctuation">.</span><span class="token function">withHubProtocol</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">signalR<span class="token punctuation">.</span>protocols<span class="token punctuation">.</span>msgpack<span class="token punctuation">.</span>MessagePackHubProtocol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 使用Messagepack来解析推送的数据</span>  <span class="token punctuation">.</span><span class="token function">withAutomaticReconnect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 配置重连的时间</span>  <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 重连的时候触发</span>  connection<span class="token punctuation">.</span><span class="token function">onreconnecting</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'----------------------------------signalr-- onreconnecting'</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//连接关闭的回调</span>  connection<span class="token punctuation">.</span><span class="token function">onclose</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'--------------------------------signalr-- onclose'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  connection<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'已成功连接到signalr服务器'</span><span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="尚未解决问题"><a href="#尚未解决问题" class="headerlink" title="尚未解决问题"></a>尚未解决问题</h2><p>发现通过json.net序列化得到的对象，直接传递给MessagePack序列化会报错，没找着解决方法，直接改成字符串传递，然后在前端解析了，有遇到过的大佬欢迎指点下</p><p>至此，MessagePack介绍算结束了，更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/09/22/dotnetcore/signalr/02-type-hub/">.net core 3.0 Signalr - 02 使用强类型的Hub</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/10/01/dotnetcore/signalr/04-redis/">.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr><tr><td align="left">MessagePack-CSharp</td><td align="left"><a href="https://github.com/neuecc/MessagePack-CSharp">MessagePack-CSharp</a></td></tr><tr><td align="left">MessagePack</td><td align="left"><a href="https://msgpack.org/index.html">MessagePack</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 02 使用强类型的Hub</title>
      <link href="2019/09/22/dotnetcore/signalr/02-type-hub/"/>
      <url>2019/09/22/dotnetcore/signalr/02-type-hub/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 02 使用强类型的Hub</p><a id="more"></a><h2 id="强类型的优缺点"><a href="#强类型的优缺点" class="headerlink" title="强类型的优缺点"></a>强类型的优缺点</h2><ul><li>优点<br>强类型的Hub可以避免魔法函数名，相比弱类型更容易维护和发现问题，直接上代码</li><li>缺点<br>特么的得多些好几行代码</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><pre class=" language-C#"><code class="language-C#">  /// <summary>  /// 服务端接口  /// </summary>  public interface IServerNotifyHub  &#123;  &#125;  /// <summary>  /// 客户端使用的接口  /// </summary>  public interface IClientNotifyHub  &#123;      // 这里我们定义一个统一的客户端通知方法      Task OnNotify(object data);  &#125;</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>对之前的Hub进行修改,暂时就先通过OnNotify给当前所有客户端推送一个信息<pre class=" language-C#"><code class="language-C#">public class NotifyHub : Hub<IClientNotifyHub>,IServerNotifyHub  &#123;      public override async Task OnConnectedAsync()      &#123;          await Clients.All.OnNotify(new &#123; ConnectId = Context.ConnectionId &#125;);          await base.OnConnectedAsync();      &#125;  &#125;</code></pre></li></ul><h2 id="在api中调用Hub推送"><a href="#在api中调用Hub推送" class="headerlink" title="在api中调用Hub推送"></a>在api中调用Hub推送</h2><p>大部分情况下，是通过客户端某个操作，比如:将任务分配给张三，那么在分配任务的这个api中会调用推送 推送给张三一个通知，xxx分配了一个任务给你，在Controller中注入强类型的Hub，代码如下</p><pre class=" language-C#"><code class="language-C#">...private readonly IHubContext<NotifyHub,IClientNotifyHub> _notifyHub;public NotifyController(IHubContext<NotifyHub,IClientNotifyHub> notifyHub)&#123;    _notifyHub = notifyHub;&#125;</code></pre><p>至此，强类型的Hub介绍完毕，更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">上一篇</td><td align="left"><a href="/2019/09/21/dotnetcore/signalr/01-base/">.net core 3.0 Signalr - 01 基础篇</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/09/29/dotnetcore/signalr/03-message-pack">.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 01 基础篇</title>
      <link href="2019/09/21/dotnetcore/signalr/01-base/"/>
      <url>2019/09/21/dotnetcore/signalr/01-base/</url>
      
        <content type="html"><![CDATA[<p>.net core 3.0 Signalr - 01 基础篇 以最简洁的方式介绍如何创建一个可连接的hub</p><a id="more"></a><p>因为将signalr作为单独的站点，此处需要建立两个项目，一个专门用于signalr作为推送项目，一个客户端(实际的业务项目)</p><h2 id="基础知识速览"><a href="#基础知识速览" class="headerlink" title="基础知识速览"></a>基础知识速览</h2><h3 id="Clients对象属性"><a href="#Clients对象属性" class="headerlink" title="Clients对象属性"></a>Clients对象属性</h3><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">All</td><td align="left">在所有连接的客户端上调用方法</td></tr><tr><td align="left">Caller</td><td align="left">在调用集线器方法的客户端上调用方法</td></tr><tr><td align="left">Others</td><td align="left">除当前连接外的所有连接</td></tr></tbody></table><h3 id="Clients对象方法"><a href="#Clients对象方法" class="headerlink" title="Clients对象方法"></a>Clients对象方法</h3><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">AllExcept</td><td align="left">在所有连接的客户端（指定的连接除外）上调用方法</td></tr><tr><td align="left">Client</td><td align="left">在特定连接的客户端上调用方法(单个)</td></tr><tr><td align="left">Clients</td><td align="left">在特定连接的客户端上调用方法(多个)</td></tr><tr><td align="left">Group</td><td align="left">对指定组中的所有连接调用方法</td></tr><tr><td align="left">GroupExcept</td><td align="left">对指定组中的所有连接调用方法，指定的连接除外</td></tr><tr><td align="left">Groups</td><td align="left">在多组连接上调用方法</td></tr><tr><td align="left">OthersInGroup</td><td align="left">对一组连接调用方法，而不包括调用该集线器方法的客户端</td></tr><tr><td align="left">User</td><td align="left">对与特定用户关联的所有连接调用方法</td></tr><tr><td align="left">Users</td><td align="left">对与指定用户相关联的所有连接调用方法</td></tr></tbody></table><h2 id="Signalr推送端"><a href="#Signalr推送端" class="headerlink" title="Signalr推送端"></a>Signalr推送端</h2><ul><li><p>通过命令行或者vs 2019新建.netcore web项目，选择.net core 3.0、webapi  </p></li><li><p>建立一个Hub</p><pre class=" language-C#"><code class="language-C#">public class NotifyHub : Hub&#123;&#125;</code></pre></li><li><p>修改Startup中的ConfigServices方法，注册对应的服务</p><pre class=" language-C#"><code class="language-C#">// 添加Signalrservices.AddSignalR(config =>&#123;    // _webEnv为通过依赖注入在Startup的构造函数中注入的 IWebHostEnvironment    if (_webEnv.IsDevelopment())    &#123;        config.EnableDetailedErrors = true;    &#125;&#125;);</code></pre></li><li><p>修改Configure配置HTTP请求的管道</p><pre class=" language-C#"><code class="language-C#">...app.UseRouting();app.UseEndpoints(endpoints =>&#123;    endpoints.MapHub<NotifyHub>("/notify-hub");&#125;);</code></pre><h2 id="业务端"><a href="#业务端" class="headerlink" title="业务端"></a>业务端</h2><p><a href="https://docs.microsoft.com/zh-CN/aspnet/core/tutorials/signalr?view=aspnetcore-3.0&tabs=visual-studio">相关文档</a></p></li><li><p>创建连接对象</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> connection<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">signalR<span class="token punctuation">.</span>HubConnectionBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">configureLogging</span><span class="token punctuation">(</span>signalR<span class="token punctuation">.</span>LogLevel<span class="token punctuation">.</span>Error<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 前端控制台的日志级别，根据需要配置</span><span class="token punctuation">.</span><span class="token function">withUrl</span><span class="token punctuation">(</span><span class="token string">'http://localhost:50001/notify-hub'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 连接地址,这个地址是signalr项目的地址</span><span class="token punctuation">.</span><span class="token function">withAutomaticReconnect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 配置重连的时间</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 重连的时候触发</span>connection<span class="token punctuation">.</span><span class="token function">onreconnecting</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'----------------------------------signalr-- onreconnecting'</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//连接关闭的回调</span>connection<span class="token punctuation">.</span><span class="token function">onclose</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'--------------------------------signalr-- onclose'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>connection<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'已成功连接到signalr服务器'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>更多内容请通过快速导航查看下一篇</p><h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><table><thead><tr><th align="left">标题</th><th align="left">内容</th></tr></thead><tbody><tr><td align="left">索引</td><td align="left"><a href="/2019/09/20/dotnetcore/signalr/00-introduct/">.net core 3.0 Signalr - 实现一个业务推送系统</a></td></tr><tr><td align="left">下一篇</td><td align="left"><a href="/2019/09/22/dotnetcore/signalr/02-type-hub/">.net core 3.0 Signalr - 02 使用强类型的Hub</a></td></tr><tr><td align="left">源码地址</td><td align="left"><a href="https://github.com/xiexingen/CTS.Signalr">源码</a></td></tr><tr><td align="left">官方文档</td><td align="left"><a href="https://docs.microsoft.com/zh-CN/aspnet/core/?view=aspnetcore-3.0">官方文档</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.net core 3.0 Signalr - 实现一个业务推送系统</title>
      <link href="2019/09/20/dotnetcore/signalr/00-introduct/"/>
      <url>2019/09/20/dotnetcore/signalr/00-introduct/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ASP.NET Core SignalR 是一个开源代码库，它简化了向应用添加实时 Web 功能的过程。 实时 Web 功能使服务器端代码能够即时将内容推送到客户端。<br>SignalR 的适用对象：  </p><ul><li>需要来自服务器的高频率更新的应用。 例如：游戏、社交网络、投票、拍卖、地图和 GPS 应用。</li><li>仪表板和监视应用。 示例包括公司仪表板、销售状态即时更新或行程警示。</li><li>协作应用。 协作应用的示例包括白板应用和团队会议软件。</li><li>需要通知的应用。 社交网络、电子邮件、聊天、游戏、行程警示以及许多其他应用都使用通知。<br>SignalR 提供了一个用于创建服务器到客户端远程过程调用（RPC）的 API。 RPC 通过服务器端 .NET Core 代码调用客户端上的 JavaScript 函数。<br>以下是 ASP.NET Core SignalR 的一些功能：</li><li>自动管理连接。</li><li>同时向所有连接的客户端发送消息。 例如，聊天室。</li><li>将消息发送到特定的客户端或客户端组。</li><li>扩展以处理增加的流量。</li></ul><h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><ul><li>一个人可以开多个tab有多个连接</li><li>给指定的一个、一批人推送(以User为中心对该用户的所有连接进行推送(浏览器多个tab))</li><li>给指定的组中某些人推送(群聊)</li><li>给指定的人某些Connect推送(登录排斥，不允许多台电同时脑登录)</li></ul><h2 id="改进部分"><a href="#改进部分" class="headerlink" title="改进部分"></a>改进部分</h2><ul><li>优先使用socket进行通信</li><li>支持一个用户多个连接</li><li>使用MessagePack进行传输</li><li>使用Redis作为底板来支持横向扩展</li></ul><p>本系列共分为10篇，包括基础知识介绍，项目实战等，目录如下</p><p><a href="/2019/09/21/dotnetcore/signalr/01-base/">.net core 3.0 Signalr - 01 基础篇</a><br><a href="/2019/09/22/dotnetcore/signalr/02-type-hub/">.net core 3.0 Signalr - 02 使用强类型的Hub</a><br><a href="/2019/09/29/dotnetcore/signalr/03-message-pack/">.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容</a><br><a href="/2019/10/01/dotnetcore/signalr/04-redis/">.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展</a><br><a href="/2019/10/02/dotnetcore/signalr/05-jwt/">.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联</a><br><a href="/2019/10/03/dotnetcore/signalr/06-analysis/">.net core 3.0 Signalr - 06 业务实现-业务分析</a><br><a href="/2019/10/04/dotnetcore/signalr/07-self-manager/">.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接</a><br><a href="/2019/10/05/dotnetcore/signalr/08-clientdemo/">.net core 3.0 Signalr - 08 业务实现-客户端demo</a><br><a href="/2019/10/05/dotnetcore/signalr/09-todo/">.net core 3.0 Signalr - 09 待改进&amp;交流</a>   </p><h2 id="Demo源码地址"><a href="#Demo源码地址" class="headerlink" title="Demo源码地址"></a>Demo源码地址</h2><blockquote><p><a href="https://github.com/xiexingen/CTS.Signalr">https://github.com/xiexingen/CTS.Signalr</a></p></blockquote><h2 id="强烈推荐的参考文档"><a href="#强烈推荐的参考文档" class="headerlink" title="强烈推荐的参考文档"></a>强烈推荐的参考文档</h2><blockquote><p>微软官方文档:<a href="https://docs.microsoft.com/zh-CN/aspnet/core/signalr/introduction?view=aspnetcore-3.0">https://docs.microsoft.com/zh-CN/aspnet/core/signalr/introduction?view=aspnetcore-3.0</a><br>发现写的不错的博客: <a href="https://www.cnblogs.com/cgzl/p/9509207.html">https://www.cnblogs.com/cgzl/p/9509207.html</a><br>发现写的不错的博客:<a href="https://www.cnblogs.com/cgzl/p/9515516.html">https://www.cnblogs.com/cgzl/p/9515516.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Signalr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter-01 环境搭建</title>
      <link href="2019/09/09/flutter/01-environment/"/>
      <url>2019/09/09/flutter/01-environment/</url>
      
        <content type="html"><![CDATA[<p>Flutter-01 环境搭建</p><a id="more"></a><p>文档地址 <a href="https://developer.android.google.cn/studio/intro">https://developer.android.google.cn/studio/intro</a></p><h1 id="Window10环境搭建Flutter开发环境"><a href="#Window10环境搭建Flutter开发环境" class="headerlink" title="Window10环境搭建Flutter开发环境"></a>Window10环境搭建Flutter开发环境</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>磁盘空间足够</li><li>git 2.x</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Android-Studio-建议3-0及以上"><a href="#Android-Studio-建议3-0及以上" class="headerlink" title="Android Studio(建议3.0及以上)"></a>Android Studio(建议3.0及以上)</h3><ol><li>下载</li></ol><ul><li><a href="https://developer.android.google.com/studio(%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99)">https://developer.android.google.com/studio(需要翻墙)</a></li><li><a href="https://developer.android.google.cn/studio">https://developer.android.google.cn/studio</a><br>如果过程提示是否安装一些东西，点同意即可,会自动安装java jdk</li></ul><ol start="2"><li>为Android Studio安装Flutter和Dart插件<br>File-&gt;Settings-&gt;Plugins 然后搜索Flutter点击安装，这个时候会提示安装Dart插件，点安装 然后重启Android Studio<br>如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190909203319.png" alt="20190909203319.png"></li></ol><h3 id="Flutter-SDK"><a href="#Flutter-SDK" class="headerlink" title="Flutter SDK"></a>Flutter SDK</h3><ol><li><p>配置flutter临时镜像(非必须)</p><pre class=" language-bash"><code class="language-bash">// 增加如下变量到用户环境变量中PUB_HOSTED_URL<span class="token operator">=</span>https://pub.flutter-io.cn  FLUTTER_STORAGE_BASE_URL<span class="token operator">=</span>https://storage.flutter-io.cn// 注:这些镜像为临时镜像，并不保证一直可用，可以从https://flutter.dev/community/china 查看最新的网址</code></pre></li><li><p>下载并安装</p></li></ol><ul><li>通过 git 克隆flutter项目代码到本地，比如我的是D:\Program Files\Flutter<br>不建议放到高级目录，比如C:\Program Files</li><li>然后在Flutter安装目录的flutter文件下找到flutter_console.bat 双击运行  </li></ul><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><ol><li>系统环境PATH添加 D:\Program Files\Flutter\bin</li><li>Android环境变量配置</li></ol><ul><li>添加系统环境变量<pre class=" language-bash"><code class="language-bash">// 键和值，其中目录为Android SDK的目录，可以通过android studio菜单File-<span class="token operator">></span>Settings 然后搜索SDK 可查看SDK的安装目录ANDROID_HOME:C:\Users\xiexingen\AppData\Local\Android\Sdk</code></pre></li><li>在系统环境变量中的Path中添加%ANDROID_HOME%\emulator</li><li>在系统环境变量中的Path中添加%ANDROID_HOME%\platform-tools</li><li>在系统环境变量中的Path中添加%ANDROID_HOME%\tools</li></ul><blockquote><p>配置完成后，需要重启电脑</p></blockquote><h3 id="在Android模拟器上运行Flutter"><a href="#在Android模拟器上运行Flutter" class="headerlink" title="在Android模拟器上运行Flutter"></a>在Android模拟器上运行Flutter</h3><ul><li>机器上需要启用VM acceleration</li><li>启动android studio 菜单 Tools-&gt;AVD Manager 并选择 <code>Create Virtual Device</code></li><li>选择一个设备 然后点 Next</li><li>为要模拟的Android版本选择一个或多个系统镜像，然后选择Next(建议使用x86)</li><li>在Emulated Performance下，选择 Hardware-GLES 2.0 以启用硬件加速</li><li>验证AVD配置是否正确，然后选Finish,更多问题可以参考文档</li><li>在Android Virtual Device Manager中，点击工具栏的 <code>Run</code>,启动模拟器并显示所选择的操作系统版本或设备的启动画面</li><li>通过 <code>flutter run</code> 命令行运行启动项目</li></ul><h2 id="如何在Android真机运行"><a href="#如何在Android真机运行" class="headerlink" title="如何在Android真机运行"></a>如何在Android真机运行</h2><p>要准备在Android设备上运行并测试Flutter，需要安装Android4.1 (API level 16)或者更高低版本</p><ul><li>在设备上启用 <code>开发人员选项</code>和<code>USB调试</code>，可自行google</li><li>使用USB将手机插入电脑，如果有授权提示则点同意</li><li>在终端中，运行 <code>flutter devices</code>命令以验证Flutter是否识别你连接的Android设备</li><li>通过 <code>flutter run</code> 启动项目</li></ul><hr><h1 id="Mac-环境搭建Flutter开发环境"><a href="#Mac-环境搭建Flutter开发环境" class="headerlink" title="Mac 环境搭建Flutter开发环境"></a>Mac 环境搭建Flutter开发环境</h1><blockquote><p>由于没有mac电脑，所以特地在VM下安装了一个mac系统</p></blockquote><h2 id="前置条件-1"><a href="#前置条件-1" class="headerlink" title="前置条件"></a>前置条件</h2><ul><li>磁盘空间足够</li><li>安装了命令行工具: bash、curl、git 2.x、mkdir、rm、unzip、which</li><li>由于国内访问Flutter可能受限，Flutter官方为中国地区待见了临时镜像，可添加如下环境变量到用户的环境变量中<pre class=" language-bash"><code class="language-bash">// Macintosh HD-<span class="token operator">></span>Users-<span class="token operator">></span>用户名-<span class="token operator">></span>.bash_profile<span class="token function">export</span> PUB_HOSTED_URL<span class="token operator">=</span>https://pub.flutter-io.cn<span class="token function">export</span> FLUTTER_STORAGE_BASE_URL<span class="token operator">=</span>https://storage.flutter-io.cn// 注:这些镜像为临时镜像，并不保证一直可用，可以从https://flutter.dev/community/china 查看最新的网址</code></pre></li></ul><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><h3 id="Flutter-SDK-1"><a href="#Flutter-SDK-1" class="headerlink" title="Flutter SDK"></a>Flutter SDK</h3><ol start="2"><li>下载并安装</li></ol><ul><li>下载stable版本的sdk，然后解压到~/flutter</li></ul><ol start="3"><li><p>添加flutter路径到path中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> ~vim .bash_profile// 然后添加下面行,<span class="token punctuation">;</span>wq 保存，然后重启bash<span class="token function">export</span> PATH<span class="token operator">=</span>/Users/xiexingen/flutter/bin:<span class="token variable">$PATH</span></code></pre></li><li><p>运行flutter doctor来检查flutter<br>会有很多xx 比如xcode，android相关的工具</p></li></ol><h3 id="Android-Studio-建议3-0及以上-1"><a href="#Android-Studio-建议3-0及以上-1" class="headerlink" title="Android Studio(建议3.0及以上)"></a>Android Studio(建议3.0及以上)</h3><ol><li>下载</li></ol><ul><li><a href="https://developer.android.google.com/studio(%E9%9C%80%E8%A6%81%E7%BF%BB%E5%A2%99)">https://developer.android.google.com/studio(需要翻墙)</a></li><li><a href="https://developer.android.google.cn/studio">https://developer.android.google.cn/studio</a><br>如果过程提示是否安装一些东西，点同意即可,会自动安装java jdk</li></ul><ol start="2"><li>为Android Studio安装Flutter和Dart插件<br>File-&gt;Settings-&gt;Plugins 然后搜索Flutter点击安装，这个时候会提示安装Dart插件，点安装 然后重启Android Studio<br>如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190909203319.png" alt="20190909203319.png"></li></ol><h3 id="设置环境变量-1"><a href="#设置环境变量-1" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><ul><li>添加系统环境变量<pre class=" language-bash"><code class="language-bash">// 电脑/Users/用户名/.bash_profile<span class="token comment" spellcheck="true"># Android 环境变量 xiexingen为我的用户名</span><span class="token function">export</span> ANDROID_HOME<span class="token operator">=</span>/Users/xiexingen/Library/Android/sdk<span class="token comment" spellcheck="true"># Android 模拟器路径</span><span class="token function">export</span> PATH<span class="token operator">=</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/emulator</span><span class="token comment" spellcheck="true"># Android tools 路径</span><span class="token function">export</span> PATH<span class="token operator">=</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/tools</span><span class="token comment" spellcheck="true"># Android 平台工具路径</span><span class="token function">export</span> PATH<span class="token operator">=</span>$<span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/platform-tools</span><span class="token comment" spellcheck="true"># Android NDK路径</span>ANDROID_NDK_HOME<span class="token operator">=</span>/Users/xiexingen/Library/Android/ndk/android-ndk-r10e<span class="token comment" spellcheck="true"># Flutter镜像</span><span class="token function">export</span> PUB_HOSTED_URL<span class="token operator">=</span>https://pub.flutter-io.cn<span class="token function">export</span> FLUTTER_STORAGE_BASE_URL<span class="token operator">=</span>https://storage.flutter-io.cn<span class="token comment" spellcheck="true"># Flutter 环境变量</span><span class="token function">export</span> PATH<span class="token operator">=</span>/Users/xiexingen/flutter/bin:<span class="token variable">$PATH</span></code></pre></li></ul><blockquote><p>配置完成后，需要重启电脑</p></blockquote><h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><ol><li>通过苹果应用商店安装</li><li>配置Xcode命令行工具以使用最新安装的Xcode版本<pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> xcode-select --switch /Applications/Xcode.app/Contents/Developer</code></pre></li></ol><h3 id="设置IOS模拟器"><a href="#设置IOS模拟器" class="headerlink" title="设置IOS模拟器"></a>设置IOS模拟器</h3><ol><li>在终端输入如下命令行打开一个ios模拟器<pre class=" language-bash"><code class="language-bash"><span class="token function">open</span> -a Simulator</code></pre></li><li>通过模拟器菜单的 <em>硬件-&gt;设备</em>,确保是64位的iphone5s或更新的模拟器</li></ol><h3 id="如何将Flutter安装到IOS真机上"><a href="#如何将Flutter安装到IOS真机上" class="headerlink" title="如何将Flutter安装到IOS真机上"></a>如何将Flutter安装到IOS真机上</h3><p>要通过<em>flutter run</em> 将Flutter应用安装到ios整机设备，需要一些额外的工具和一个Apple账号，还需要在Xcode中进行设置：</p><blockquote><p>当然，用XCode来讲Flutter运行在真机上更简单，只需要点 <em>run</em>按钮即可，可以根据需要进行两种不同的运行方式；  </p></blockquote><ol><li><p>安装 <a href="https://brew.sh/">Homebrew</a></p></li><li><p>确保homebrew最新</p><pre class=" language-bash"><code class="language-bash">brew update</code></pre></li><li><p>打开终端并运行如下命令来安装用于将Flutter应用安装到IOS设备的工具</p><pre class=" language-bash"><code class="language-bash">brew <span class="token function">install</span> --HEAD usbmuxdbrew <span class="token function">link</span> usbmuxdbrew <span class="token function">install</span> --HEAd libimobiledevicebrew <span class="token function">install</span> ideviceinstaller ios-deploy cocoapodspod setup</code></pre><p>如果这些命令中的任何一个失败并出现错误，可运行<em>brew doctor</em>并按照说明来解决问题</p></li><li><p>遵循Xcode前面流程来配置项目</p></li></ol><ul><li>在你Flutter项目目录中通过<em>open ios/Runner.xcworkspace</em>打开默认的Xcode workspace</li><li>在Xcode中，选择导航面板左侧中的Runner项目</li><li>在Runner target设置页面中，确保在 常规&gt;前面&gt;团队 下选择了您的开发团队。当你选择一个团队时，Xcode会创建并下载开发证书，向您的设备注册您的账户，并创建和下载配置文件(如果需要)<ul><li>要开始您的第一个IOS开发项目，您可能需要使用您的APP ID登录Xcode</li><li>任何App Id都支持开发和测试，但是如想法不到App Store则需要支付99到的开发者账号</li></ul></li><li>当你第一次attach真机设备进行ios开发时，需要同时信任你的Mac和该设备上的开发证书。首次将IOS设备连接到Mac时，请在对话中选择 <em>信任</em>,然后，转到IOS设备上的设置应用程序，选择 常规&gt;设备管理 并信任您的证书<ul><li>如果Xcode中的自动签名失败，请验证项目的 General&gt;Identity&gt;Bundle Identifier值是否唯一.</li></ul></li></ul><ol start="5"><li>通过flutter run 运行启动项目<pre class=" language-bash"><code class="language-bash">flutter run</code></pre></li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li>运行 adb // 检测android相关</li><li>运行flutter doctor  // 检测flutter相关<blockquote><p>第一次运行flutter命令(如 flutter doctor)，它会下载自己的依赖项目并自动编译，并缓存</p></blockquote></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="无法启动模拟器"><a href="#无法启动模拟器" class="headerlink" title="无法启动模拟器"></a>无法启动模拟器</h3><blockquote><p>emulator: ERROR:x86 emulation currently requires hardware acceleration! Please ensure Windows Hypervisor Platform (WHPX) is properly installed and usable. CPU acceleration status: HAXM is not installed on this machine<br>解决方案:选择 Tools-&gt; SDK Manager -&gt; SDK Tools,安装 HAXM 即可<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190909204602.png" alt="20190909204602.png"></p></blockquote><h3 id="创建flutter项目"><a href="#创建flutter项目" class="headerlink" title="创建flutter项目"></a>创建flutter项目</h3><ol><li><p>通过android studio创建<br>File-&gt;Create-&gt;New Flutter Project</p></li><li><p>通过命令行<br>flutter create my_first_app</p></li></ol><h3 id="运行flutter项目"><a href="#运行flutter项目" class="headerlink" title="运行flutter项目"></a>运行flutter项目</h3><ol><li><p>通过android studio 启动按钮</p></li><li><p>命令行运行android模拟器</p><pre class=" language-bash"><code class="language-bash">// hw1 表示模拟器的名称emulator -avd hw1</code></pre></li><li><p>命令行 flutter run<br>前置条件，需要一个已经启动的android模拟器或者连接到电脑的android设备</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写博客的神器-图床篇</title>
      <link href="2019/08/26/other/blog-image-lib/"/>
      <url>2019/08/26/other/blog-image-lib/</url>
      
        <content type="html"><![CDATA[<p>vscode下使用 PicGo自动上传图片</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><a href="https://github.com/Molunerfinn/PicGo">PicGo github地址</a><br><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">PicGo 文档地址</a> </p></blockquote><h3 id="纯手工时代"><a href="#纯手工时代" class="headerlink" title="纯手工时代"></a>纯手工时代</h3><table><thead><tr><th align="left">类型</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left">站内</td><td align="left">1.图片自定义命名<br/> 2.方便管理迁移</td><td align="left">1.增加博客服务器压力(一般都是比较弱的机器)<br/> 2. 操作麻烦</td></tr><tr><td align="left">外部资源服务器<br/>比如(七牛、微博、腾讯云、阿里云等)</td><td align="left">1. 减轻服务器压力<br/></td><td align="left">1.操作麻烦，不好管理图片</td></tr></tbody></table><h3 id="工业1-0时代"><a href="#工业1-0时代" class="headerlink" title="工业1.0时代"></a>工业1.0时代</h3><p>今天的重点是，vscode下的<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>插件,通过简单的配置可以实现切换 七牛、微博、腾讯云COS、又拍云、github、阿里云oss、imgur等，与vscode很方便的集成，综合对比了下 腾讯云、阿里云皆收费，github国内又有点慢，最后选择了七牛，每个月10G 博客应该够用，配置如下:<br><img src="http://qiniu.xxgtalk.cn/blog/images/20190807085943.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY一个集搜索、排序、分页功能的列表组件</title>
      <link href="2019/05/22/front/react/diy-component-pagedquery/"/>
      <url>2019/05/22/front/react/diy-component-pagedquery/</url>
      
        <content type="html"><![CDATA[<p>DIY一个集搜索、排序、分页功能的列表组件</p><a id="more"></a><p><a href="https://github.com/wetrial/wetrial-template">源码地址</a>: <a href="https://github.com/wetrial/wetrial-template">https://github.com/wetrial/wetrial-template</a><br />效果<br /><img src="https://cdn.nlark.com/yuque/0/2019/gif/173421/1558523693173-c0265a6e-5263-4317-bf76-99b17c86ec1c.gif#align=left&display=inline&height=513&name=test.gif&originHeight=1508&originWidth=2193&size=4252316&status=done&width=746" alt="test.gif"><br><a name="UKzZ5"></a></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在中控台系统中经常需要带条件过滤、分页、排序等的列表页面，antd提供了表格、排序、分页等，多个页面中使用会发现里面其实有很多重复的代码，自己捣腾下最后有了这个组件，<br><a name="pfCYQ"></a></p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p><a name="7qJ13"></a></p><h2 id="列表使用"><a href="#列表使用" class="headerlink" title="列表使用"></a>列表使用</h2><p>如图所示:<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/173421/1558524295889-fe6fce9b-1d53-4849-898c-39a7decf52ec.png#align=left&display=inline&height=1323&name=image.png&originHeight=1985&originWidth=2000&size=270488&status=done&width=1333.3333333333333" alt="image.png"></p><ol><li><p>引入高阶组件pagedQuery</p></li><li><p>引入封装的TableList 基本上跟Antd table组件用法一致，只是初始化了许多默认参数</p></li><li><p>用高阶组件包裹组件，并传参</p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">// type为必须参数，一般对应dva中model的effects</span><span class="token entity" title="&#123;">&amp;#123;</span>type<span class="token punctuation">:</span> string<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型 一般指获取数据源的action</span>page<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前页 从1开始</span>defaultPageSize<span class="token operator">?</span><span class="token punctuation">:</span>number<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每页默认显示的条数</span>pageSize<span class="token operator">?</span><span class="token punctuation">:</span> number<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每页显示数量</span>record<span class="token operator">?</span><span class="token punctuation">:</span> boolean<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否记录搜索状态</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre></li><li><p>请求附带的基础参数，通过<em>getQueryParams返回一个对象，用于一些特殊场景，一般为空</em></p></li><li><p>处理搜索按钮的点击事件，将搜索表单中的值收集并传递给onSearchData方法</p></li><li><p>处理重置按钮，将重置按钮的点击事件绑定来源于高阶组件给组件的onResetData</p></li><li><p>获取数据源并给到table<br><a name="AiF39"></a></p><h2 id="详情页面"><a href="#详情页面" class="headerlink" title="详情页面"></a>详情页面</h2><p>回退到列表页面有两种形式，<br />1.通过浏览器上的回退按钮<br />2.详情页面放置一个回退按钮，代码层面实现路由跳转到列表页<br />一般情况都使用第二种方式，因为如果编辑页面比较负责，可能里面有子页面，子页面又可以进入这一通过浏览器上的回退按钮需要点击N多次，再者，浏览器的回退有数量限制<br />同样，如图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2019/png/173421/1558524894480-261376dd-c130-40e0-b993-23812add160f.png#align=left&display=inline&height=877&name=image.png&originHeight=1316&originWidth=1714&size=188537&status=done&width=1142.6666666666667" alt="image.png"></p></li><li><p>引入方法backRouter</p></li><li><p>在需要跳转路由的地方调用一下backRoute方法，并将路由传递给方法，该方法会返回之前记录的列表路由<br><a name="VNgB5"></a></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1></li></ol><p>实现思路，通过高阶组件实现，<a href="https://github.com/wetrial/wetrial/blob/master/src/components/PagedQuery/index.tsx">代码</a>  、  <a href="https://github.com/wetrial/wetrial/blob/master/src/components/PagedQuery/index.zh-CN.md">api文档</a>  <br />记录搜索状态，通过sessionStorage来实现，考虑到sessionStore的一个优势，关闭当前tab页就失效了 省去还得去手动清除记录状态的麻烦(比如放到localStorage)，再者 这种查询状态不需要持久记录  <br />回退方法backRouter，由于高阶组件中会在组件的componentWillUnmount方法中记录搜索状态，以location的pathname为key，以location的search为值存放，所以通过backRouter方法匹配的时候会从sessionStorage中查询，如果有则带上查询串，以此来达到记录页面状态的效果</p><blockquote><p>更多请参观：<a href="https://www.yuque.com/wetrial/front-end/">https://www.yuque.com/wetrial/front-end/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优质文章收集(持续更新中...)</title>
      <link href="2019/04/26/tools/articlecollections/"/>
      <url>2019/04/26/tools/articlecollections/</url>
      
        <content type="html"><![CDATA[<p>各大优质文章收集(持续更新中…)</p><a id="more"></a><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p><a href="https://juejin.im/post/5cc089eae51d456e7d189f9d">可能是最全的前端动效库汇总</a></p><p><a href="https://github.com/sorrycc/awesome-f2e-libs">常用前端库</a></p><p><a href="https://github.com/sorrycc/awesome-tools">awesome-tools</a></p><p><a href="https://juejin.im/post/5d08d3d3f265da1b7e103a4d?utm_source=gold_browser_extension">前端工程化-5:你所需要的npm知识储备都在这了</a></p><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">正则相关</a></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex布局-语法篇</a>、<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">flex布局-实战篇</a><br><a href="https://juejin.im/post/5d9bf530518825427b27639d">ES6</a></p><h4 id="Chrome插件开发"><a href="#Chrome插件开发" class="headerlink" title="Chrome插件开发"></a>Chrome插件开发</h4><p><a href="https://github.com/sxei/chrome-plugin-demo">chrome插件开发</a></p><p><a href="http://www.cnblogs.com/champagne/p/?page=2">博客文章</a></p><p><a href="https://zjcqoo.github.io/-----https://developer.chrome.com/extensions">官方资料</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>NAS 私有文件服务器</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用umi-library来打包组件</title>
      <link href="2019/04/02/front/react/umi-library-self/"/>
      <url>2019/04/02/front/react/umi-library-self/</url>
      
        <content type="html"><![CDATA[<p>通过umi-library将自己的组件打包成各种类型的包…</p><a id="more"></a><h1 id="文件格式说明"><a href="#文件格式说明" class="headerlink" title="文件格式说明"></a>文件格式说明</h1><h3 id="esm-用途"><a href="#esm-用途" class="headerlink" title="esm 用途"></a>esm 用途</h3><p>es6语法格式(也叫AMD)，主要用在浏览器中 export default …；可以做 tree-shaking(打包成一个文件，但是项目中使用时只引入需要的那一部分) </p><h3 id="cjs-用途"><a href="#cjs-用途" class="headerlink" title="cjs 用途"></a>cjs 用途</h3><p>es5的语法(也叫CommonJS)，目前主要给node用； module.exports=…</p><h3 id="umd-用途"><a href="#umd-用途" class="headerlink" title="umd 用途"></a>umd 用途</h3><p>兼容esm和cjs，先判断是否支持node模块module.exports</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>安装umi-library  <pre class=" language-node"><code class="language-node">yarn add umi-library -D</code></pre></li><li>配置.umirc.library.js文件<pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 使用babel方式打包 将按照源代码的文件目录进行打包，默认为rollup方式(将文件合并成一个)</span>esm<span class="token punctuation">:</span> <span class="token string">'babel'</span><span class="token punctuation">,</span> cjs<span class="token punctuation">:</span> <span class="token string">'babel'</span><span class="token punctuation">,</span>autoprefixer<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    browsers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'ie>8'</span><span class="token punctuation">,</span> <span class="token string">'Safari >= 6'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>extraBabelPlugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span>    <span class="token string">'babel-plugin-import'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        libraryName<span class="token punctuation">:</span> <span class="token string">'antd'</span><span class="token punctuation">,</span>        libraryDirectory<span class="token punctuation">:</span> <span class="token string">'es'</span><span class="token punctuation">,</span>        style<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li><li>执行打包<br>可以参考github项目 <a href="https://github.com/wetrial/wetrial">https://github.com/wetrial/wetrial</a></li></ol><blockquote><p>umi-library<a href="https://github.com/umijs/umi/tree/master/packages/umi-library">地址</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> umi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用travis自动部署到github</title>
      <link href="2019/03/16/tools/travis/"/>
      <url>2019/03/16/tools/travis/</url>
      
        <content type="html"><![CDATA[<h4 id="使用github-travis-ant-design-pro-site打造自己公司的前端开发文档站点"><a href="#使用github-travis-ant-design-pro-site打造自己公司的前端开发文档站点" class="headerlink" title="使用github+travis+ant-design-pro-site打造自己公司的前端开发文档站点"></a>使用github+travis+ant-design-pro-site打造自己公司的前端开发文档站点</h4><a id="more"></a><h4 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h4><blockquote><p>插播一条小广告，我们公司招人.net、前端(react栈) ；有求职意向可以私我内推(qq:1002275364)</p></blockquote><p>目前公司的系统是基于.net web mvc开发，由于历史原因吧，里面有razor写的，也有公司自定义的前端单页框架jui写的一部分，在后续的开发、维护过程中愈发困难；基于各方面考虑以最后打算后端基于.netcore；前端基于react+antd+dva+umi栈重构；</p><ol><li>为什么用.net core<br>其实吧，我跟后端是有很大的渊源的，做了好几年后端吧，发现.net后端其实蛮苦逼的，不仅得写后端api还得写前端页面(没办法，你让美工去写razor页面感觉有点过分)，这也是为什么要前后端分离的原因之一(虽然分离之后前端页面还是后端开发人员兼职写^_^)；<br>.net core 天生为了跨平台、高性能、微服务、云而生；作为一个后端黑带6道的我，中小型项目里面玩的还是蛮顺手的(像什么abp、DI、dapper、ef、NPOI、itextsharp、quartznet、CAP、SignalR、Polly、DotnetSpider等还是玩过一些些的，只要别跟我扯什么动不动就双十一的场景，还是可以聊的下去的)<br>其次，.net core生态圈目前虽然不如java等，但是还是可以看到一直在进步；像什么桌面应用、Xamarin、ML.NET、爬虫、Xamarin、区块链、IoT、Unity3D、等都有涉及到;微服务方向，有Ocelot、Consul、Polly 等等等等等等等等等等等等等…  </li><li>为啥用react+antd+dva+umi【+ts】栈<br>目前开发人员以后端人员为主力，对jquery栈比较熟悉；切换到react后需要比较大的转变，需要接触很多新知识，比如es6的析构赋值、rest、箭头函数、Generate、Promise、模板字符串;再比如 react的生命周期、redux的数据流等 这些都是新的东西；考虑到各方面，最终打算数据量方案使用dva(简单明了以model为单位集reducers、effects、subscribe等)，至于antd不用过多介绍，业界公认前端ui库</li></ol><p>好像有点跑题了~~~~~</p><h4 id="工作准备"><a href="#工作准备" class="headerlink" title="工作准备"></a>工作准备</h4><ol><li>注册账号<a href="https://github.com/">github</a>、<a href="https://travis-ci.org/">travis</a></li><li>github上创建仓库(wetrial-site)</li><li>github上生成一个token(记得保存下来)，用于travis推送代码到gh-pages分支<br><img src="http://qiniu.xxgtalk.cn/blog/images/tools/travis_github_generate_token.jpg" alt="生成token"><br>记得将tokens保存下来，稍后要用到，仓库权限选择第一项 repo即可  </li><li>travis设置<br>点击头像、然后选择项目，默认是用户，如果你的项目是组织项目的，需要切换到组织，如图所示<br><img src="http://qiniu.xxgtalk.cn/blog/images/tools/travis_project_list.jpg" alt="travis项目选择"> </li><li>进入项目配置页面，如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/tools/travis_project_setting.jpg" alt="travis项目选择"><br>添加环境变量相关东西，包括域名、token等<br><img src="http://qiniu.xxgtalk.cn/blog/images/tools/travis_environment.jpg" alt="配置">   </li><li>回到实际的项目<br>从ant-design-pro-site拉取代码，然后根据自己的实际情况做修改；比如我去掉了尾栏的一些东西，增加了css相关的大栏(这里不具体介绍)  </li><li>在根目录下添加travis的配置文件.travis.yml 内容如下所示<pre class=" language-yml"><code class="language-yml">language: node_js</code></pre></li></ol><p>node_js:</p><ul><li>“8”</li></ul><h1 id="缓存依赖"><a href="#缓存依赖" class="headerlink" title="缓存依赖"></a>缓存依赖</h1><p>cache:<br>  directories:<br>    - node_modules</p><p>before_install:</p><ul><li>export TZ=’Asia/Shanghai’ # 更改时区</li></ul><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><p>install:</p><ul><li>npm install</li></ul><h1 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h1><p>script: </p><ul><li>npm run build-site</li></ul><h1 id="分支白名单"><a href="#分支白名单" class="headerlink" title="分支白名单"></a>分支白名单</h1><p>branches:<br>  only:<br>    - master # 只对 master 分支进行构建</p><h1 id="GitHub-Pages-部署"><a href="#GitHub-Pages-部署" class="headerlink" title="GitHub Pages 部署"></a>GitHub Pages 部署</h1><p>deploy:</p><ul><li>provider: pages<br>skip_cleanup: true<h1 id="在项目仪表盘的-Settings-gt-Environment-Variables-中配置"><a href="#在项目仪表盘的-Settings-gt-Environment-Variables-中配置" class="headerlink" title="在项目仪表盘的 Settings -&gt; Environment Variables 中配置"></a>在项目仪表盘的 Settings -&gt; Environment Variables 中配置</h1>github_token: $GITHUB_TOKEN<h1 id="将-build-目录下的内容推送到默认的-gh-pages-分支上，并不会连带-build-目录一起"><a href="#将-build-目录下的内容推送到默认的-gh-pages-分支上，并不会连带-build-目录一起" class="headerlink" title="将 build 目录下的内容推送到默认的 gh-pages 分支上，并不会连带 build 目录一起"></a>将 build 目录下的内容推送到默认的 gh-pages 分支上，并不会连带 build 目录一起</h1>local_dir: _site<h1 id="绑定自定义域名，根据自己的情况来"><a href="#绑定自定义域名，根据自己的情况来" class="headerlink" title="绑定自定义域名，根据自己的情况来"></a>绑定自定义域名，根据自己的情况来</h1>fqdn: $CUSTOM_DOMAIN<br>name: $GIT_NAME<br>email: $GIT_EMAIL<pre><code>然后提交并同步到github,回到travis将会看到如下一幕  ![配置](http://qiniu.xxgtalk.cn/blog/images/tools/travis_log.jpg)    你也可以从日志里面看到具体的执行过程，等待执行完成后回到github中将会看到里面多了一个gh-pages分支，没错 这个分支就是travis中的deploy推送过去的，里面就是编译后的代码，再回到setting里面，将会看到已经默认配置好站点地址了，这里我们改改 使用自己的域名，如图所示:  ![](http://qiniu.xxgtalk.cn/blog/images/tools/travis_github_config.jpg) 最后，去域名管理页，将自己的这个子域名一定一个类型为CNAME的，地址为:wetrial.github.io</code></pre></li></ul><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>访问刚配置的地址:<a href="http://ant.xxgtalk.cn/">http://ant.xxgtalk.cn</a> 可以看到部署好的文档</p><p><img src="http://qiniu.xxgtalk.cn/blog/images/tools/wetrial-site.jpg" alt="wetrial示例"> </p><blockquote><p>此外,打算写一篇这块的手册，<a href="https://www.yuque.com/wetrial/front-end/xuyan">地址:https://www.yuque.com/wetrial/front-end/xuyan</a> 欢迎 <a href="https://www.yuque.com/wetrial/front-end/xuyan">FORK</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用ngrok来做内网穿透</title>
      <link href="2018/12/17/tools/ngrok/"/>
      <url>2018/12/17/tools/ngrok/</url>
      
        <content type="html"><![CDATA[<p>我有很多自己的个人代码是跑在家里的服务器中的.一般来说都是自动化的处理我的一些生活问题,与数据收集等相关活动. 所以一般没有客户端访问家里服务器的需求. 但是很多时候脑子突发奇想.有一些小点子,一些小的bug或者小的优化,代码修改完成之后,有一个部署到需求. 因为家里服务器没有一个稳定的外网IP的,外网不能直接连接服务器. 所以我们需要 内网穿透.<br><a id="more"></a></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li>首先你需要去官网注册一个账号</li><li>下载ngrok,并且解压到一个你喜欢的目录下面</li><li>去官网复制你的授权码</li><li>授权ngrok<pre class=" language-bash"><code class="language-bash">ngrok authtoken 授权码</code></pre><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><pre class=" language-bash"><code class="language-bash">ngrok http 8080</code></pre></li></ol><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><pre class=" language-bash"><code class="language-bash">ngrok tcp 22</code></pre><p><img src="http://qiniu.xxgtalk.cn/blog/images/20191217094149.png" alt="20191217094149.png"></p><p>最终你会得到,一个外网可以访问的地址. 用这个地址就可以直接访问到你本机的端口了.  </p><p>当我们拥有这样一个公网地址之后,我们就可以ssh来控制家里的机器 或者使用github的webhook来做一切你想要做的事情.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React社区精选组件</title>
      <link href="2018/12/10/front/react/components/"/>
      <url>2018/12/10/front/react/components/</url>
      
        <content type="html"><![CDATA[<p>ReactReact社区精选组件</p><a id="more"></a><p>其他地址：<a href="https://ant.design/docs/react/recommendation-cn">https://ant.design/docs/react/recommendation-cn</a><br>| 类型 | 推荐组件 | 描述<br>| :— | :— | :—<br>|滚动条 |<a href="https://github.com/goldenyz/react-perfect-scrollbar">react-perfect-scrollbar</a> <a href="https://github.com/souhe/reactScrollbar">reactScrollbar</a>  | 虚拟滚动条<br>|图片缩放|<a href="https://github.com/infeng/react-viewer">react-viewer</a> | 图片缩放<br>|媒体查询|<a href="https://github.com/ReactTraining/react-media">react-media</a>|媒体查询<br>|标题修改|<a href="https://github.com/gaearon/react-document-title">react-document-title</a>| 修改标题<br>|浏览器存储|<a href="https://github.com/marcuswestin/store.js">store</a> | 浏览器存储技术<br>|pdf|<a href="https://github.com/diegomura/react-pdf">react-pdf</a> | pdf<br>|react-virtualized|<a href="https://github.com/bvaughn/react-virtualized">react-virtualized</a> | 大数据渲染</p><h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><table><thead><tr><th align="left">类型</th><th align="left">推荐组件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">生成pdf</td><td align="left"><a href="https://github.com/MrRio/jsPDF?utm_source=gold_browser_extension">jsPDF</a></td><td align="left">前端生成pdf</td></tr><tr><td align="left">谷歌浏览器API</td><td align="left"><a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a></td><td align="left">可以用来写爬虫 一个无界面的谷歌浏览器</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-config常用点介绍</title>
      <link href="2018/12/03/redis/01-config/"/>
      <url>2018/12/03/redis/01-config/</url>
      
        <content type="html"><![CDATA[<p>redis-config常用点介绍<br><a id="more"></a></p><blockquote><p>参考文档:<a href="http://redisdoc.com/">http://redisdoc.com/</a></p></blockquote><ol><li><p>是否以守护进程方式运行，redis默认不是守护进程方式运行，可以修改该配置项来使用守护进程方式运行<br>daemonizo:yes</p></li><li><p>pidfile 指定守护进程方式的写入文件<br>当redis以守护进程方式运行时，redis默认会吧pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid</p></li><li><p>指定redis端口<br>配置文件里面找port，默认是6379 </p></li><li><p>bind 绑定的主机ip</p><pre class=" language-bash"><code class="language-bash">bind 127.0.0.1</code></pre></li><li><p>timeout<br>超时时间,默认为0 表示关闭该功能</p></li><li><p>loglevel </p><pre class=" language-bash"><code class="language-bash">设置日志级别 debug verbose notice warning  syslog-enabled:是否将日志输出到系统日志syslog里头    syslog-indent: 指定syslog里的日志标志syslog-facility： 指定syslog设备，值可以是USER或者LOCAL0-LOCAL7</code></pre></li><li><p>日志记录方式，默认为标志输出，如果配置redis为守护进程方式运行，而这里又配置日志记录方式为标准输出，则日志将会发送给/dev/nulll<br>logfile stdout</p></li><li><p>databases 数据库数量</p><pre class=" language-bash"><code class="language-bash">databases 16</code></pre></li><li><p>指定多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件适配</p><pre class=" language-bash"><code class="language-bash">save <span class="token operator">&lt;</span>seconds<span class="token operator">></span> <span class="token operator">&lt;</span>changes<span class="token operator">></span><span class="token comment" spellcheck="true"># redis 默认配置文件提供了三个条件</span><span class="token comment" spellcheck="true"># save 900 1 # 900秒内有一个更改</span><span class="token comment" spellcheck="true"># save 300 10 # 300秒内有10个更改</span><span class="token comment" spellcheck="true"># save 60 10000 # 60秒内有10000个更改</span></code></pre></li><li><p>指定存储至本地数据库时是否压缩数据，默认为yes，redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，单会大致数据库文件变得巨大</p><pre class=" language-bash"><code class="language-bash">rdbcompression <span class="token function">yes</span></code></pre></li><li><p>指定本地数据库文件名，默认为dump.rdb</p><pre class=" language-bash"><code class="language-bash">dbfilename dump.rdb</code></pre></li><li><p>指定本地数据库存放目录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">dir</span> ./</code></pre></li><li><p>设置当本机为slav服务是，设置master服务的ip地址及端口，在redis启动时，他会自动从master进行数据同步</p><pre class=" language-bash"><code class="language-bash">slaveof <span class="token operator">&lt;</span>masterip<span class="token operator">></span> <span class="token operator">&lt;</span>masterport<span class="token operator">></span></code></pre></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码</p><pre class=" language-bash"><code class="language-bash">masterauth <span class="token operator">&lt;</span>master-password<span class="token operator">></span></code></pre></li><li><p>设置redis连接密码，如果设置了密码，客户端在连接的时候需要通过 auth <password> 提供密码，默认为关闭</p><pre class=" language-bash"><code class="language-bash">requirepass Abcd1234</code></pre></li><li><p>设置同一时间最大客户端连接数，默认无限制，redis可以同时打开的客户端连接数为redis经常可以打开的最大文件描述符数，如果设置maxclients 0,表示不作限值。当客户端连接数达到限制时，redis会关闭新的连接并向客户端返回 max number of clients reached错误信息</p><pre class=" language-bash"><code class="language-bash">maxclients 128</code></pre></li><li><p>指定redis最大内存限制，redis在启动时会把数据加载到内存中，达到最大内存后，redis会尝试清除已到期或即将到期的key，当次方法处理后，仍然达到最大内存设置，将无法进行写入操作，但仍可以读，redis新的vm机制，会把key存放内存，value存放在swap区</p><pre class=" language-bash"><code class="language-bash">maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">></span></code></pre></li><li><p>指定是否每次更新操作后进行日志记录，redis在默认情况下是异步吧数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失，因为redis本身同步数据文件是按上面save条件来同步的，所有的数据会在一段时间内只存在于内存中。默认为 no</p><pre class=" language-bash"><code class="language-bash">appendonly no</code></pre></li><li><p>指定更新日志文件名，默认为appendonly.aof</p><pre class=" language-bash"><code class="language-bash">appendfilename  appendonly.aof</code></pre></li><li><p>指定更新日志条件，共有3个可选值<br>no: 表示等操作系统镜像数据缓存同步到磁盘(块)<br>always: 表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)<br>everysec:表示每秒同步一次(折中，默认值)</p><pre class=" language-bash"><code class="language-bash">appendfsync everysec</code></pre></li><li><p>指定是否启用虚拟内存机制，默认为no，简单的介绍下，VM机制将数据分页存放，有redis将访问量较少的页即冷水机swap到磁盘上，访问多的页由磁盘自动换出到内存中</p><pre class=" language-bash"><code class="language-bash">vm-enabled no</code></pre></li><li><p>虚拟内存文件路径，默认值为/temp/redis.swap，不可多个redis实例共享</p><pre class=" language-bash"><code class="language-bash">vm-swap-file /tmp/redis.swap</code></pre></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(redis的所有数据就是keys)，也就是说 当vm-max-memory设置为0的时候，其实就是所有的value都存在于磁盘。默认值为0</p><pre class=" language-bash"><code class="language-bash">vm-max-memory 0</code></pre></li><li><p>redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但是一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大对象，可以使用更大的page，如果不确定，就是用默认值</p><pre class=" language-bash"><code class="language-bash">vm-max-size 32</code></pre></li><li><p>设置swap文件中的page数量，由于页表(一种表示页面空闲或使用bitmap)是放在内存中的，在磁盘上每8个pages将消耗1bytes内存。</p><pre class=" language-bash"><code class="language-bash">vm-pages 1342177289</code></pre></li><li><p>设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么对所有swap文件的操作都是串行的，可能会造成比较长的延迟，美容是4</p><pre class=" language-bash"><code class="language-bash">vm-max-thread:4</code></pre></li><li><p>设置在想客户端应答时，是否吧较小的包合并为一个包发送，默认为开启</p><pre class=" language-bash"><code class="language-bash">glueoutputbuf <span class="token function">yes</span></code></pre></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># hash-max-zipmap-entries 64</span><span class="token comment" spellcheck="true"># has-max-zipmap-value 512</span></code></pre></li><li><p>指定是否激活重置哈希，默认为开启</p><pre class=" language-bash"><code class="language-bash">activerehashing <span class="token function">yes</span></code></pre></li><li><p>指定包含其他的配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p><pre class=" language-bash"><code class="language-bash">include /path/to/local.conf</code></pre></li></ol><h2 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a>SNAPSHOTTING快照</h2><h2 id="REPLICATION复制"><a href="#REPLICATION复制" class="headerlink" title="REPLICATION复制"></a>REPLICATION复制</h2><h2 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a>SECURITY安全</h2><ul><li>requirepass节点<br>config get requirepass<br>config set requirepass [v]</li></ul><h2 id="LIMITS限值"><a href="#LIMITS限值" class="headerlink" title="LIMITS限值"></a>LIMITS限值</h2><ul><li><p>maxclients :最大连接数</p></li><li><p>maxmemory :最大内存</p></li><li><p>maxmemory-policy : 默认为noeviction<br>volatile-lru: 使用LRU算法移除key，只对设置了过期时间的键</p></li></ul><p>allkeys-lru:使用LRU算法移除key</p><p>volatile-random:在过期集合中随机移除，值对设置了过期时间的键有效</p><p>allkeys-random: 随机移除key</p><p>volatile-ttl: 移除那些TTL值最小的key，也就是最近要过期的key</p><p>noeviction: 永不过期，不进行移除，针对写操作，直返回错误信息</p><ul><li>maxmemory-samples</li></ul><h2 id="APPEND-ONLY-MODE追加"><a href="#APPEND-ONLY-MODE追加" class="headerlink" title="APPEND ONLY MODE追加"></a>APPEND ONLY MODE追加</h2>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-cli基础</title>
      <link href="2018/12/02/redis/02-cmd/"/>
      <url>2018/12/02/redis/02-cmd/</url>
      
        <content type="html"><![CDATA[<p>redis-cli基础<br><a id="more"></a></p><ul><li>参考文档:<a href="http://redisdoc.com/">http://redisdoc.com/</a></li></ul><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th><th style="text-align:left">参数说明</th><th style="text-align:left">案例</th></tr></thead><tbody><tr><td style="text-align:left">redis-cli -h [host] -p [port] -a [password]</td><td style="text-align:left">通过redis-cli连接redis</td><td style="text-align:left">host:地址<br>port:端口号,默认为6379<br> password:密码</td><td style="text-align:left">redis-cli -h localhost -p 7379 -a test</td></tr><tr><td style="text-align:left">ping</td><td style="text-align:left">测试是否通</td><td style="text-align:left">如果返回pong，表示通了</td></tr><tr><td style="text-align:left">FLUSHALL</td><td style="text-align:left">清空所有db</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">FLUSHDB</td><td style="text-align:left">清空当前db</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">select [index]</td><td style="text-align:left">切换到第几个db</td><td style="text-align:left">index：从0开始的db下标</td><td style="text-align:left">select 0</td></tr><tr><td style="text-align:left">DBSIZE</td><td style="text-align:left">显示当前db中的key个数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">keys [pattern]</td><td style="text-align:left">显示当前db中的所有key</td><td style="text-align:left">pattern：匹配符(如：？)</td><td style="text-align:left">keys *</td></tr><tr><td style="text-align:left">get [key]</td><td style="text-align:left">查询指定key的值</td><td style="text-align:left">key:键名</td><td style="text-align:left">get name</td></tr><tr><td style="text-align:left">del [key]</td><td style="text-align:left">删除指定key的值</td><td style="text-align:left">key:键名</td><td style="text-align:left">del name</td></tr><tr><td style="text-align:left">EXISTS [key]</td><td style="text-align:left">判断是否存在指定的key</td><td style="text-align:left">key:键名</td><td style="text-align:left">EXISTS name</td></tr><tr><td style="text-align:left">move [key] [db]</td><td style="text-align:left">移动指定的key到指定的db</td><td style="text-align:left">key:键名<br> db:db下标</td></tr><tr><td style="text-align:left">ttl [key]</td><td style="text-align:left">查看过期时间</td><td style="text-align:left">key:键名,返回值(-1:永不过期 -2:已过期，会移除)</td><td style="text-align:left">ttl name</td></tr><tr><td style="text-align:left">EXPIRE [key] [time]</td><td style="text-align:left">设置带过期时间的键值</td><td style="text-align:left">key:键名<br>time:过期时间(秒)<br></td><td style="text-align:left">EXPIRE name 10</td></tr><tr><td style="text-align:left">type [key]</td><td style="text-align:left">查看指定key的数据类型</td><td style="text-align:left">key:键名</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li><p>append [key]:追加   </p></li><li><p>STRLEN [key]:字符串长度</p></li><li><p>INCR [key]:数值增加 </p></li><li><p>INCRBY [key] v:数值增加v</p></li><li><p>DECR [key] :数值减少</p></li><li><p>DECRBY [key] v:数值减少v</p></li><li><p>GETRANGE [key] [start] [end]:字符串截取</p></li><li><p>SETRANGE [key] [start] [end]:字符串截取</p></li><li><p>setnx [key] [v]: 如果不存在才设置</p></li><li><p>msetnx [key] […v] : 设置多个</p></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>LPUSH [key] […v] :依次往左边插入多个</p></li><li><p>RPUSH [key] […v] :依次往右边插入多个</p></li><li><p>LRANGE [key] [start] [end] :列出多个</p></li><li><p>lpop [key] :删除第一个</p></li><li><p>rpop [key] :删除第一个</p></li><li><p>LINDEX [key] [index] :查看指定下标的值</p></li><li><p>LLEN [key] :查看list长度</p></li><li><p>LREM [key] [count] [v]:删除指定列表中指定的count个v</p></li><li><p>LTRIM [key] [start] [end]: 从start开始删除到end为止</p></li><li><p>rpoplpush [source] [destination]: 移除source的最后一项 并插入到destination的第一项</p></li><li><p>lset [key] [index] [value] : 用value替换指定下标的值</p></li><li><p>linsert [key] [before/after] [value1] [value2]: 在value1前/后插入value2</p></li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ul><li><p>SMEMBERS [key] :查看set中数据集合</p></li><li><p>sadd [key] […v]:添加多个值，去重复的</p></li><li><p>scard [key] :查看元素中的数量</p></li><li><p>SREM [key] [v] :删除指定集合中的指定的值</p></li><li><p>srandmember [key] [count]: 随机生成count个整数</p></li><li><p>spop [key]:随机删除一个</p></li><li><p>smove [key1] [key2] [v] :将set集合key1中的v移到key2中</p></li><li><p>sdiff [key1] [key2]: 查询key1中有，key2中没有的</p></li><li><p>sinter [key1] [key2]: 查询两个中都有的</p></li><li><p>sunion [key1] [key2]：查询两个的去重后的合并集合</p></li></ul><h1 id="Hash-gt-K-V模式不变，V是一个键值对"><a href="#Hash-gt-K-V模式不变，V是一个键值对" class="headerlink" title="Hash =&gt; K/V模式不变，V是一个键值对"></a>Hash =&gt; K/V模式不变，V是一个键值对</h1><ul><li><p>hget [key] [vKey]:查询key中v的值</p></li><li><p>hmget [key] […vKey]: 一次查询多个</p></li><li><p>hset [key] [vKey] [value]：设置key中v的值为value,例:hset user id 1</p></li><li><p>hmset [key] […[vKey] [value]]: 一次设置多个，例:hmset user name xxg age 28 id</p></li><li><p>HGETALL [key] :查询key中所有的键值对，得到数组[‘属性’,’值’]形式</p></li><li><p>hdel [key] […vKey] :删除多个指定的vKey</p></li><li><p>hlen [key] :查询指定key中的数量</p></li><li><p>hexists [key] [vKey]:判断key里面是否存在某个值的key</p></li><li><p>HKEYS [key] : 查看指定key中所有的值的key</p></li><li><p>hvals [key] : 查看指定key中所有的值</p></li><li><p>HINCRYBY/HINCRYBYFLOAT [key] [vKey] [v] :给指定key增加指定的整数/小数</p></li><li><p>hsetnx [key] [vKey] [value]：设置值，如果不存在</p></li></ul><h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><p>卧槽，实在不想写了，参考: <a href="http://redisdoc.com/sorted_set/index.html">http://redisdoc.com/sorted_set/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>umi文件拆分</title>
      <link href="2018/11/11/front/react/umi-split-chunks/"/>
      <url>2018/11/11/front/react/umi-split-chunks/</url>
      
        <content type="html"><![CDATA[<p>umi文件拆分</p><a id="more"></a><blockquote><p>前言 在umi群里有群友在问umi打包后umi.js文件有1M多甚至更多，那么网站加载的时候会等待这个文件加载完成 可能需要好些时间 这个是比较难忍受的,其实umi有提供代码拆分的功能 只是文档不是很全 这里写了个片博客 谈谈怎么拆分的</p></blockquote><ol><li>使用命令yarn run analyze 打开分析页面，运行后会打开如图的页面<blockquote><p>analyze是package.js中定义好的命令’cross-env ANALYZE=1 umi build’ 可以自行添加或者查看umi文档</p></blockquote></li></ol><p><img src="http://qiniu.xxgtalk.cn/blog/images/front/reactumi-split-pre.jpg"><br>如图所示，目前umi文件比较大，现在来做拆分，比如这：把@ant-design和antd这两个拆分为antdesigns文件、把react|react-dom|react-router|react-router-dom|lodash|lodash-decorators|redux-saga|re-select|dva|moment这些拆分为wendors文件<br>2. 编写拆分规则 在umi.js||config.js文件的chainWebpack 中加入</p><pre class=" language-bash"><code class="language-bash">config.optimization.splitChunks<span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>    chunks: <span class="token string">'async'</span>,    minSize: 30000,    maxSize: 0,    minChunks: 1,    maxAsyncRequests: 5,    maxInitialRequests: 3,    automaticNameDelimiter: <span class="token string">'~'</span>,    name: true,    cacheGroups: <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>      vendors: <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        name: <span class="token string">'vendors'</span>,        chunks: <span class="token string">'all'</span>,        test: /<span class="token punctuation">[</span>\\/<span class="token punctuation">]</span>node_modules<span class="token punctuation">[</span>\\/<span class="token punctuation">]</span><span class="token punctuation">(</span>react<span class="token operator">|</span>react-dom<span class="token operator">|</span>react-router<span class="token operator">|</span>react-router-dom<span class="token operator">|</span>lodash<span class="token operator">|</span>lodash-decorators<span class="token operator">|</span>redux-saga<span class="token operator">|</span>re-select<span class="token operator">|</span>dva<span class="token operator">|</span>moment<span class="token punctuation">)</span><span class="token punctuation">[</span>\\/<span class="token punctuation">]</span>/,        priority: -10,      <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;,</span>      antdesigns: <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        name: <span class="token string">'antdesigns'</span>,        chunks: <span class="token string">'all'</span>,        test: /<span class="token punctuation">[</span>\\/<span class="token punctuation">]</span>node_modules<span class="token punctuation">[</span>\\/<span class="token punctuation">]</span><span class="token punctuation">(</span>@ant-design<span class="token operator">|</span>antd<span class="token punctuation">)</span><span class="token punctuation">[</span>\\/<span class="token punctuation">]</span>/,        priority: -11,      <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;,</span>  <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;);</span></code></pre><ol start="3"><li>在umi.js或者config.js 的umi-plugin-react中的chunks属性中配置配置如下<pre class=" language-bash"><code class="language-bash">chunks: <span class="token punctuation">[</span><span class="token string">'vendors'</span>,<span class="token string">'antdesigns'</span>, <span class="token string">'umi'</span><span class="token punctuation">]</span></code></pre></li><li>重新执行 yarn run analyze 查看拆分后的情况，如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/front/reactumi-split-next.jpg"></li></ol><p>致次 拆分完成</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> umi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode下调试es6编写的npm包</title>
      <link href="2018/09/22/front/other/vscodedebug/"/>
      <url>2018/09/22/front/other/vscodedebug/</url>
      
        <content type="html"><![CDATA[<ol start="0"><li>前置条件 安装好node环境</li><li>创建一个文件夹  执行npm init 更具需要选择</li><li>通过yarn安装babel-preset-es2015 (也可以通过npm等)<pre><code>yarn add -d babel-cli babel-preset-es2015 //安装babel-cli与babel-preset-es2015yarn add -d babel-preset-stage-1 //支持babel-preset-stage-1//yarn add -d babel-preset-react //如果需要支持react//yarn add -d babel-plugin-transform-object-assign //适用于Object.assign()//yarn add -d babel-plugin-transform-object-rest-spread //适用于展开运算符</code></pre></li><li>在package.json文件夹中添加一个scripts 如下所示:<pre><code>scripts: &#123; &quot;build&quot;: &quot;babel src --watch --source-maps --presets=es2015,stage-1 --out-dir dist&quot; //切记 --source-maps一定要加上&#125;</code></pre></li><li>跟目录下添加.babelrc 内容如下<pre><code>&#123; &quot;presets&quot;: [     &quot;es2015&quot;     //,&quot;react&quot; //如果有使用react ] //, //&quot;plugins&quot;:[ //    &quot;transform-object-assign&quot;, //适用于Object.assign() //    &quot;transform-object-rest-spread&quot; //适用于展开运算符 ... //]&#125;</code></pre></li><li>编写自己的代码，整体项目结构如下<br>|-src<br>&emsp;|–cores<br>&emsp;&emsp;|–math.js  –被引用的js文件<br>&emsp;|–index.js   –主入口js文件<br>|.babelrc<br>|.package.json  </li><li>切到vscode左侧的调试窗口，点击添加配置<br>这个时候会生成一个launch.json文件，修改内容如下<pre><code>&#123; // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [     &#123;         &quot;type&quot;: &quot;node&quot;,         &quot;request&quot;: &quot;launch&quot;,         &quot;name&quot;: &quot;Launch App.js&quot;,         &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/src/index.js&quot;,         &quot;outFiles&quot;: [             &quot;$&#123;workspaceRoot&#125;/dist/**/*.js&quot;         ]     &#125; ]&#125;</code></pre></li><li>先生成在运行调试<br>npm run build会生成一个dist目录，然后点击调试上的运行按钮 执行调试</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端-其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端-其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资料收集(持续更新中...)</title>
      <link href="2018/09/13/tools/collections/"/>
      <url>2018/09/13/tools/collections/</url>
      
        <content type="html"><![CDATA[<p>各大组件、工具收藏夹(持续更新中…)</p><a id="more"></a><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><table><thead><tr><th align="left">类型</th><th align="left">推荐组件</th></tr></thead><tbody><tr><td align="left">爬虫</td><td align="left"><a href="https://github.com/GoogleChrome/puppeteer">puppeteer</a>、<a href="https://github.com/kblok/puppeteer-sharp">puppeteer-sharp</a>、<a href="https://github.com/dotnetcore/DotnetSpider">DotnetSpide</a>、<a href="https://github.com/ferventdesert/Hawk">Hawk</a></td></tr><tr><td align="left">工业物联网</td><td align="left"><a href="https://github.com/dathlin/HslCommunication">HslCommunication</a></td></tr><tr><td align="left">斗地主</td><td align="left"><a href="https://github.com/2881099/FightLandlord">FightLandlord</a></td></tr><tr><td align="left">规则引擎</td><td align="left"><a href="https://github.com/NRules/NRules">NRules</a></td></tr><tr><td align="left">机器人</td><td align="left"><a href="https://github.com/leonlj/BotDemo">BotDemo</a></td></tr><tr><td align="left">定时任务</td><td align="left"><a href="https://github.com/zhaopeiym/quartzui">quartzui</a>、<a href="https://github.com/Topshelf/Topshelf">Topshelf</a></td></tr><tr><td align="left">机器学</td><td align="left"><a href="https://github.com/dotnet/machinelearning">machinelearning</a></td></tr><tr><td align="left">导出pdf</td><td align="left"><a href="https://github.com/MrRio/jsPDF">jsPDF</a>、<a href="https://github.com/wkhtmltopdf/wkhtmltopdf">wkhtmltopdf</a>、<a href="https://github.com/itext/itextsharp">itextsharp</a></td></tr><tr><td align="left">redis桌面管理器</td><td align="left"><a href="https://gitee.com/MaxBill/RedisPlus">RedisPlus</a></td></tr><tr><td align="left">host切换工具</td><td align="left"><a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a></td></tr><tr><td align="left">异常收集框架</td><td align="left"><a href="https://github.com/exceptionless/Exceptionless">Exceptionless</a></td></tr><tr><td align="left">容器监管</td><td align="left"><a href="https://github.com/portainer/portainer">portainer</a></td></tr></tbody></table><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table><thead><tr><th align="left">类型</th><th align="left">推荐组件</th></tr></thead><tbody><tr><td align="left">redis桌面管理器</td><td align="left"><a href="https://gitee.com/MaxBill/RedisPlus">RedisPlus</a></td></tr><tr><td align="left">host切换工具</td><td align="left"><a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a></td></tr></tbody></table><h2 id="纯前端库"><a href="#纯前端库" class="headerlink" title="纯前端库"></a>纯前端库</h2><table><thead><tr><th align="left">类型</th><th align="left">推荐组件</th></tr></thead><tbody><tr><td align="left">数字转大写</td><td align="left"><a href="https://github.com/cnwhy/nzh">nzh</a></td></tr><tr><td align="left">js帮助库</td><td align="left"><a href="https://github.com/lodash/lodash">lodash</a></td></tr><tr><td align="left">时区</td><td align="left"><a href="https://github.com/moment/moment">moment</a></td></tr><tr><td align="left">3D动画</td><td align="left"><a href="https://github.com/mrdoob/three.js">Three.js</a></td></tr><tr><td align="left">动画</td><td align="left"><a href="https://github.com/juliangarnier/anime">Anime.js</a>、<a href="https://github.com/greensock/GreenSock-JS">GreenSock</a></td></tr><tr><td align="left">打字机</td><td align="left"><a href="https://github.com/luisvinicius167/ityped">ityped</a></td></tr><tr><td align="left">悬停效果</td><td align="left"><a href="https://github.com/IanLunn/Hover">Hover</a></td></tr><tr><td align="left">快捷键</td><td align="left"><a href="https://github.com/jaywcjlove/hotkeys">hotkeys</a></td></tr><tr><td align="left">拖拽</td><td align="left"><a href="https://github.com/react-dnd/react-dnd">react-dnd</a>、<a href="https://github.com/atlassian/react-beautiful-dnd">react-beautiful-dnd</a></td></tr></tbody></table><h2 id="推荐-neter常用优秀开源项目"><a href="#推荐-neter常用优秀开源项目" class="headerlink" title="推荐.neter常用优秀开源项目"></a>推荐.neter常用优秀开源项目</h2><ul><li><p>Domain-Driven-Design-Example<br>DDD 示例 挺不错的.<br><a href="https://github.com/zkavtaskin/Domain-Driven-Design-Example">github https://github.com/zkavtaskin/Domain-Driven-Design-Example</a></p></li><li><p>SmartStoreNET<br>开源的电商项目<br><a href="https://github.com/smartstore/SmartStoreNET">github https://github.com/smartstore/SmartStoreNET</a></p></li><li><p>abp<br>ABP框架全称为“ASP.NET Boilerplate Project”，中文翻译为“ ASP.NET样板项目”，ABP是一个开源应用程序框架,专注于基于ASP.NET Core 的Web应用程序开发,但也支持开发其他类型的应用程序<br><a href="https://github.com/abpframework/abp">github https://github.com/abpframework/abp</a></p></li><li><p>grpc<br>gRPC 是一个由Google开源的，跨语言的，高性能的远程过程调用（RPC）框架。gRPC使客户端和服务端应用程序可以透明地进行通信，并简化了连接系统的构建。它使用HTTP/2作为通信协议，使用 Protocol Buffers 作为序列化协议。并且微软官方 ASP.NET 项目的人员进行维护，良好的接入 .NET Core 生态<br><a href="https://github.com/grpc/grpc-dotnet">github https://github.com/grpc/grpc-dotnet</a></p></li><li><p>Autofac<br>IOC容器<br><a href="https://github.com/autofac/Autofac">github https://github.com/autofac/Autofac</a></p></li><li><p>Hangfire<br>非常容易地在.NET或者.NETcore应用程序中执行后台任务，无需windows服务或者单独的进程。且任务信息可以被持久保存。<br><a href="https://github.com/HangfireIO/Hangfire">github https://github.com/HangfireIO/Hangfire</a></p></li><li><p>quartz<br>任务调度<br><a href="https://github.com/quartznet/quartznet">github https://github.com/quartznet/quartznet</a></p></li><li><p>polly<br>Polly 是一个 .NET 弹性和瞬态故障处理库，允许开发人员以 Fluent 和线程安全的方式来实现重试、断路、超时、隔离和回退策略。<br><a href="https://github.com/App-vNext/Polly">github https://github.com/App-vNext/Polly</a>  </p></li><li><p>redis 命令<br>《Redis Command Reference》全文的中文翻译版。 <a href="http://redisdoc.com/">http://RedisDoc.com</a><br><a href="https://github.com/huangz1990/redis">github https://github.com/huangz1990/redis</a>  </p></li><li><p>orleans<br>一种构建分布式、 高规模（伸缩）的应用程序， 奥尔良是一个框架，提供一个简单的方法来构建分布式的高规模计算应用程序，而无需了解并应用复杂并发或其他伸缩模式。它是由微软研究院创建和设计在云计算中使用。<br><a href="https://github.com/dotnet/orleans">github https://github.com/dotnet/orleans</a>  </p></li><li><p>rabbitmq-dotnet-client<br>rabbitmq 客户端类库<br><a href="https://github.com/rabbitmq/rabbitmq-dotnet-client">github https://github.com/rabbitmq/rabbitmq-dotnet-client</a>  </p></li><li><p>AutoMapper<br>将一个对象映射到另一个对象的代码。摆脱了繁琐的赋值过程<br><a href="https://github.com/AutoMapper/AutoMapper">github https://github.com/AutoMapper/AutoMapper</a>  </p></li></ul><h2 id="程序员一般可以从什么平台接私活"><a href="#程序员一般可以从什么平台接私活" class="headerlink" title="程序员一般可以从什么平台接私活"></a>程序员一般可以从什么平台接私活</h2><h3 id="国内"><a href="#国内" class="headerlink" title="国内"></a>国内</h3><ul><li><p>程序员客栈：<a href="https://www.proginn.com/">https://www.proginn.com</a><br>程序员客栈中国非常领先的自由工作平台，为中高端程序员、产品经理和设计师等等互联网相关人员提供稳定的线上工作机会，包括自由工作、远程工作和兼职工作，还支持按需雇佣，工作模式非常多，感兴趣的推荐大家尝试一下。<br>虽然名称叫程序员客栈，但是除了程序员，像产品经理，设计师等等互联网相关人员，都能在上面找到适合自己的项目。感兴趣的可以体验一下<br><a href="https://www.proginn.com/">https://www.proginn.com</a></p></li><li><p>CODING 码市：<a href="https://mart.coding.net/">https://mart.coding.net</a><br>Coding 旗下的互联网软件外包服务平台，平台以外包为主。</p></li><li><p>开源众包：zb.oschina.net/projects<br>开源中国的众包平台，主要是以众包为主。</p></li><li><p>猪八戒：<a href="https://zbj.com/">https://zbj.com</a><br>找兼职的地方，主要是入门级项目，不适合专业程序员，只适合新手。</p></li><li><p>英选：linktion.cn<br>平台以定制开发外包服务为主，也是外包项目平台。</p></li><li><p>快码众包：kuaima.co  </p></li><li><p>码易众包平台：mayigeek.com  </p></li><li><p> 一早一晚平台：yizaoyiwan.com/  </p></li><li><p>开发邦：<a href="http://www.kaifabang.com/">http://www.kaifabang.com</a>  </p></li><li><p>人人开发：rrkf.com  </p></li><li><p>厘米脚印：<a href="http://www.limijiaoyin.com/">http://www.limijiaoyin.com</a>  </p></li><li><p>Sxsoft：<a href="https://www.sxsoft.com/">https://www.sxsoft.com/</a>  </p></li><li><p>猿急送：<a href="https://www.yuanjisong.com/">https://www.yuanjisong.com/</a></p></li><li><p> 实现网传送门：shixian.com/</p></li><li><p>智城外包网：<a href="http://www.taskcity.com/">http://www.taskcity.com/</a></p></li></ul><h3 id="国外"><a href="#国外" class="headerlink" title="国外"></a>国外</h3><ul><li><p>Upwork：<a href="https://www.upwork.com/">https://www.upwork.com/</a><br>Upwork 是全球最大的、最优秀的、最规范的综合类人力外包服务平台，由著名的 Elance 和 oDesk 合并。这里聚集 900 万来自全球各地的自由工作者，你肯定可以在找到适合你的职位  </p></li><li><p>Freelancer：<a href="https://www.freelance.com/">https://www.freelance.com/</a><br>工作类型覆盖了很多不同的领域，由程序开发到市场营销、广告、会计、法务等一系列的可以远程的工作  </p></li><li><p>Dribbble：<a href="https://dribbble.com/jobs">https://dribbble.com/jobs</a><br>你没看错，Dribbble 不只是全球最受欢迎的设计师社区，同样是设计师寻找远程工作的好出处。自从被 Tiny 收购后，Dribbble 的招聘属性正在慢慢增强，试着持续 PO 出自己的好作品，等待你的伯乐，同样你可以关注 Jobs 页面，给心仪的 Team 提交简历  </p></li><li><p>Stackoverflow：<a href="https://stackoverflow.com/jobs">https://stackoverflow.com/jobs</a><br>被广大程序员熟知的 Stackoverflow 本身就是一个全民远程工作的公司，程序员在远程工作中有很大的先天优势，Stackoverflow Jobs 里有远程职位的筛选，这里有丰富的远程技术职位  </p></li><li><p>99designs：<a href="https://99designs.com/">https://99designs.com/</a><br>99designs 是一个专门针对设计师的雇佣平台，你可以在这里参加设计竞赛给公开的项目投标，也可以给雇主提供一对一的专业服务  </p></li><li><p>Remoteok：<a href="https://remoteok.io/">https://remoteok.io/</a><br>Remoteok 不仅提供最初的兼职类远程工作，还有全职类，签署合同类和实习类的工作。网站创始人 Pieter Levels 本身就是一名数字游民，他同样是 Nomadlist 的创始人  </p></li><li><p>Toptal：<a href="https://www.toptal.com/">https://www.toptal.com/</a><br>Toptal 是一个高端一些的自由职业者平台，适合比较有经验和工作尽力的远程工作者。它将企业与全球的软件工程师，设计师和业务顾问联系起来  </p></li><li><p>Ange：<a href="https://angel.co/job-collections/remote">https://angel.co/job-collections/remote</a><br>AngelList 主要是服务于初创公司和天使投资人的平台，这里还有初创公司提供的远程工作的机会，如果对远程加入初创公司感兴趣的，可以尝试一下  </p></li><li><p>Topcoder：<a href="https://www.topcoder.com/">https://www.topcoder.com/</a><br>Topcoder 通过算法比赛吸引世界顶级的程序员，他会将一下大型项目分割成很多小模块，通过竞赛的模式交给用户来做，优胜者可以拿到制定模块的奖金  </p></li></ul><blockquote><p><a href="/2018/12/10/front/react/components">react相关</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中安装Consul</title>
      <link href="2018/09/04/dotnetcore/consul/docker-zhong-an-zhuang-consul/"/>
      <url>2018/09/04/dotnetcore/consul/docker-zhong-an-zhuang-consul/</url>
      
        <content type="html"><![CDATA[<p>Docker中安装Consul</p><a id="more"></a><blockquote><p>Consul Docker镜像地址:<a href="https://hub.docker.com/_/consul">https://hub.docker.com/_/consul</a></p></blockquote><ol><li><p>Docker中启动Consul  </p><pre><code>docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul1 consul agent -server -bind=119.29.92.252 -bootstrap-expect=3 -node=consul1</code></pre><ul><li>-node：节点的名称  </li><li>-bind：绑定的一个地址，用于节点之间通信的地址，可以是内外网，必须是可以访问到的地址  </li><li>-server：这个就是表示这个节点是个SERVER  </li><li>-bootstrap-expect：这个就是表示期望提供的SERVER节点数目，数目一达到，它就会被激活，然后就是leader节点了</li></ul></li><li><p>启动节点2、3</p><pre><code>docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul2 consul agent -server -bind=172.17.0.3  -join=119.29.92.252 -node-id=$(uuidgen | awk &#39;&#123;print tolower($0)&#125;&#39;)  -node=consul2docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul3 consul agent -server -bind=172.17.0.4  -join=119.29.92.252 -node-id=$(uuidgen | awk &#39;&#123;print tolower($0)&#125;&#39;)  -node=consul3 -client=172.17.0.4</code></pre><ul><li>-join：这个表示启动的时候，要加入到哪个集群内，这里就是说要加入到*节点1的集群</li><li>-node-id：这个貌似版本8才加入的，这里用这个来指定唯一的节点ID，可以查看这个issue  </li><li>-client：这个表示注册或者查询等一系列客户端对它操作的IP，如果不指定这个IP，默认是127.0.0.1。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Consul </tag>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React资料收集</title>
      <link href="2018/08/01/front/react/collection/"/>
      <url>2018/08/01/front/react/collection/</url>
      
        <content type="html"><![CDATA[<p>React资料收集</p><a id="more"></a><h5 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h5><p>vscode、Rekit</p><h5 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h5><p>eslint-config-airbnb  最最最完整的javascript eslint规则</p><h5 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h5><p>代码格式化工具,vscode支持 安装插件 添加.prettier文件</p><h5 id="React-DevTool、Redux-DevTool"><a href="#React-DevTool、Redux-DevTool" class="headerlink" title="React DevTool、Redux DevTool"></a>React DevTool、Redux DevTool</h5><p>chrome浏览器插件</p><h5 id="单元测试相关"><a href="#单元测试相关" class="headerlink" title="单元测试相关"></a>单元测试相关</h5><ol><li>Jest:Facebook开源的JS单元测试狂阿基</li><li>JS DOM浏览器环境的NodeJS模拟</li><li>Enzyme:React组件渲染和测试</li><li>nock:模拟http请求</li><li>sinon：函数模拟和调用跟踪</li><li>istanbul:单元测试覆盖率</li></ol><blockquote><p><a href="/2018/09/13/tools/collections/">其他请查看</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装RabbitMQ</title>
      <link href="2018/06/08/docker/12docker-rabbitmq/"/>
      <url>2018/06/08/docker/12docker-rabbitmq/</url>
      
        <content type="html"><![CDATA[<p>Docker安装RabbitMQ</p><a id="more"></a><blockquote><p>参考地址:<a href="https://hub.docker.com/_/rabbitmq/">https://hub.docker.com/_/rabbitmq/</a></p></blockquote><ul><li>运行命令   <pre class=" language-docker"><code class="language-docker">docker run <span class="token punctuation">-</span>d <span class="token punctuation">-</span>p 8092<span class="token punctuation">:</span>15672 <span class="token punctuation">-</span>p 5672<span class="token punctuation">:</span>5672  <span class="token punctuation">-</span><span class="token punctuation">-</span>restart always <span class="token punctuation">-</span><span class="token punctuation">-</span>hostname my<span class="token punctuation">-</span>rabbit <span class="token punctuation">-</span><span class="token punctuation">-</span>name rabbit <span class="token punctuation">-</span>e RABBITMQ_DEFAULT_USER=xxg <span class="token punctuation">-</span>e RABBITMQ_DEFAULT_PASS=Abcd1234  rabbitmq<span class="token punctuation">:</span>3<span class="token punctuation">-</span>management</code></pre><blockquote><p>说明  </p></blockquote></li><li>e RABBITMQ_DEFAULT_USER=xxg    –默认用户名  </li><li>e RABBITMQ_DEFAULT_PASS=Abcd1234   –默认密码<br>rabbitmq:3-management       –表示使用带插件版本的(可以通过<a href="http://host-ip:8092/">http://host-ip:8092</a> 访问管理控制台)<br>4369/tcp    服务器 需要开放这个端口<br>5671/tcp    服务器 需要开放这个端口  </li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装redis</title>
      <link href="2018/06/06/docker/11docker-redis/"/>
      <url>2018/06/06/docker/11docker-redis/</url>
      
        <content type="html"><![CDATA[<p>Docker下安装redis</p><a id="more"></a><ol><li>创建网络<br>docker network create net_redis</li><li>创建redis配置文件(/docker/redis/config/redis.conf)  <pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#redis的databases数量</span>databases 32<span class="token comment" spellcheck="true">#redis密码</span>requirepass 123</code></pre></li><li>通过docker-compose安装<br>docker-compose -f redis-docker-compose.yml up -d<br><a href="http://qiniu.xxgtalk.cn/blog/files/docker/redis-docker-compose.yml">文件链接</a>  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET Core + Docker + Jenkins + gogs + CentOS 从零开始搭建持续集成</title>
      <link href="2018/06/06/docker/10docker-jenkins-gogs-cicd/"/>
      <url>2018/06/06/docker/10docker-jenkins-gogs-cicd/</url>
      
        <content type="html"><![CDATA[<p>ASP.NET Core + Docker + Jenkins + gogs + CentOS 从零开始搭建持续集成</p><a id="more"></a><blockquote><p>参考地址：<a href="https://www.cnblogs.com/stulzq/p/8629165.html">https://www.cnblogs.com/stulzq/p/8629165.html</a><br><a href="https://www.jianshu.com/p/64e9708c23e7">https://www.jianshu.com/p/64e9708c23e7</a><br>前置条件 安装了docker、配置了加速镜像(参考01)  </p></blockquote><ol><li>使用docker安装免费https证书  <pre><code>sudo docker run -it --rm --name certbot \ -v &quot;/etc/letsencrypt:/etc/letsencrypt&quot; \ -v &quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot; \ certbot/certbot certonly</code></pre>按照提示进行操作  </li><li>docker安装Gogs (一个gitserver，类似于gitlab)<br>创建文件/docker/gogs  然后运行如下命令<br>docker run -d –name=gogs -p 23:22 -p 8090:3000 –mount type=bind,src=/docker/gogs,dst=/data –restart always gogs/gogs   <blockquote><p>参考地址 <a href="https://github.com/gogits/gogs/tree/master/docker">https://github.com/gogits/gogs/tree/master/docker</a>   </p></blockquote></li><li>docker 安装jenkins<br>自定义镜像  <pre class=" language-yml"><code class="language-yml">FROM jenkinsUSER root#清除了基础镜像设置的源，切换成腾讯云的jessie源#使用非腾讯云环境的需要将 tencentyun 改为 aliyunRUN echo '' > /etc/apt/sources.list.d/jessie-backports.list \&& echo "deb http://mirrors.tencentyun.com/debian jessie main contrib non-free" > /etc/apt/sources.list \&& echo "deb http://mirrors.tencentyun.com/debian jessie-updates main contrib non-free" >> /etc/apt/sources.list \&& echo "deb http://mirrors.tencentyun.com/debian-security jessie/updates main contrib non-free" >> /etc/apt/sources.list#更新源并安装缺少的包RUN apt-get update && apt-get install -y libltdl7 && apt-get update</code></pre></li></ol><p>ARG dockerGid=999</p><p>RUN echo “docker:x:${dockerGid}:jenkins” &gt;&gt; /etc/group </p><h1 id="安装-docker-compose-因为等下构建环境的需要"><a href="#安装-docker-compose-因为等下构建环境的需要" class="headerlink" title="安装 docker-compose 因为等下构建环境的需要"></a>安装 docker-compose 因为等下构建环境的需要</h1><p>RUN curl -L <a href="https://github.com/docker/compose/releases/download/1.20.1/docker-compose-%60uname">https://github.com/docker/compose/releases/download/1.20.1/docker-compose-`uname</a> -s<code>-</code>uname -m` -o /usr/local/bin/docker-compose</p><p>RUN chmod +x /usr/local/bin/docker-compose</p><pre><code>docker build -t auto-jenkins .  创建目录/docker/jenkins/docker.sock、/docker/jenkins/jenkins_home  ``` ymldocker run --name jenkins -p 8091:8080 -p 50000:50000 \    --mount type=bind,src=/docker/jenkins/docker.sock,dst=/var/run/docker.sock \    --mount type=bind,src=$(which docker),dst=/bin/docker \    --mount type=bind,src=/docker/jenkins/jenkins_home,dst=/var/jenkins_home \    --restart always \    -d auto-jenkins</code></pre><p>docker run –name jenkins -p 8091:8080 -p 50000:50000 –mount type=bind,src=/docker/jenkins/docker.sock,dst=/var/run/docker.sock  –mount type=bind,src=$(which docker),dst=/bin/docke  –mount type=bind,src=/docker/jenkins/jenkins_home,dst=/var/jenkins_home –restart always -d auto-jenkins  </p><ol start="4"><li>ASP.NET Core 持续集成  </li><li>Jenkins配置Gogs webhook插件  </li><li>Jenkins持续集成演示  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7.x 安装gitlab-runner</title>
      <link href="2018/06/05/docker/07gitlab01-runner/"/>
      <url>2018/06/05/docker/07gitlab01-runner/</url>
      
        <content type="html"><![CDATA[<p>Centos7.x 安装gitlab-runner</p><a id="more"></a><blockquote><p>说明：开始尝试过在docker中安装gitlab-runner注册gitlab-runner啥的都没问题 但是gitlab-ci.yml文件中使用docker的时候提示xxxx daemon文件问题 折腾了好几天没能解决(大概的意思就是在容器内部使用使用docker访问不了外面的啥东西最后放弃了，该用在centos中直接安装gitlab-runner形式)<br>参考地址: <a href="http://www.cnblogs.com/xishuai/p/ubuntu-gitlab-ci-docker-aspnet-core-part-2.html">http://www.cnblogs.com/xishuai/p/ubuntu-gitlab-ci-docker-aspnet-core-part-2.html</a><br>【前置条件】 系统安装了docker、docker-compose、git、dotnetcore<br>docker 这个必须要<br>git 必须，因为需要通过git获取代码<br>docker-compose根据情况 因为我的ci中使用了docker-compose所以要<br>dotnetcore 因为我是微软的铁杆粉丝  </p></blockquote><ol><li>安装docker、docker-compose<a href="./01docker-config.html">参考01</a>    </li><li>gitlab-runner  </li></ol><ul><li>安装命令<br>sudo wget -O /usr/local/bin/gitlab-runner <a href="https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64">https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64</a>  </li><li>给予其权限<br>sudo chmod +x /usr/local/bin/gitlab-runner  </li><li>注册<br>sudo gitlab-runner register<br>根据提示输入gitlab地址、token、描述信息、tag、[true|false]、[true|false]、shell    </li><li>添加一个用于跑 GitLab Runner 的gitlab-runner用户<br>sudo useradd –comment ‘GitLab Runner’ –create-home gitlab-runner –shell /bin/bash    </li><li>指定 GitLab Runner 执行的用户和工作目录<br>sudo gitlab-runner install –user=gitlab-runner –working-directory=/home/gitlab-runner  </li><li>启动gitlab-runner<br>sudo gitlab-runner start  </li><li>把 GitLab Runner 服务器中的gitlab-runner账户，添加到docker用户组中<br>sudo usermod -aG docker gitlab-runner  </li><li>在 GitLab Runner 服务器中，切换到gitlab-runner用户下，配置 SSH  <pre><code>su gitlab-runnerssh-keygen -t rsa -P &#39;&#39;ssh-copy-id root@你的ip地址</code></pre></li></ul><ol start="3"><li>安装git<br>cd ~<br>yum -y install git  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装GitLab</title>
      <link href="2018/06/05/docker/07gitlab/"/>
      <url>2018/06/05/docker/07gitlab/</url>
      
        <content type="html"><![CDATA[<p>Docker下安装GitLab</p><a id="more"></a><blockquote><p>前置条件 安装好docker  </p></blockquote><ol><li>docker运行gitlab(由于22端口被ssh占用 改用23)  </li></ol><ul><li>在/docker/gitlab 目录下分别创建data、config、logs三个文件夹  </li><li>执行命令<pre class=" language-docker"><code class="language-docker">sudo docker run <span class="token punctuation">-</span><span class="token punctuation">-</span>detach <span class="token punctuation">-</span><span class="token punctuation">-</span>hostname gitlab.xxgtalk.cn <span class="token punctuation">-</span><span class="token punctuation">-</span>publish 443<span class="token punctuation">:</span>443 <span class="token punctuation">-</span><span class="token punctuation">-</span>publish 8090<span class="token punctuation">:</span>80 <span class="token punctuation">-</span><span class="token punctuation">-</span>publish 23<span class="token punctuation">:</span>22 <span class="token punctuation">-</span><span class="token punctuation">-</span>name gitlab <span class="token punctuation">-</span><span class="token punctuation">-</span>restart always <span class="token punctuation">-</span>v /docker/gitlab/config<span class="token punctuation">:</span>/etc/gitlab <span class="token punctuation">-</span>v /docker/gitlab/logs<span class="token punctuation">:</span>/var/log/gitlab <span class="token punctuation">-</span>v /docker/gitlab/data<span class="token punctuation">:</span>/var/opt/gitlab gitlab/gitlab<span class="token punctuation">-</span>ce* * * * * * 介绍 * * * * * *sudo docker run <span class="token punctuation">-</span><span class="token punctuation">-</span>detach \<span class="token punctuation">-</span><span class="token punctuation">-</span>hostname gitlab.xxgtalk.cn \<span class="token punctuation">-</span><span class="token punctuation">-</span>publish 443<span class="token punctuation">:</span>443 <span class="token punctuation">-</span><span class="token punctuation">-</span>publish 8090<span class="token punctuation">:</span>80 <span class="token punctuation">-</span><span class="token punctuation">-</span>publish 23<span class="token punctuation">:</span>22 \ <span class="token punctuation">-</span><span class="token punctuation">-</span>name gitlab \<span class="token punctuation">-</span><span class="token punctuation">-</span>restart always \<span class="token punctuation">-</span>v /docker/gitlab/config<span class="token punctuation">:</span>/etc/gitlab \ 配置文件映射到config文件夹<span class="token punctuation">-</span>v /docker/gitlab/logs<span class="token punctuation">:</span>/var/log/gitlab \<span class="token punctuation">-</span>v /docker/gitlab/data<span class="token punctuation">:</span>/var/opt/gitlab \gitlab/gitlab<span class="token punctuation">-</span>ce</code></pre>::: warning 注意</li></ul><ul><li>因为配置的ssh端口是23 所以需要修改/docker/gitlab/config/gitlab.rb文件中修改或增加<br>gitlab_rails[‘gitlab_shell_ssh_port’] = 23</li><li>查看日志<br>docker logs –follow gitlab<br>:::</li></ul><ol start="2"><li>docker下安装gitlab runner  </li></ol><ul><li>[2.1] 安装gitlab runner<pre class=" language-docker"><code class="language-docker">sudo docker run <span class="token punctuation">-</span>d <span class="token punctuation">-</span><span class="token punctuation">-</span>name gitlab<span class="token punctuation">-</span>runner <span class="token punctuation">-</span><span class="token punctuation">-</span>restart always <span class="token punctuation">-</span>v /srv/gitlab<span class="token punctuation">-</span>runner/config<span class="token punctuation">:</span>/docker/gitlab<span class="token punctuation">-</span>runner/config <span class="token punctuation">-</span>v /var/run/docker.sock<span class="token punctuation">:</span>/docker/gitlab<span class="token punctuation">-</span>runner/run/docker.sock gitlab/gitlab<span class="token punctuation">-</span>runner<span class="token punctuation">:</span>latest* * * * * * 介绍 * * * * * *sudo docker run <span class="token punctuation">-</span>d <span class="token punctuation">-</span><span class="token punctuation">-</span>name gitlab<span class="token punctuation">-</span>runner <span class="token punctuation">-</span><span class="token punctuation">-</span>restart always \v /srv/gitlab<span class="token punctuation">-</span>runner/config<span class="token punctuation">:</span>/docker/gitlab<span class="token punctuation">-</span>runner/config \<span class="token punctuation">-</span>v /var/run/docker.sock<span class="token punctuation">:</span>/docker/gitlab<span class="token punctuation">-</span>runner/run/docker.sock \gitlab/gitlab<span class="token punctuation">-</span>runner<span class="token punctuation">:</span>latest</code></pre></li><li>[2.2] 注册gitlab runner(官方建议跟gitlab不要放在同一个服务器上)【最后没有成功,改用<a href="/2018/06/05/docker/07gitlab01-runner/">07Gitlab01-runner</a> 】<br>参考地址:<a href="https://docs.gitlab.com.cn/runner/register/index.html">https://docs.gitlab.com.cn/runner/register/index.html</a>  <ul><li>运行下面命令启动注册程序<br>sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register</li><li>输入 GitLab 实例 URL<br>gitlab的域名  </li><li>输入获取到的用于注册 Runner 的 token:<br>y8R7nLY4x3mdBiZt9AQV  </li><li> 输入该 Runner 的描述，稍后也可通过 GitLab’s UI 修改:  </li><li> 给该 Runner 指派 tags, 稍后也可以在 GitLab’s UI 修改:  </li><li> 选择 Runner 是否接收未指定 tags 的任务（默认值：false）， 稍后可以在 GitLab’s UI 修改： true  </li><li> 选择是否为当前项目锁定该 Runner， 之后也可以在 GitLab’s UI 修改。 该功能通常用于被指定为某个项目的 Runner （默认值：true）：  </li><li>选择 Runner executor:<br> 我们使用docker  </li><li> 如果你选择 Docker 作为你的 executor，注册程序会让你设置一个默认的镜像， 作用于.gitlab-ci.yml中未指定镜像的项目<br>输入: microsoft/dotnet  </li></ul></li></ul><hr><h5 id="搭建私有仓库"><a href="#搭建私有仓库" class="headerlink" title="搭建私有仓库"></a>搭建私有仓库</h5><ol><li>在docker中创建文件夹registry 用来存放仓库镜像，然后运行命令  <pre class=" language-docker"><code class="language-docker">docker run <span class="token punctuation">-</span>d <span class="token punctuation">-</span>v /docker/registry<span class="token punctuation">:</span>/var/lib/registry <span class="token punctuation">-</span>p 8091<span class="token punctuation">:</span>5000 <span class="token punctuation">-</span><span class="token punctuation">-</span>restart=always <span class="token punctuation">-</span><span class="token punctuation">-</span>name registry registry</code></pre></li></ol><h5 id="使用docker-compose安装"><a href="#使用docker-compose安装" class="headerlink" title="使用docker-compose安装"></a>使用docker-compose安装</h5><p>请查看<a href="http://qiniu.xxgtalk.cn/blog/files/docker/gitlab-docker-compose.yml">docker-compose文件</a> </p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker-compose</title>
      <link href="2018/06/04/docker/06docker-compose/"/>
      <url>2018/06/04/docker/06docker-compose/</url>
      
        <content type="html"><![CDATA[<p>使用docker-compose按照webapi&amp;mysql</p><a id="more"></a><p><a href="./05docker-webapi-mysql.html">接Docker制作WebApi&amp;MySql</a></p><ol><li><p>创建docker-compose.yml文件  </p><pre class=" language-docker"><code class="language-docker">version <span class="token string">'1'</span>services<span class="token punctuation">:</span> db<span class="token punctuation">:</span>     image<span class="token punctuation">:</span> mysql/mysql<span class="token punctuation">-</span>server     container_name<span class="token punctuation">:</span> <span class="token string">'db'</span>     command<span class="token punctuation">:</span> mysqld <span class="token punctuation">-</span><span class="token punctuation">-</span>character<span class="token punctuation">-</span>set<span class="token punctuation">-</span>server=utf8 <span class="token punctuation">-</span><span class="token punctuation">-</span>collaction<span class="token punctuation">-</span>server=utf8_general_ci     restart<span class="token punctuation">:</span> always     ports<span class="token punctuation">:</span>       <span class="token punctuation">-</span><span class="token string">'3306:3306'</span>     environment<span class="token punctuation">:</span>       MYSQL_ROOT_PASSWORD<span class="token punctuation">:</span> Abcd1234       MYSQL_USER<span class="token punctuation">:</span> sa       MYSQL_PASWORD<span class="token punctuation">:</span> Abcd1234     volumes<span class="token punctuation">:</span>       <span class="token punctuation">-</span> /docker/mysql/db<span class="token punctuation">-</span>init<span class="token punctuation">:</span>/docker<span class="token punctuation">-</span>entrypoint<span class="token punctuation">-</span>initdb.d webapi<span class="token punctuation">:</span>     build<span class="token punctuation">:</span> .     container_name<span class="token punctuation">:</span> <span class="token string">'webapi01'</span>     ports<span class="token punctuation">:</span>       <span class="token punctuation">-</span><span class="token string">'5000:80'</span>     depends_on<span class="token punctuation">:</span>       <span class="token punctuation">-</span> db</code></pre><blockquote><p>【注意】<br>由于db需要初始化用户角色 所以在资料卷中指定目录下放入sql 内容<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘sa’@’%’ WITH GRANT OPTION;  </p></blockquote></li><li><p>执行命令<br>docker-compose build<br>docker up    //docker down 与docker up相反  </p><blockquote><p><a href="http://qiniu.xxgtalk.cn/blog/files/docker/mysql-docker-compose.yml">docker-compose文件</a>  </p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker制作WebApi&amp;MySql</title>
      <link href="2018/06/03/docker/05docker-webapi-mysql/"/>
      <url>2018/06/03/docker/05docker-webapi-mysql/</url>
      
        <content type="html"><![CDATA[<p>Docker制作WebApi&amp;MySql 直接上图</p><a id="more"></a><p><img src="http://qiniu.xxgtalk.cn/blog/images/docker/050a01.png"></p><ol><li><p>docker文件  </p><pre class=" language-docker"><code class="language-docker"><span class="token keyword">FROM</span> microsoft/aspnetcore<span class="token punctuation">-</span>build as build<span class="token punctuation">-</span>env<span class="token keyword">WORKDIR</span> /code<span class="token keyword">COPY</span> *.csproj ./<span class="token keyword">RUN</span> dotnet restore<span class="token keyword">COPY</span> . ./<span class="token keyword">RUN</span> dotnet publish <span class="token punctuation">-</span>c Release <span class="token punctuation">-</span>o out<span class="token keyword">FROM</span> microsoft/aspnetcore<span class="token keyword">WORKDIR</span> /app<span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>from=build<span class="token punctuation">-</span>env /code/out ./<span class="token keyword">EXPOSE</span> 50000<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"dotnet"</span><span class="token punctuation">,</span><span class="token string">"WebApiDocker.dll"</span><span class="token punctuation">]</span></code></pre></li><li><p>编译docker文件  </p><pre class=" language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>t  xxg/aspnetcore<span class="token punctuation">:</span>1.0 .</code></pre></li><li><p>使用该镜像启动一个容器<br>a. docker run -d -p 5000:80  –name api01 –link mysql01:db xxg/aspnetcore:1.0<br>b. 使用bridge形式<br>docker network create -d bridge mybridge        //创建一个网络<br>docker run -d -p 5000:5000 –net mybridge –name api1 xxg/aspnetcore:1.0<br>docker network connect mysql01  mybridge    //表示将mysql01跟mybridge网络连接起来  </p><blockquote><p>–link mysql01:db        –表示将mysql01取个别名db并连接到当前容器<br>–net mybridge        –表示使用指定网络</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装MsSqlserver</title>
      <link href="2018/06/02/docker/04docker-mssqlserver/"/>
      <url>2018/06/02/docker/04docker-mssqlserver/</url>
      
        <content type="html"><![CDATA[<p>Docker安装MsSqlserver</p><a id="more"></a><blockquote><p>未成功</p></blockquote><ol><li>执行命令<br>``` sql<br>docker run -e ‘ACCEPT_EULA=Y’ -e ‘MSSQL_SA_PASSWORD=Abcd1234’ -v=/docker/mssql:/var/opt/mssql  -p 1433:1433 –name sqlserver  -d microsoft/mssql-server-linux:2017-latest  </li></ol><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li>备注 * * * * * * * * *<br>docker run -e ‘ACCEPT_EULA=Y’  –是否接受协议</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>-e ‘MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;’ –设置密码<br>-p 1433:1433    –端口<br>–name sqlserver       –用户</li></ul> -d microsoft/mssql-server-linux:2017-latest –2017latest版本<pre><code></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 安装MySql</title>
      <link href="2018/06/02/docker/04docker-install-mysql/"/>
      <url>2018/06/02/docker/04docker-install-mysql/</url>
      
        <content type="html"><![CDATA[<p>Docker 安装MySql<br><a id="more"></a></p><blockquote><p>将docker容器中的实例中的文件跟物理文件链接起来 即使删掉容器 数据还在 再创建容器的时候 任然可以对应上之前的数据  </p></blockquote><h4 id="一、安装篇"><a href="#一、安装篇" class="headerlink" title="一、安装篇"></a>一、安装篇</h4><ol><li>使用docker-compose安装  </li></ol><ul><li>[1.1] 在目录/docker/data/mysql/mysql-init下创建init-user.sql文件 内容如下  <pre><code>use mysql;CREATE USER &#39;sa&#39;@&#39;%&#39; IDENTIFIED BY &#39;Abcd1234&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;sa&#39;@&#39;%&#39;;</code></pre></li><li>[1.2]<br>docker-compose -f mysql-compose.yml up -d<br>对应的mysql-compose.yml文件<br><code>`</code> yml<br>version: ‘2.3’</li></ul><p>services:<br>  db:<br>    image: mysql/mysql-server<br>    container_name: mysql01<br>    restart: always<br>    command: mysqld –character-set-server=utf8 –collation-server=utf8_general_ci<br>    ports:</p><pre><code>  - 3306:3306</code></pre><h1 id="networks"><a href="#networks" class="headerlink" title="networks:"></a>networks:</h1><h1 id="net-mysql"><a href="#net-mysql" class="headerlink" title="- net_mysql"></a>- net_mysql</h1><pre><code>environment:  MYSQL_ROOT_PASSWORD: Abcd1234volumes:  - /docker/data/mysql/mysql-init:/docker-entrypoint-initdb.d  - /docker/data/mysql/data:/var/lib/mysql</code></pre><h1 id="volumes"><a href="#volumes" class="headerlink" title="volumes:"></a>volumes:</h1><h1 id="mysql-data"><a href="#mysql-data" class="headerlink" title="mysql-data:"></a>mysql-data:</h1><h1 id="external-true"><a href="#external-true" class="headerlink" title="external: true"></a>external: true</h1><h1 id="networks-1"><a href="#networks-1" class="headerlink" title="networks:"></a>networks:</h1><h1 id="net-mysql-1"><a href="#net-mysql-1" class="headerlink" title="net_mysql:"></a>net_mysql:</h1><h1 id="external-true-1"><a href="#external-true-1" class="headerlink" title="external: true"></a>external: true</h1><pre><code>2. mount【推荐使用】  </code></pre><p>docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Abcd1234 –name mysql01 –restart always –mount type=bind,src=/docker/mysql/config/my.cnf,dst=/etc/my.cnf –mount type=bind,src=/docker/mysql/data,dst=/var/lib/mysql mysql</p><pre><code>&gt; /docker/mysql/config/my.cnf    &amp;nbsp;&amp;nbsp;对应物理磁盘位置 需要新建my.cnf 内容如下</code></pre><p>[mysqld]<br>user=root<br>character-set-server=utf8<br>[client]<br>default-character-set=utf8<br>[mysql]<br>default-character-set=utf8</p><pre><code>&gt; /etc/my.cnf    --docker创建mysql后该mysql容器对应的配置文件  /docker/mysql/data    --对应物理磁盘位置 表示docker中数据映射到的物理文件位置  /var/lib/mysql mysql/mysql-server &amp;nbsp;&amp;nbsp;对应docker中mysql实例容器的文件位置  -e  MYSQL_ROOT_PASSWORD=Abcd1234 &amp;nbsp;设置初始密码  1. volume[后期废用]  推荐使用mount形式  </code></pre><p>docker run -d -p 3306:3306 –name mysql01 -v=/docker/mysql/config/my.cnf:/etc/my.cnf -v=/docker/mysql/data:/var/lib/mysql mysql/mysql-server<br><code>`</code></p><h4 id="二、使用篇"><a href="#二、使用篇" class="headerlink" title="二、使用篇"></a>二、使用篇</h4><blockquote><p>docker 操作mysql  </p><ol><li>连接mysql<br>docker exec -it mysql01 bash<br>mysql -u root -p [密码]     –密码可以待mysql容器启动后<br>通过docker logs mysql01 找到生成的随机密码 密码在一段类型：<br><img src="/images/docker/040101.png" alt=""></li><li>设置mysql密码<br>SET PASSWORD FOR ‘root‘@’localhost’ = PASSWORD(‘Abcd1234’);    –用户名为root 密码为Abcd1234  </li><li>实验一下    【–exit 退出当前】<br>use mysql;    –使用数据库查询<br>select user,host from user;    –查询用户信息<br>show variables like ‘%char%’;        –查看当前使用的字符集<br>在mysql中创建网络用户 这样可以非本机访问<br>mysql&gt; CREATE USER ‘sa‘@’%’ IDENTIFIED BY ‘Abcd1234’;<br>mysql&gt; GRANT ALL PRIVILEGES ON <em>.</em> TO ‘sa‘@’%’;<br>docker run -d -p 3306:3306 -e”MYSQL_USER=Zarc” -e”MYSQL_PASSWORD=pwd123456” -e”MYSQL_ROOT_PASSWORD=password123” -e”MYSQL_RANDOM_ROOT_PASSWORD=true” –name mysql01 mysql/mysql-server –character-set-server=utf8 –collation-server=utf8_general_ci<br>备注： : When this is true (which is its default state, unless MYSQL_ROOT_PASSWORD is set or MYSQL_ALLOW_EMPTY_PASSWORD is set to true), a random password for the server’s root user is generated when the Docker container is started 当这个MYSQL_RANDOM_ROOT_PASSWORD 为true 时 为root用户设置密码是没有作用的还是会生成随机的密码，设置为false 或者不加这个环境变量  </li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装mongodb</title>
      <link href="2018/06/01/docker/03docker-mongodb/"/>
      <url>2018/06/01/docker/03docker-mongodb/</url>
      
        <content type="html"><![CDATA[<p>Docker安装mongodb</p><a id="more"></a><ol><li>配置好docker的加速镜像[参考02Docker安装及配置]  </li><li>docker pull mongo 拉去mongo镜像  </li><li>启动docker实例  <blockquote><p>方式一<br>docker run -d -p 27017:27017 –name mongodb mongo<br>方式二 将容器的文件挂在到Host Volume  </p></blockquote></li></ol><p>–首先创建文件夹  /docker/mongo/config  以及/docker/mongo/data 用于与docker中mongo实例链接  然后运行命令</p><pre class=" language-bash"><code class="language-bash">docker run -d -p 27017:27017 --name mongo01 -v /docker/mongo/config:/data/configdb -v<span class="token operator">=</span>/docker/mongo/data:/data/db mongo</code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装及配置加速镜像</title>
      <link href="2018/05/30/docker/01docker-config/"/>
      <url>2018/05/30/docker/01docker-config/</url>
      
        <content type="html"><![CDATA[<p>Docker安装及配置加速镜像</p><a id="more"></a><blockquote><p>个人阿里云加速镜像个人地址&nbsp; <a href="https://noe4mlw6.mirror.aliyuncs.com/">https://noe4mlw6.mirror.aliyuncs.com</a></p></blockquote><hr><h5 id="CentOS-7-使用yum进行安装"><a href="#CentOS-7-使用yum进行安装" class="headerlink" title="CentOS 7 (使用yum进行安装)"></a>CentOS 7 (使用yum进行安装)</h5><p>如果之前安装过】先卸载依赖  </p><pre class=" language-bash"><code class="language-bash">  <span class="token function">sudo</span> yum remove docker \  docker-common \  container-selinux \  docker-selinux \  docker-engine \  docker-engine-selinux</code></pre><ol><li>直接安装<br>curl -sSL <a href="https://get.docker.com/">https://get.docker.com/</a> | sh</li><li>启动 并设置开机启动  <pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre></li></ol><blockquote><p>配置docker使用国内镜像<br>如何配置镜像加速器<br>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：  </p></blockquote><pre><code>&#123;  &quot;registry-mirrors&quot;: [&quot;https://noe4mlw6.mirror.aliyuncs.com&quot;]&#125;</code></pre><p>重启docker  </p><pre><code>sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><ol><li>sudo curl -L <a href="https://github.com/docker/compose/releases/download/1.20.0/docker-compose-%60uname">https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname</a> -s<code>-</code>uname -m` -o /usr/local/bin/docker-compose  </li><li>sudo chmod a+x /usr/local/bin/docker-compose <blockquote><p>卸载<br>sudo rm /usr/local/bin/docker-compose</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile解析</title>
      <link href="2018/05/30/docker/02docker-dockerfile/"/>
      <url>2018/05/30/docker/02docker-dockerfile/</url>
      
        <content type="html"><![CDATA[<p>Dockerfile解说<br><a id="more"></a></p><table><thead><tr><th style="text-align:left">关键字</th><th style="text-align:left">说明</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">FROM</td><td style="text-align:left">以此为基础来构建</td><td style="text-align:left">FROM debian:buster-slim</td></tr><tr><td style="text-align:left">MAINTAINER</td><td style="text-align:left">镜像维护着的项目和邮箱地址</td><td style="text-align:left">MAINTAINER The CentOS Project <a href="mailto:&#x78;&#x78;&#x78;&#x78;&#64;&#99;&#101;&#x6e;&#x74;&#111;&#115;&#46;&#x6f;&#114;&#x67;">&#x78;&#x78;&#x78;&#x78;&#64;&#99;&#101;&#x6e;&#x74;&#111;&#115;&#46;&#x6f;&#114;&#x67;</a></td></tr><tr><td style="text-align:left">RUN</td><td style="text-align:left">容器构建时运行的命令</td></tr><tr><td style="text-align:left">EXPOSE</td><td style="text-align:left">当前容器对外暴露的端口</td></tr><tr><td style="text-align:left">WORKDIR</td><td style="text-align:left">指定容器创建后，终端默认进来的工作目录</td></tr><tr><td style="text-align:left">ENV</td><td style="text-align:left">用来在构建镜像过程中设置环境变量</td></tr><tr><td style="text-align:left">ADD</td><td style="text-align:left">将宿主机目录下的文件拷贝到镜像且ADD命令会自动处理URL和解压tar压缩包</td><td style="text-align:left">ADD c48-docker.tar.xz /</td></tr><tr><td style="text-align:left">COPY</td><td style="text-align:left">跟ADD类似，但是不会解压</td><td style="text-align:left">copy src desc、copy [“src”,”desc”]</td></tr><tr><td style="text-align:left">VOLUME</td><td style="text-align:left">容器数据卷，用于数据保存和持久化工作</td><td style="text-align:left">VOLUME [“/xxg-data1”,”/xxg-data2”]</td></tr><tr><td style="text-align:left">CMD</td><td style="text-align:left">指定一个容器启动时要运行的命令，Dockerfile中可以有多个CMD指令，<strong><em>但只有最后一个生效</em></strong>，CMD会被docker run之后的参数替换</td><td style="text-align:left">CMD /bin/bash </td></tr><tr><td style="text-align:left">ENTRYPOINT</td><td style="text-align:left">指定一个容器启动时要运行的命令，和CMD一样，都是指定容器启动程序及参数</td><td style="text-align:left">ENTRYPOINT netcore.dll</td></tr><tr><td style="text-align:left">ONBUILD</td><td style="text-align:left">当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</td></tr></tbody></table><pre class=" language-Dockerfile"><code class="language-Dockerfile"># 案例一  构建一个自己的centos系统FROM centosENV mypath /tmpWORKDIR $mypathRUN yum -y install vimRUN yum -y install net-toolsEXPORT 80CMD /bin/bash </code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="2018/05/28/docker/00command/"/>
      <url>2018/05/28/docker/00command/</url>
      
        <content type="html"><![CDATA[<p>Docker常用命令<br><a id="more"></a></p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:left">docker –version</td><td style="text-align:left">查看当前docker版本</td></tr><tr><td style="text-align:left">docker ps</td><td style="text-align:left">查看当前正在运行的容器</td></tr><tr><td style="text-align:left">docker images</td><td style="text-align:left">查看本地所有镜像</td></tr><tr><td style="text-align:left">docker pull [镜像名称]</td><td style="text-align:left">拉取一个镜像到本地</td></tr><tr><td style="text-align:left">docker run [容器名称]</td><td style="text-align:left">运行一个容器</td></tr><tr><td style="text-align:left">docker rm [容器名称]</td><td style="text-align:left">删除本地使用过的容器</td></tr><tr><td style="text-align:left">docker start [Name]</td><td style="text-align:left">启动指定容器</td></tr><tr><td style="text-align:left">docker stop [Name]</td><td style="text-align:left">关闭指定容器</td></tr><tr><td style="text-align:left">docker kill [Name]</td><td style="text-align:left">强制关闭指定容器</td></tr><tr><td style="text-align:left">docker pause [Name]</td><td style="text-align:left">暂停指定容器</td></tr><tr><td style="text-align:left">docker unpause [Name]</td><td style="text-align:left">恢复指定容器</td></tr><tr><td style="text-align:left">docker rmi -f $(docker images -a -q)</td><td style="text-align:left">移除所有images</td></tr><tr><td style="text-align:left">docker rmi $(docker images -f ‘dangling=true’ -q)</td><td style="text-align:left">移除none的images  </td></tr><tr><td style="text-align:left">docker inspect [容器名称]</td><td style="text-align:left">查看容器的信息</td></tr><tr><td style="text-align:left">docker exec -it [容器名称] bash</td><td style="text-align:left">在容器内执行bash 比如执行后可以执行ls查看目录 也可以创建文件等</td></tr><tr><td style="text-align:left">docker rm -fv [容器Id]</td><td style="text-align:left">停止、删除容器、清除数据</td></tr><tr><td style="text-align:left">docker images -f [option]</td><td style="text-align:left">过滤查询</td></tr><tr><td style="text-align:left">docker logs -f [container-name]</td><td style="text-align:left">查看日志</td></tr><tr><td style="text-align:left">docker history [container-name]</td><td style="text-align:left">查看镜像的构建历史</td></tr></tbody></table><ul><li><p>数据卷<br>-v 主机目录:容器目录<br>docker run -it -v /docker/data:/config [–privileged=true] 表示将宿主机中的/docker目录跟容器中的/config目录做一个映射，如果没有将自动创建  </p><blockquote><p>如果遇到数据卷没权限访问，则在后面增加 –privileged=true即可</p></blockquote></li><li><p>数据卷容器<br>–volumns-form containerId|name  表示容器数据卷从name容器同步  </p><blockquote><p>docker run -it –name xxg2 –volumns-from xxg1 nginx</p></blockquote></li></ul><p>warning 温馨提示</p><ul><li>docker run -p 8001:80   &nbsp;&nbsp;–运行 指定端口 8001外部端口  80表示内部端口</li><li>docker run -d             &nbsp;&nbsp;–detach 还可以继续操作 不会阻塞</li><li>docker run –name        &nbsp;&nbsp;–运行的docker镜像的名称</li><li>docker run -p 8001:80 &nbsp;&nbsp;–name myapi helloapi:latest<br>表示运行docker中名为helloapi的容器 版本为latest docker的端口为80 本机的端口8001 名字为myapi</li><li>docker ps -a            &nbsp;&nbsp;–查看所有容器 不管有没运行</li><li>过滤查询<br>docker images –filter “before=image1” 查询image1之后的<br>docker images –filter “since=image3”  查询image3之前的<br>docker images “wechat:v1.3.<em>“  查询wechat:1.3.x的<br>docker rmi -f $(docker images “wechat:v1.2.</em>“ -q) 移除wechat:v1.2.*版本的</li><li><p>docker logs查看日志<br>docker logs -f gitlab 查看gitlab容器所有日志<br>docker logs –tail 20 -f gitlab 查看gitlab最近20条的日志<br>docker logs –since 30s -f gitlab 查看gitlab最近30s的日志</p></li><li><p>docker inspect 查看日志文件位置  </p><pre class=" language-bash"><code class="language-bash">docker inspect --format<span class="token operator">=</span><span class="token string">'&amp;#123;&amp;#123;.LogPath&amp;#125;&amp;#125;'</span> mysql  </code></pre></li><li>清空docker实例的日志内容  </li></ul><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">$(</span>docker inspect --format<span class="token operator">=</span><span class="token string">'&amp;#123;&amp;#123;.LogPath&amp;#125;&amp;#125;'</span> <span class="token operator">&lt;</span>容器ID<span class="token operator">></span><span class="token punctuation">)</span></code></pre><ul><li>退出 -it<br>exit 或者ctrl+p+q<br>:::</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows使用相关</title>
      <link href="2018/05/20/tools/windows/"/>
      <url>2018/05/20/tools/windows/</url>
      
        <content type="html"><![CDATA[<h4 id="window技巧-长期更新"><a href="#window技巧-长期更新" class="headerlink" title="window技巧-长期更新"></a>window技巧-长期更新</h4><a id="more"></a><h5 id="一、技巧篇"><a href="#一、技巧篇" class="headerlink" title="一、技巧篇"></a>一、技巧篇</h5><ul><li><p>查看占用端口<br>netstat -aon    [|findstr “1005”]      查找1005端口被那个占用  </p></li><li><p>windows下删除多层级文件夹：<br>安装rimraf包：npm install -g rimraf<br>然后通过：rimraf &lt;目录名称&gt; 来删除  </p></li><li><p>*#06#:查看IphoneCMD</p></li><li><p> 如何下载到本地，而不是边下载边更新：<br>创建一个快捷方式，在快捷方式的后面加 “-layout” 双击后就是下载到本地 而不是安装</p></li><li><p>打开本地连接：ncpa.cpl</p></li><li><p>查看系统支持的最大内存：wmic memphysical get maxcapacity</p></li><li><p>修改hosts文件后刷新 ipconfig -flushdns</p><h5 id="二、快捷键"><a href="#二、快捷键" class="headerlink" title="二、快捷键"></a>二、快捷键</h5></li><li><p>comexp.msc:打开window组件服务，可以查看事务  </p></li><li><p>netplwiz   :修改用户组相关  </p></li><li><p>inetmgr:打开IIS  </p></li><li><p>ssms:SQLServer数据库</p></li><li><p>SQLServerManager11.msc 数据库管理工具</p></li><li><p>devenv:VS</p></li><li><p>mstsc:远程</p></li><li><p>Alt+Enter 显示所选项的属性</p></li><li><p>Alt+Esc 以项目打开的顺序循环切换项目</p></li><li><p>Alt+向上键 在 Windows 资源管理器中查看上一级文件夹</p></li><li><p>Win + M：最小化所有窗口</p></li><li><p>Windows 徽标键 + 加号或减号 放大或缩小</p></li><li><p>Windows 徽标键 输入mspaint 打开画图</p></li><li><p>Windows 徽标键 输入psr打开系统视频录制</p></li><li><p>Windows 徽标键  snippingtool  win7自带截图工具</p></li><li><p>notepad 打开记事本</p></li><li><p>write———-写字板</p></li><li><p>perfmon.msc—-计算机性能监测程序</p></li><li><p>services.msc 服务</p></li><li><p>f10或alt键 激活当前程序的菜单栏</p></li><li><p>osk————打开屏幕键盘 </p></li><li><p>结束进程：cmd—taskkill /im`notepad.exe /t</p></li><li><p>cdm常用命令：具体参考（<a href="http://www.51xue8.com/e/DownSys/play/?classid=31&amp;id=1001&amp;pathid=4&amp;jishu=26%EF%BC%89">http://www.51xue8.com/e/DownSys/play/?classid=31&amp;id=1001&amp;pathid=4&amp;jishu=26）</a></p></li><li><p>ver====显示系统版本······ver/? =帮助</p></li><li><p>dir====显示驱动版本 · ·······dir/? =帮助</p></li><li><p>copy（用法4，全部复制）如：copy c:\新建文件夹*.* ()d:\txt</p></li><li><p>chkdsk/?=====查看磁盘文件报告</p></li><li><p>chkdsk===检查磁盘</p></li><li><p>dir====C盘文件夹目录（详细，时间，大小··）</p></li><li><p>dir/w =====显示C盘文件夹 （不显示时间，大小）</p></li><li><p>dir/l 显示子文件夹</p></li><li><p>dir/p======屏幕显示不完时加p</p></li><li><p>format====格式化磁盘（慎用）如：format g:</p></li><li><p>format/?====格式化帮助</p></li><li><p>del=====删除文件 如：del c:\···</p></li><li><p>del/?===删除帮助</p></li><li><p>md====创建文件夹</p></li><li><p>ipconfig ====查看ip等信息</p></li><li><p>ren=====文件重命名</p></li><li><p>nslookup======ip地址查询</p></li><li><p>exit=====退出</p></li><li><p>rd======删除目录</p></li><li><p>tasklist =====显示进程</p></li><li><p>type=======显示文本内容</p></li><li><p>tree=======显示所有文件名····显示D盘则tree d:\</p></li><li><p>ping=======检测网络···如ping（必须空格）-f</p></li><li><p>net user=========更改用户</p></li><li><p>net share====== 查看共享文件</p></li><li><p>help==============显示所有命令</p></li><li><p>gpedit.msc—–组策略</p></li><li><p>sndrec32——-录音机</p></li><li><p>Nslookup——-IP地址侦测器</p></li><li><p>explorer——-打开资源管理器</p></li><li><p>logoff———注销命令</p></li><li><p>tsshutdn——-60秒倒计时关机命令</p></li><li><p>lusrmgr.msc—-本机用户和组</p></li><li><p>services.msc—本地服务设置</p></li><li><p>oobe/msoobe /a—-检查XP是否激活</p></li><li><p>cleanmgr——-垃圾整理</p></li><li><p>net start messenger—-开始信使服务</p></li><li><p>compmgmt.msc—计算机管理</p></li><li><p>net stop messenger—–停止信使服务</p></li><li><p>conf———–启动netmeeting</p></li><li><p>dvdplay——–DVD播放器</p></li><li><p>charmap——–启动字符映射表</p></li><li><p>diskmgmt.msc—磁盘管理实用程序</p></li><li><p>calc———–启动计算器</p></li><li><p>dfrg.msc——-磁盘碎片整理程序</p></li><li><p>chkdsk.exe—–Chkdsk磁盘检查</p></li><li><p>devmgmt.msc— 设备管理器</p></li><li><p>regsvr32 /u *.dll—-停止dll文件运行</p></li><li><p>drwtsn32—— 系统医生</p></li><li><p>rononce -p —-15秒关机</p></li><li><p>dxdiag———检查DirectX信息</p></li><li><p>regedt32——-注册表编辑器</p></li><li><p>Msconfig.exe—系统配置实用程序</p></li><li><p>rsop.msc——-组策略结果集</p></li><li><p>mem.exe——–显示内存使用情况</p></li><li><p>regedit.exe—-注册表</p></li><li><p>winchat——–XP自带局域网聊天</p></li><li><p>progman——–程序管理器</p></li><li><p>winmsd———系统信息</p></li><li><p>perfmon.msc—-计算机性能监测程序</p></li><li><p>winver———检查Windows版本</p></li><li><p>sfc /scannow—–扫描错误并复原</p></li><li><p>taskmgr—–任务管理器（2000／xp／2003</p></li><li><p>winver———检查Windows版本</p></li><li><p>wmimgmt.msc—-打开windows管理体系结构(WMI)</p></li><li><p>wupdmgr——–windows更新程序</p></li><li><p>wscript——–windows脚本宿主设置</p></li><li><p>write———-写字板</p></li><li><p>winmsd———系统信息</p></li><li><p>wiaacmgr——-扫描仪和照相机向导</p></li><li><p>winchat——–XP自带局域网聊天</p></li><li><p>mem.exe——–显示内存使用情况</p></li><li><p>Msconfig.exe—系统配置实用程序</p></li><li><p>mplayer2——-简易widnows media player</p></li><li><p>mspaint——–画图板</p></li><li><p>mstsc———-远程桌面连接</p></li><li><p>mplayer2——-媒体播放机</p></li><li><p>magnify——–放大镜实用程序</p></li><li><p>mmc————打开控制台</p></li><li><p>mobsync——–同步命令</p></li><li><p>dxdiag———检查DirectX信息</p></li><li><p>drwtsn32—— 系统医生</p></li><li><p>devmgmt.msc— 设备管理器</p></li><li><p>dfrg.msc——-磁盘碎片整理程序</p></li><li><p>diskmgmt.msc—磁盘管理实用程序</p></li><li><p>dcomcnfg——-打开系统组件服务</p></li><li><p>ddeshare——-打开DDE共享设置</p></li><li><p>dvdplay——–DVD播放器</p></li><li><p>net stop messenger—–停止信使服务</p></li><li><p>net start messenger—-开始信使服务</p></li><li><p>notepad——–打开记事本</p></li><li><p>nslookup——-网络管理的工具向导</p></li><li><p>ntbackup——-系统备份和还原</p></li><li><p>narrator——-屏幕“讲述人”</p></li><li><p>ntmsmgr.msc—-移动存储管理器</p></li><li><p>ntmsoprq.msc—移动存储管理员操作请求</p></li><li><p>netstat -an—-(TC)命令检查接口</p></li><li><p>syncapp——–创建一个公文包</p></li><li><p>sysedit——–系统配置编辑器</p></li><li><p>sigverif——-文件签名验证程序</p></li><li><p>sndrec32——-录音机</p></li><li><p>shrpubw——–创建共享文件夹</p></li><li><p>secpol.msc—–本地安全策略</p></li><li><p>syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</p></li><li><p>services.msc—本地服务设置</p></li><li><p>Sndvol32——-音量控制程序</p></li><li><p>sfc.exe——–系统文件检查器</p></li><li><p>sfc /scannow—windows文件保护</p></li><li><p>tsshutdn——-60秒倒计时关机命令</p></li><li><p>tourstart——xp简介（安装完成后出现的漫游xp程序）</p></li><li><p>taskmgr——–任务管理器</p></li><li><p>eventvwr——-事件查看器</p></li><li><p>eudcedit——-造字程序</p></li><li><p>explorer——-打开资源管理器</p></li><li><p>packager——-对象包装程序</p></li><li><p>perfmon.msc—-计算机性能监测程序</p></li><li><p>progman——–程序管理器</p></li><li><p>regedit.exe—-注册表</p></li><li><p>rsop.msc——-组策略结果集</p></li><li><p>regedt32——-注册表编辑器</p></li><li><p>rononce -p —-15秒关机</p></li><li><p>regsvr32 /u *.dll—-停止dll文件运行</p></li><li><p>regsvr32 /u zipfldr.dll——取消ZIP支持</p></li><li><p>cmd.exe——–CMD命令提示符</p></li><li><p>chkdsk.exe—–Chkdsk磁盘检查</p></li><li><p>certmgr.msc—-证书管理实用程序</p></li><li><p>calc———–启动计算器</p></li><li><p>charmap——–启动字符映射表</p></li><li><p>cliconfg——-SQL SERVER 客户端网络实用程序</p></li><li><p>Clipbrd——–剪贴板查看器</p></li><li><p>conf———–启动netmeeting</p></li><li><p>compmgmt.msc—计算机管理</p></li><li><p>cleanmgr——-垃圾整理</p></li><li><p>ciadv.msc——索引服务程序</p></li><li><p>osk————打开屏幕键盘</p></li><li><p>odbcad32——-ODBC数据源管理器</p></li><li><p>oobe/msoobe /a—-检查XP是否激活</p></li><li><p>lusrmgr.msc—-本机用户和组</p></li><li><p>logoff———注销命令</p></li><li><p>iexpress——-木马捆绑工具，系统自带</p></li><li><p>Nslookup——-IP地址侦测器</p></li><li><p>fsmgmt.msc—–共享文件夹管理器</p></li><li><p>utilman——–辅助工具管理器</p></li><li><p>系统查看=========systeminfo</p></li><li><p>轻松访问键盘快捷方式<br>　　按住右Shift 八秒钟： 启用和关闭筛选键<br>　　按左 Alt+左 Shift+PrtScn(或 PrtScn)：启用或关闭高对比度<br>　　按左 Alt+左 Shift+Num Lock ：启用或关闭鼠标键<br>　　按 Shift 五次： 启用或关闭粘滞键<br>　　按住 Num Lock 五秒钟：启用或关闭切换键<br>　　Windows 徽标键 + U ： 打开轻松访问中心</p></li><li><p>常规键盘快捷方式<br>　　F1 显示帮助<br>　　Ctrl+C  复制选择的项目<br>　　Ctrl+X  剪切选择的项目<br>　　Ctrl+V  粘贴选择的项目<br>　　Ctrl+Z  撤消操作<br>　　Ctrl+Y  重新执行某项操作<br>　　F2 重命名选定项目<br>　　Ctrl+向右键 将光标移动到下一个字词的起始处<br>　　Ctrl+向左键 将光标移动到上一个字词的起始处<br>　　Ctrl+向下键 将光标移动到下一个段落的起始处<br>　　Ctrl+向上键 将光标移动到上一个段落的起始处<br>　　Ctrl+Shift 加某个箭头键 选择一块文本<br>　　Shift 加任意箭头键 在窗口中或桌面上选择多个项目，或者在文档中选择文本<br>　　Ctrl 加任意箭头键+空格键 选择窗口中或桌面上的多个单个项目<br>　　Ctrl+A 选择文档或窗口中的所有项目<br>　　F3 搜索文件或文件夹<br>　　Alt+Enter 显示所选项的属性<br>　　Alt+F4 关闭活动项目或者退出活动程序<br>　　Alt+空格键 为活动窗口打开快捷方式菜单<br>　　Ctrl+F4 关闭活动文档(在允许同时打开多个文档的程序中)<br>　　Alt+Tab 在打开的项目之间切换<br>　　Ctrl+Alt+Tab 使用箭头键在打开的项目之间切换<br>　　Ctrl+鼠标滚轮 更改桌面上的图标大小<br>　　Windows 徽标键 + Tab 使用 Aero Flip 3-D 循环切换任务栏上的程序<br>　　Ctrl + Windows 徽标键 + Tab 通过 Aero Flip 3-D 使用箭头键循环切换任务栏上的程序<br>　　Alt+Esc 以项目打开的顺序循环切换项目<br>　　F6 在窗口中或桌面上循环切换屏幕元素<br>　　F4 在 Windows 资源管理器中显示地址栏列表<br>　　Shift+F10 显示选定项目的快捷菜单<br>　　Ctrl+Esc 打开「开始」菜单<br>　　Alt+加下划线的字母 显示相应的菜单<br>　　Alt+加下划线的字母 执行菜单命令(或其他有下划线的命令)<br>　　F10 激活活动程序中的菜单栏<br>　　向右键 打开右侧的下一个菜单或者打开子菜单<br>　　向左键 打开左侧的下一个菜单或者关闭子菜单<br>　　F5 刷新活动窗口<br>　　Alt+向上键 在 Windows 资源管理器中查看上一级文件夹<br>　　Esc 取消当前任务<br>　　Ctrl+Shift+Esc 打开任务管理器<br>　　插入 CD 时按住 Shift 阻止 CD 自动播放  </p></li><li><p>对话框键盘快捷方式<br>　　Ctrl+Tab  在选项卡上向前移动<br>　　Ctrl+Shift+Tab  在选项卡上向后移动<br>　　Tab  在选项上向前移动<br>　　Shift+Tab  在选项上向后移动<br>　　Alt+加下划线的字母  执行与该字母匹配的命令(或选择选项)<br>　　Enter  对于许多选定命令代替单击鼠标<br>　　空格键 如果活动选项是复选框，则选中或清除该复选框<br>　　箭头键 如果活动选项是一组选项按钮，则选择某个按钮<br>　　F1 显示帮助<br>　　F4 显示活动列表中的项目<br>　　Backspace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹  </p></li><li><p>Windows 徽标键相关的快捷键<br>　　Windows徽标键就是显示为Windows旗帜，或标有文字Win或Windows的按键，以下简称Win键。XP时代有4个经典的 Win 键组合：R/E/F/L。到了 Win7，花样更多了。<br>　　Win：打开或关闭开始菜单<br>　　Win + Pause：显示系统属性对话框<br>　　Win + D：显示桌面<br>　　Win + M：最小化所有窗口<br>　　Win + SHIFT + M：还原最小化窗口到桌面上<br>　　Win + E：打开我的电脑<br>　　Win + F：搜索文件或文件夹<br>　　Ctrl + Win + F：搜索计算机(如果您在网络上)<br>　　Win + L：锁定您的计算机或切换用户<br>　　Win + R：打开运行对话框<br>　　Win + T：切换任务栏上的程序(感觉是和alt+ESC 一样 )<br>　　Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，新开一个实例。(感觉这个比较新颖，貌似快速启动。) Shift + Windows logo key +number：Start a new instance of the program pinned to the taskbar in the position indicated by the number<br>　　Ctrl + Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，切换到上一次的活动窗口。 Ctrl+Windows logo key +number：Switch to the last active window of the program pinned to the taskbar in the position indicated by the number<br>　　ALT + Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，显示跳转清单。 Alt+Windows logo key +number： Open the Jump List for the program pinned to the taskbar in the position indicated by the number<br>　　Win + TAB：循环切换任务栏上的程序并使用的Aero三维效果<br>　　Ctrl + Win + TAB：使用方向键来循环循环切换任务栏上的程序，并使用的Aero三维效果<br>　　按Ctrl + Win + B：切换到在通知区域中显示信息的程序<br>　　Win + 空格：预览桌面<br>　　Win + ↑：最大化窗口<br>　　Win + ↓：最小化窗口<br>　　Win + ←：最大化到窗口左侧的屏幕上<br>　　Win + →：最大化窗口到右侧的屏幕上<br>　　Win + Home：最小化所有窗口，除了当前激活窗口<br>　　Win+ SHIFT + ↑：拉伸窗口的到屏幕的顶部和底部<br>　　Win+ SHIFT + →/←：移动一个窗口，从一个显示器到另一个<br>　　Win + P：选择一个演示文稿显示模式<br>　　Win + G：循环切换侧边栏的小工具<br>　　Win + U：打开轻松访问中心<br>　　Win + x：打开Windows移动中心  </p></li><li><p>Windows Explorer相关快捷键<br>　　Ctrl+N 打开新窗口<br>　　Ctrl+Shift+N 新建文件夹</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过dotnet命令上传自己的nuget包</title>
      <link href="2018/05/16/tools/nuget/"/>
      <url>2018/05/16/tools/nuget/</url>
      
        <content type="html"><![CDATA[<p>通过dotnet命令上传自己的nuget包</p><a id="more"></a><h5 id="通过dotnet命令上传自己的nuget包"><a href="#通过dotnet命令上传自己的nuget包" class="headerlink" title="通过dotnet命令上传自己的nuget包"></a>通过dotnet命令上传自己的nuget包</h5><ul><li>编辑项目属性 在打包选项中设置各种东西 勾选’在版本中生成Nuget包’、设置其他东西 如包Id、版本等  </li><li>通过vs发布该包 我生成的为:XXG.AutoMapper.AutoReg.1.1.0.nupkg</li><li>执行命令<pre class=" language-bash"><code class="language-bash">dotnet nuget push XXG.AutoMapper.AutoReg.1.1.0.nupkg -k oy2km5lmhmh4lnff32uadp2qudugxwce5jjamrh6xgx4vy -s https://api.nuget.org/v3/index.json</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>office笔记</title>
      <link href="2018/05/16/tools/office/"/>
      <url>2018/05/16/tools/office/</url>
      
        <content type="html"><![CDATA[<p>office笔记-长期更新</p><a id="more"></a><ol><li>=INDIRECT(“Sheet1!C”&amp;ROW())&amp;””，引用下拉框，自动行号   </li><li>字符串拼接：=$A1&amp;$B1，表示：输出A1和B1单元格的内容  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx笔记</title>
      <link href="2018/05/16/tools/nginx/"/>
      <url>2018/05/16/tools/nginx/</url>
      
        <content type="html"><![CDATA[<p>linux安装nginx</p><a id="more"></a><ol><li>nginx官网<a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7</a></li><li>命令<br>启动:sudo nginx<br>重启:sudo nginx -s reload<br>关闭:sudo nginx -s stop  </li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm前端项目</title>
      <link href="2018/05/16/tools/npm/"/>
      <url>2018/05/16/tools/npm/</url>
      
        <content type="html"><![CDATA[<p>npm相关前端操作</p><a id="more"></a><h5 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h5><p>调试本地的包  </p><ol><li>cd 到包的文件夹下 将当前包link到全局<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">link</span></code></pre></li><li>cd 到项目文件夹 将要使用的包link过来 命令如下<pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">link</span> <span class="token punctuation">[</span>package name<span class="token punctuation">]</span></code></pre>示例：<blockquote><p>包名称 xxg-uim-plugin-locale、项目名称 xxg-admin<br>先在 xxg-uim-plugin-locale文件夹下将当前包link到全局，执行 :npm link<br>在定位到xxg-admin项目下，执行: npm link xxg-umi-plugin-locale<br>这样 如果通过yarn add xxg-umi-plugin-locale 安装包的时候会link到本地而不会从npm下载 这样方便本地开发调试</p></blockquote></li></ol><h5 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h5><p>续待更新…</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发中能提高工作效率的工具收集</title>
      <link href="2018/05/16/tools/develop/"/>
      <url>2018/05/16/tools/develop/</url>
      
        <content type="html"><![CDATA[<p>开发工具收藏夹</p><a id="more"></a><h5 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h5><ul><li>sql对比工具：DiffUse  </li><li>BCompare 文件对比  </li><li>ORC 图片文本识别   </li></ul><h5 id="VS插件"><a href="#VS插件" class="headerlink" title="VS插件"></a>VS插件</h5><ul><li>Web Essentials  </li><li>web Extension Pack  </li><li>Productivity Power Tools 2015:方法开始结束标线  </li><li><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">PicGo vscode的图床管理</a>、<a href="http://picgo.github.io/">github</a></li><li>Settings Sync vscode 同步插件</li></ul><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><ul><li>编辑器神器：webstrom、SubLime node  </li><li>压缩合并混合：grunt、webpack</li><li>依赖管理工具：bower、npm、cnpm、yarn</li><li>轻量级服务器：httpserver  </li><li>单元测试：karma 、jasmine  </li><li>karma是容器，jasmine是语法  </li><li>angularJS专用测试工具：protractor  </li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>Emmet：提供自动完成某些文档  </li><li>DocBlockr　　DocBlockr可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++  </li></ul><h5 id="测试、分析工具"><a href="#测试、分析工具" class="headerlink" title="测试、分析工具"></a>测试、分析工具</h5><ul><li>压力测试:Load Runner  </li><li>服务器IIS分析:Visual Studio Profiler、WinDebug、opserver  </li></ul><h5 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h5><p>toad for mysql</p><blockquote><p>欢迎补充</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令(笔记)</title>
      <link href="2018/05/16/tools/git/"/>
      <url>2018/05/16/tools/git/</url>
      
        <content type="html"><![CDATA[<p>常用git命令</p><a id="more"></a><ol><li>创建一个版本库<br>mkdir repository    //创建一个文件夹<br>git init [name]       //把目录编程git可以管理的仓库,[name]可选  </li><li>提交文件到版本库<br>git add test.txt    //添加文件到版本库,此时还没有提交到git<br>git commit -m “提交注释”    //告诉Git，把文件提交到仓库  </li><li>远程<br>查看当前git的状态:        git status<br>查看修改变的内容:        git diff<br>查看历史记录:                git log<br>查看修改的headid：       git reflog<br>查看分支：    git branch [-a|-r]    //-a 所有分支，-r:远程分支<br>查看远程库信息   :            git remote<br>查看远程库详细信息:        git remote -v<br>查看远程仓库：$ git remote -v<br>添加远程仓库：$ git remote add [name] [url]<br>克隆远程仓库：git checkout [branchName] origin/[branchName] //如果远程分支有branchName而本地没<br>git checkout -b [branchName] origin/[branchName] //如果远程分支有本地无，克隆并切换到<br>删除本地仓库: git branch -d [branch-name]<br>强制删除本地分支  git branch -D [branch-name]<br>删除远程仓库：$ git push origin :[branch-name] //删除远程分支  <pre><code>     git remote rm [branch-name]       git push origin --delete [branchName]    </code></pre>修改远程仓库：$ git remote set-url –push [name] [newUrl]<br>拉取远程仓库：$ git pull origin [remoteName]:[localBranchName]  <pre><code>                     git fetch origin [remoteName]:[localBranchName]    //获取到当前分支  </code></pre>推送远程仓库：$ git push origin [remoteName]:[localBranchName]        //如果有冲突，需要先pull或者fetch远程的<br>git push origin [remoteName]:[localBranchName] -f    //强推，使用本地覆盖服务器的  </li><li>与远程git关联<br>a、在git上创建一个Repository<br>b、在本地执行命令：git remote add origin <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#109;</a>:xiexingen/learngit.git    //将本地仓库与远程关联<br>c、重新关联：git remote set-url origin git://git.coding.net/xxxx/yyyy.git  </li><li>从远程下载到本地<br>git clone [地址] [文件夹名称]    //将远程项目复制到本地之地文件加下  </li><li>分支<br>创建分支：git branch [branch Name]<br>切换分支：git checkout [branch Name]<br>创建+切换分支：git checkout -b [branch Name]<br>合并分支到当前分支：git merge [branch Name]<br>重命名分支：    git branch -m [new_branchName] [old_branchName]<br>查看所有分支：git branch -a<br>从指定分支创建并切换到分支:git checkout -b [local-branchName] [origin/branchName]<br>删除分支:    git branch [-d|-D] [local-branch] //-d 只能删除已经参与合并的分支,-D:可以删除为合并的分支，然后在git push origin :master 可以删除远程分支<br>git merge命令用于合并指定分支到当前分支,注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交<br>git merge dev :分两种情况一种是直接指向，另一种是生成另外一个将两个合并<br>git merge –no-ff -m’comment’ [branch Name]    //合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并<br>git merge –abort //取消合并  </li><li>Bug分支<br>git stash        //相当于tfs中的搁置<br>git stash apply    //取消搁置到本地<br>git stash drp     //删除搁置集<br>git stash pop        //取消搁置到本地并删除搁置集<br>git stash list    //查看搁置集<br>git stash apply stash@{0}    //恢复指定的搁置集  </li><li>多人协作<br>A、git push -u origin [local-branch][:remote-branch]    //吧本地库推送到远程库上，-u，不但回吧本地的分支推送到远程新的master分支，还会把本地分支和远程分支关联起来，在以后的推送或者拉去时就可以简化命名<br>后面如果有修改的话，只需要执行：git push origin [local-branch]    //吧本地分支的最新修改推送到服务器<br>B、从本地推送分支，使用git push origin [local_branch]:[remote-branch]，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>c、建立本地分支和远程分支的关联，使用git branch –set-upstream [local-branch] [origin/remote-branch]<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。<br>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name</li><li>取消、回滚<br>git -reflog 查看历史版本<br>git reset –hard HEAD^    //回到上一次改动 (针对历史提交)<br>git reset -hard 3628164    //3628164 headid 恢复到指定的记录(针对历史提交)<br>git reset test.js //使用当前历史提交还原工作区<br>git checkout – test.js    //使用暂存区覆盖改动  </li><li>clean<br>git clean -n //将当前非暂存区的文件移除<br>git clean -f //强制移除  </li><li>版本(tag)操作相关命令<br>查看版本：$ git tag<br>创建版本：$ git tag [name]<br>删除版本：$ git tag -d [name]<br>查看远程版本：$ git tag -r<br>创建远程版本(本地版本push到远程)：$ git push origin [name]<br>删除远程版本：$ git push origin :refs/tags/[name]<br>合并远程仓库的tag到本地：$ git pull origin –tags<br>上传本地tag到远程仓库：$ git push origin –tags<br>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’  </li><li>忽略一些文件、文件夹不提交<br>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin  </li></ol><p>*.db<br>13. 生成密钥  </p><ul><li>查看是否已经有了ssh密钥：cd ~/.ssh  <blockquote><p>如果提示：No such file or directory 说明你是第一次使用git<br>如果不是第一次使用，请执行下面的操作,清理原有ssh密钥。<br>$ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa*<br>生成新的密钥：<br>$ ssh-keygen -t rsa -C “<a href="mailto:&#49;&#x30;&#x30;&#50;&#x32;&#x37;&#53;&#51;&#54;&#x34;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#x30;&#x30;&#50;&#x32;&#x37;&#53;&#51;&#54;&#x34;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>”  </p></blockquote></li></ul><ol start="14"><li>添加忽略文件<br>git rm -f –cached [path] 移除单个文件，path表示全路径<br>git rm -f –cached [path] -r 移除目录，path表示目录  </li><li>从暂存区移除文件<br>git rm –cached [file] //将file从暂存区移除  </li><li>tag<br>git tag -a v1.0 -m ‘version 1.0’<br>git tag 列出已有标签<br>git tag -l ‘v1.0’ //列出指定标签<br>git checkout -b [branchName] [tagname] //在特定的标签上创建一个新分支<br>git tag v0.9 [626262] //给上次提价的commit id为626262打上标签<br>git push origin [v1.0] //将标签v1.0push到远程<br>git push origin –tags //将本地的所有tag push到远程<br>git push origin :refs/tags/[v1.0] //删除v1.0  </li><li>.gitignore文件无效的解决方法<br>git rm -r –cached [指定文件]<br>提交</li></ol><h5 id="配置git使用BCompare来比对文件-用户目录-gitconfig里面"><a href="#配置git使用BCompare来比对文件-用户目录-gitconfig里面" class="headerlink" title="配置git使用BCompare来比对文件(用户目录.gitconfig里面)"></a>配置git使用BCompare来比对文件(用户目录.gitconfig里面)</h5><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>user<span class="token punctuation">]</span>name <span class="token operator">=</span> xiexingenemail <span class="token operator">=</span> 1002275364@qq.com<span class="token punctuation">[</span>diff<span class="token punctuation">]</span>    tool <span class="token operator">=</span> bc4<span class="token punctuation">[</span>difftool<span class="token punctuation">]</span>    prompt <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">[</span>difftool <span class="token string">"bc4"</span><span class="token punctuation">]</span>    cmd <span class="token operator">=</span> \<span class="token string">"D:/Program Files/Beyond Compare 4/BComp.exe\" \"<span class="token variable">$LOCAL</span>\" \"<span class="token variable">$REMOTE</span>\"[merge]    tool = bc4[mergetool]    prompt = false    keepBackup = false[mergetool "</span>bc4"<span class="token punctuation">]</span>    cmd <span class="token operator">=</span> \"D:/Program Files/Beyond Compare 4/BComp.exe\" \"<span class="token variable">$LOCAL</span>\" \"<span class="token variable">$REMOTE</span>\" \"<span class="token variable">$BASE</span>\" \"<span class="token variable">$MERGED</span>\"    trustExitCode <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">[</span>alias<span class="token punctuation">]</span>    dt <span class="token operator">=</span> difftool    mt <span class="token operator">=</span> mergetool</code></pre><p>使用：<br>git difftool ‘文件1’ ‘文件2’<br>git mergetool  </p><ul><li><p>全局配置用户名</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name xiexingen<span class="token function">git</span> config --global user.email 1002275364@qq.com<span class="token function">git</span> config --global alias.co checkout  //用co代替checkout</code></pre><p>日志  </p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> log –graph –pretty<span class="token operator">=</span>format:’%Cred%h%Creset -%C<span class="token punctuation">(</span>yellow<span class="token punctuation">)</span>%d%Creset %s %Cgreen<span class="token punctuation">(</span>%cr<span class="token punctuation">)</span> %C<span class="token punctuation">(</span>bold blue<span class="token punctuation">)</span><span class="token operator">&lt;</span>%an<span class="token operator">></span>%Creset’ –abbrev-commit –date<span class="token operator">=</span>relative **</code></pre></li><li><p>https带用户名密码形式迁出代码<br>git clone http://用户名:密码@gitlab.xxgtalk.cn/WT/StudyNetCore.git    </p></li><li><p>github上游合并问题</p><pre class=" language-js"><code class="language-js">首先指定上游地址：git remote add upstream <span class="token punctuation">[</span>original repo url<span class="token punctuation">]</span>拉取上游代码<span class="token punctuation">:</span>git fetch upstream合并代码<span class="token punctuation">:</span>git merge upstream<span class="token operator">/</span>master</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openssl生成免费证书</title>
      <link href="2018/05/16/tools/cer/"/>
      <url>2018/05/16/tools/cer/</url>
      
        <content type="html"><![CDATA[<p>使用Openssl生成免费证书</p><a id="more"></a><blockquote><p>官网地址 openssl的windows官网: <a href="https://slproweb.com/products/Win32OpenSSL.html">https://slproweb.com/products/Win32OpenSSL.html</a>  </p></blockquote><ol><li>下载安装</li><li>在自己目录下运行 <pre class=" language-bash"><code class="language-bash">openssl req -newkey rsa:2048 -nodes -keyout socialnetwork.key -x509 -days 365 -out socialnetwork.cer</code></pre></li><li>生成pfx文件命令<pre class=" language-bash"><code class="language-bash">openssl pkcs12 -export -in socialnetwork.cer -inkey socialnetwork.key -out socialnetwork.pfx</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IdentityServer4-使用密码授权模式</title>
      <link href="2018/03/11/dotnetcore/identityserver4/02passport/"/>
      <url>2018/03/11/dotnetcore/identityserver4/02passport/</url>
      
        <content type="html"><![CDATA[<p>IdentityServer4-使用密码授权模式</p><a id="more"></a><h5 id="一、IdentityServer-也叫服务端"><a href="#一、IdentityServer-也叫服务端" class="headerlink" title="一、IdentityServer 也叫服务端"></a>一、IdentityServer 也叫服务端</h5><ol><li>新建.netcore web项目 设置启动端口为60000 并通过Nuget引用IdentityServer4</li><li>添加ApiResource和Client(此处方便测试固定了一些数据)<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/1-0201.png"></li><li>使用IdentityServer<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/1-0301.png"><br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/1-0302.png"></li><li>启动项目 <a href="http://localhost:60000/.well-known/openid-configuration">http://localhost:60000/.well-known/openid-configuration</a> 可以看到相关json数据<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/1-0401.png"><h5 id="二、Api端-与clientCredentials模式完全一致"><a href="#二、Api端-与clientCredentials模式完全一致" class="headerlink" title="二、Api端 (与clientCredentials模式完全一致)"></a>二、Api端 (与clientCredentials模式完全一致)</h5></li><li>新建.netcore web项目 设置启动端口为60001<br>通过Nuget引用IdentityServer4.AccessTokenValidation 此处只需要验证所以不需要引用IdentityServer4</li><li>配置<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/2-0201.png"></li><li>在controller上贴上属性[Authorize] 表示只允许登录用户访问</li><li>通过postman获取token(注意请求body中的参数)<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/2-0401.png"></li><li>请求需要登录的api 此处为api/values<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/2-0501.png"><h5 id="三、client-客户端也叫ThirPart【选修】"><a href="#三、client-客户端也叫ThirPart【选修】" class="headerlink" title="三、client 客户端也叫ThirPart【选修】"></a>三、client 客户端也叫ThirPart【选修】</h5><blockquote><p>定义一个控制台程序 访问api获取数据</p></blockquote></li><li>创建.net core控制台程序 通过Nuget引用包IdentityModel<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/02/3-0101.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> IdentityServer4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IdentityServer4-ClientCredentials模式</title>
      <link href="2018/03/10/dotnetcore/identityserver4/01client-credentials/"/>
      <url>2018/03/10/dotnetcore/identityserver4/01client-credentials/</url>
      
        <content type="html"><![CDATA[<p>IdentityServer4-ClientCredentials模式</p><a id="more"></a><h5 id="一、IdentityServer端-也叫服务端"><a href="#一、IdentityServer端-也叫服务端" class="headerlink" title="一、IdentityServer端 也叫服务端"></a>一、IdentityServer端 也叫服务端</h5><ol><li><p>新建.netcore web项目 设置启动端口为60000 并通过Nuget引用IdentityServer4</p></li><li><p>添加ApiResource和Client(此处方便测试固定了一些数据)</p><pre class=" language-cs"><code class="language-cs">using IdentityServer4.Models;using System.Collections.Generic;namespace Api&#123;    public class Config    &#123;        public static IEnumerable<ApiResource> GetResources()        &#123;            return new List<ApiResource>()            &#123;                new ApiResource("api","My Api")            &#125;;        &#125;        public static IEnumerable<Client> GetClients()        &#123;            return new List<Client>()            &#123;                new Client()&#123;                    ClientId="client",                    AllowedGrantTypes=GrantTypes.ClientCredentials,                    ClientSecrets=&#123;                        new Secret("secret".Sha256())                    &#125;,                    AllowedScopes=&#123;"api"&#125;                &#125;            &#125;;        &#125;    &#125;&#125;</code></pre></li><li><p>使用IdentityServe4</p><pre class=" language-cs"><code class="language-cs">public void ConfigureServices(IServiceCollection services)&#123;    services.AddIdentityServer()        .AddDeveloperSigningCredential()        .AddInMemoryApiResources(Config.GetResources())        .AddInMemoryClients(Config.GetClients());&#125;public void Configure(IApplicationBuilder app,IHostingEnvironment env)&#123;    if (env.IsDevelopment())    &#123;        app.UseDeveloperExceptionPage();    &#125;    app.UseIdentityServer();&#125;</code></pre></li><li><p>启动项目 <a href="http://localhost:60000/.well-known/openid-configuration">http://localhost:60000/.well-known/openid-configuration</a> 可以看到相关json数据<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/01/1-0401.png" alt="json"></p></li></ol><h4 id="二、Api端"><a href="#二、Api端" class="headerlink" title="二、Api端"></a>二、Api端</h4><ol><li><p>新建.netcore web项目 设置启动端口为60001<br>通过Nuget引用IdentityServer4.AccessTokenValidation 此处只需要验证所以不需要引用IdentityServer4</p></li><li><p>配置StartUp</p><pre class=" language-cs"><code class="language-cs">using Microsoft.AspNetCore.Builder;using Microsoft.AspNetCore.Hosting;using Microsoft.Extensions.Configuration;using Microsoft.Extensions.DependencyInjection;namespace Api&#123;    public class Startup    &#123;        public Startup(IConfiguration configuration)        &#123;            Configuration = configuration;        &#125;        public IConfiguration Configuration &#123; get; &#125;        // This method gets called by the runtime. Use this method to add services to the container.        public void ConfigureServices(IServiceCollection services)        &#123;            services.AddAuthentication("Bearer")                .AddIdentityServerAuthentication(options =>                &#123;                    options.Authority = "http://localhost:60001";//设置认证服务器地址                    options.RequireHttpsMetadata = false;//不需要https                    options.ApiName = "api";//api resource的名字 对应定义的ApiResource中的name                &#125;);            services.AddMvc();        &#125;        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.        public void Configure(IApplicationBuilder app, IHostingEnvironment env)        &#123;            if (env.IsDevelopment())            &#123;                app.UseDeveloperExceptionPage();            &#125;            app.UseAuthentication();            app.UseMvc();        &#125;    &#125;&#125;</code></pre></li><li><p>在controller上贴上属性[Authorize] 表示只允许登录用户访问</p></li><li><p>通过postman获取token(注意请求body中的参数)<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/01/2-0401.png" alt="json"></p></li><li><p>请求需要登录的api 此处为api/values<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/identityserver4/01/2-0501.png" alt="json"></p></li></ol><h4 id="三、client-客户端也叫ThirPart【选修】"><a href="#三、client-客户端也叫ThirPart【选修】" class="headerlink" title="三、client 客户端也叫ThirPart【选修】"></a>三、client 客户端也叫ThirPart【选修】</h4><p>定义一个控制台程序 访问api获取数据</p><ol><li><p>创建.net core控制台程序 通过Nuget引用包IdentityModel</p><pre class=" language-cs"><code class="language-cs">using IdentityModel.Client;using System;using System.Net.Http;namespace Client&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            var diso = DiscoveryClient.GetAsync("http://localhost:60000").Result;            if (diso.IsError)            &#123;                Console.WriteLine(diso.Error);            &#125;            var tokenClient = new TokenClient(diso.TokenEndpoint, "client", "secret");            var tokenResponse = tokenClient.RequestClientCredentialsAsync("api").Result;            if (tokenResponse.IsError)            &#123;                Console.WriteLine(tokenResponse.Error);            &#125;            else &#123;                Console.WriteLine(tokenResponse.Json);            &#125;            var httpClient= new HttpClient();            httpClient.SetBearerToken(tokenResponse.AccessToken);            var response = httpClient.GetAsync("http://localhost:60001/api/values").Result;            if (response.IsSuccessStatusCode)            &#123;                Console.WriteLine(response.Content.ReadAsStringAsync().Result);            &#125;</code></pre></li></ol><pre><code>            Console.ReadKey();        &#125;    &#125;&#125;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> IdentityServer4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IdentityServer4 资料收集</title>
      <link href="2018/03/09/dotnetcore/identityserver4/article/"/>
      <url>2018/03/09/dotnetcore/identityserver4/article/</url>
      
        <content type="html"><![CDATA[<p>IdentityServer4 资料收集</p><a id="more"></a><ul><li><p>IdentityServer4  endPoint查看地址：<a href="http://localhost:5000/.well-known/openId-configuration">http://localhost:5000/.well-known/openId-configuration</a></p></li><li><p>博客推荐 <a href="http://www.cnblogs.com/stulzq/p/8119928.html">http://www.cnblogs.com/stulzq/p/8119928.html</a></p></li><li><p>八幅漫画理解使用JSON Web Token设计单点登录系统<br><a href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/">http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/</a></p></li><li><p>JSON Web Token - 在Web应用间安全地传递信息<br><a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/">http://blog.leapoahead.com/2015/09/06/understanding-jwt/</a></p></li><li><p>纯OAuth2 授权码模式的实现 。 (不包含OICD）<br><a href="https://github.com/bayardw/IdentityServer4.Authorization.Code">https://github.com/bayardw/IdentityServer4.Authorization.Code</a></p></li><li><p>YAML语法介绍：<br><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
            <tag> IdentityServer4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于JWT的认证模式</title>
      <link href="2018/03/06/dotnetcore/core/03jwt-authorization/"/>
      <url>2018/03/06/dotnetcore/core/03jwt-authorization/</url>
      
        <content type="html"><![CDATA[<p>基于JWT的认证模式</p><a id="more"></a><p><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0001.png"></p><ol><li>在项目目录下定义一个JwtSetting实体类<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0101.png"></li><li>在appsettings.json中配置值<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0201.png"></li><li>在StartUp中设置验证方式<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0301.png"></li><li>在管道中加入认证<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0401.png"></li><li>登录<br>JwtSecurityToken 需要添加包Microsoft.AspNetCore.Authentication.JwtBearer<br>using Microsoft.IdentityModel.Tokens;<br>using System.IdentityModel.Tokens.Jwt;<br>using System.Security.Claims;<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0501.png">  </li><li>通过postman模拟登录获取token<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0601.png"></li><li>将token以请求头形式放到请求中发送请求<br>[注] 键:Authorization      token值记得加”bearer “<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/0701.png"> </li></ol><hr><p>扩展  </p><ol><li>使用自定义验证以及自定义头部token<br>定义MyTokenValidation 实现接口ISecurityTokenValidator<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/e0101.png"> </li><li>在ConfigureServices方法中<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/e0201.png"> </li><li>运行效果<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/03/e0301.png"> </li></ol>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于CookieBase认证的模式</title>
      <link href="2018/03/05/dotnetcore/core/02cookie-base-authorization/"/>
      <url>2018/03/05/dotnetcore/core/02cookie-base-authorization/</url>
      
        <content type="html"><![CDATA[<p>基于CookieBase认证的模式</p><a id="more"></a><blockquote><p>说明 通过vs2017新建的.net core项目默认没有添加身份认证与授权以及路由等  </p></blockquote><ol><li>在StartUp.ConfigureServices中addMvc之前添加AddAuthentication<br>using Microsoft.AspNetCore.Authentication.Cookies;<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/02/0101.png"></li><li>在Configure方法中<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/02/0201.png"></li><li>模拟登陆<br>using Microsoft.AspNetCore.Authentication;<br>using Microsoft.AspNetCore.Authentication.Cookies;<br>using System.Security.Claims;<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/02/0301.png"></li><li>在对应的Controller或者Action中贴上属性[Authorize]  </li></ol>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NetCore+centos环境搭建手摸手实战</title>
      <link href="2018/03/03/dotnetcore/core/01dotnetcore-centos-install/"/>
      <url>2018/03/03/dotnetcore/core/01dotnetcore-centos-install/</url>
      
        <content type="html"><![CDATA[<p>.NetCore+centos环境搭建手摸手实战</p><a id="more"></a><ol><li>安装VMware Workstation<br>下载地址:<a href="https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0">https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0</a>  下载安装 </li><li>安装CentOS7<br>安装好后发现不能使用网络 参考资料<br><a href="http://blog.csdn.net/wanz2/article/details/52820876">http://blog.csdn.net/wanz2/article/details/52820876</a></li><li>安装.net core<br>参考官网步骤:<a href="https://www.microsoft.com/net/learn/get-started/linuxcentos">https://www.microsoft.com/net/learn/get-started/linuxcentos</a></li><li>安装nginx<br>同样参考官网步骤:<a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7</a></li><li>vs2017新建项目发布成本地文件夹<br>新建项目，使用mvc模板发布到本地文件夹</li><li>通过Xftp上传到centos<br>通过Xftp将打包的文件直接粘贴到centos中(我是在root目录下建了个web文件夹专门用于存放部署的站点)<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0601.png"></li><li>将dotnetcore站点运行起来<br>在Xftp中点击新建终端打开XsHell 将路径定位到站点文件夹 cd /root/web/mvc  执行 dotnet HelloWord.dll  看到如下信息 表示你已经成功了<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0701.png"><br>这个时候你在外面访问是访问不了的 因为防火墙没有启用5000端口<br>如果一定想看看 可以再开一个终端 输入如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0702.png"></li><li>配置nginx将80端口指向dotnetcore站点<br>这一步就是通过nginx将80请求转到上面的localhost:5000<br>先找着nginx中的配置<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0801.png"><br>打开后会发现里面有个<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0802.png"><br>在如下目录中新建一个文件 输入配置   <pre class=" language-nginx"><code class="language-nginx">    <span class="token keyword">server</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>        <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>        <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;</span>            <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">5000</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> Connection keep<span class="token operator">-</span>alive<span class="token punctuation">;</span>            <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>            <span class="token keyword">proxy_cache_bypass</span> <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span>    <span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#125;</span></code></pre> <img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0803.png"><br>然后重启nginx ==》sudo nginx -s reload  </li><li>查看成果<br>在浏览器中输入192.168.2.105  如图<br><img src="http://qiniu.xxgtalk.cn/blog/images/dotnetcore/core/01/0901.png"></li></ol><blockquote><p>总结:<br>过程中遇到一些问题，比如虚拟机中的centos系统中使用不了网络 这个折腾了劳资一个上午(如有碰到，第2点中有参考资料)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EFCore相关资料</title>
      <link href="2018/03/01/dotnetcore/core/efcore/"/>
      <url>2018/03/01/dotnetcore/core/efcore/</url>
      
        <content type="html"><![CDATA[<p>EFCore相关资料</p><a id="more"></a><ol><li>命令行<br>CMD形式 | VS中Package Manager形式</li></ol><p>—- | —<br>dotnet ef migrations add InitCreate    [-o 路径] | Add-Migration InitCreate<br>dotnet ef database update   | Update-Database<br>dotnet ef migrations remove | Remove-Migrations<br>donet ef database update [LastGoodMigration] | Update-Database LastGoodMigration<br>dotnet ef migrations script [-o 路径] | Script-Migration</p><blockquote><p>生成 migrationName1 到 -migrationName2的脚本<br>dotnet ef migrations script migrationName1 migrationName2<br>不能使用dotnet ef命令行解决方式 在项目文件csproj文件中添加  </p></blockquote><pre><code>&lt;DotNetCliToolReference Include=&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot; Version=&quot;2.0.1&quot; /&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DotNetCore 备忘录</title>
      <link href="2018/03/01/dotnetcore/core/remark/"/>
      <url>2018/03/01/dotnetcore/core/remark/</url>
      
        <content type="html"><![CDATA[<p>DotNetCore 备忘录</p><a id="more"></a><h5 id="常用备忘录"><a href="#常用备忘录" class="headerlink" title="常用备忘录"></a>常用备忘录</h5><blockquote><p>docker run -d -p 8081:80 –name wechat -v /docker/wechat/App_Data/:/app/App_Data/ –restart always registry.cn-hangzhou.aliyuncs.com/xxg/wechat:v1.1.5 </p></blockquote><ol><li><p>使用dotnet watch 在项目项目文件夹中添加(自.netcore2.1.0开始已经集成进去 不需要手动添加)     </p><pre class=" language-c#"><code class="language-c#"><ItemGroup> <DotNetCliToolReference Include="Microsoft.DotNet.Watcher.Tools" Version="2.0.0" /></ItemGroup>   <!-- 使用dotnet ef ... --><ItemGroup><DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet" Version="2.0.1" /></ItemGroup>   </code></pre></li><li><p>测试框架<br>Moq<br>fluentassertions</p></li><li><p>查看nuget目录<br>通过dotnet dotnet nuget locals all –list  </p></li><li><p>JSON解析不适用首字母小写形式(默认会首字母小写)<br>在ConfigureServices中配置</p><pre class=" language-c#"><code class="language-c#">services.AddMvc()    .AddJsonOptions(options =>    &#123;        if (options.SerializerSettings.ContractResolver is DefaultContractResolver resolver)        &#123;            resolver.NamingStrategy = null;        &#125;    &#125;);</code></pre></li><li><p>添加输出响应内容xml格式<br>.net core中默认只返回json格式需要xml的话需要修改Output formatter</p><pre class=" language-c#"><code class="language-c#">services.AddMvc()    .AddMvcOptions(options=> &#123;        options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter());    &#125;)</code></pre></li><li><p>全局异常  </p></li></ol><ul><li><p>[6.1] 往MVC Filters中添加过滤器<br>添加一个全局异常类继承ExceptionFilterAttribute</p><pre class=" language-c#"><code class="language-c#">public class GlobalExceptionFilter : IExceptionFilter&#123;    private readonly IHostingEnvironment _hostingEnvironment;    private readonly ILogger<GlobalExceptionFilter> _logger;    public GlobalExceptionFilter(        IHostingEnvironment hostingEnvironment,        IModelMetadataProvider modelMetadataProvider,        ILogger<GlobalExceptionFilter> logger)    &#123;        _hostingEnvironment = hostingEnvironment;        _logger = logger;    &#125;</code></pre></li></ul><pre><code>    public void OnException(ExceptionContext context)    &#123;        HttpStatusCode status = HttpStatusCode.InternalServerError;        String message = String.Empty;        var exceptionType = context.Exception.GetType();        if (exceptionType == typeof(UnauthorizedAccessException))        &#123;            message = &quot;Unauthorized Access&quot;;            status = HttpStatusCode.Unauthorized;        &#125;        else if (exceptionType == typeof(NotImplementedException))        &#123;            message = &quot;A server error occurred.&quot;;            status = HttpStatusCode.NotImplemented;        &#125;        else if (exceptionType == typeof(BusinessException))        &#123;            message = context.Exception.ToString();            status = HttpStatusCode.InternalServerError;        &#125;        else        &#123;            message = context.Exception.Message;            status = HttpStatusCode.NotFound;        &#125;        context.ExceptionHandled = true;        HttpResponse response = context.HttpContext.Response;        response.StatusCode = (int)status;        response.ContentType = &quot;application/json&quot;;        var ar = new AjaxResponse()        &#123;            Success = false,            Message = message,            Data = context.Exception        &#125;;        response.WriteAsync(JsonConvert.SerializeObject(ar));        //context.Result = new JsonNetResult(new AjaxResponse() &#123;        //    Success=false,        //    Message=context.Exception.Message,        //    Data=context.Exception        //&#125;);    &#125;&#125;```</code></pre><p>在ConfigureServices方法AddMvc中<br>    <code>c#      services.AddMvc(config=&gt; &#123;         config.Filters.Add(typeof(GlobalExceptionFilter));     &#125;)    </code></p><ul><li>[6.2] 在Configure方法中添加异常处理管道(注意在所有请求管道的最前面)<pre><code>app.UseExceptionHandler(options =&gt;&#123;    options.Run(async context =&gt;    &#123;        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;        context.Response.ContentType = &quot;application/json&quot;;        var ex = context.Features.Get&lt;IExceptionHandlerFeature&gt;();        if (ex != null)        &#123;            var response = new AjaxResponse()            &#123;                Success = false,                Message = ex.Error.Message,                Data = ex.Error            &#125;;            await context.Response.WriteAsync(JsonConvert.SerializeObject(response)).ConfigureAwait(false);        &#125;    &#125;);&#125;);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetCore相关框架收集</title>
      <link href="2018/02/27/dotnetcore/core/collections/"/>
      <url>2018/02/27/dotnetcore/core/collections/</url>
      
        <content type="html"><![CDATA[<p>.NetCore相关框架收集</p><a id="more"></a><p>.net core的 开源项目地址 <a href="https://github.com/dotnet/corefx">https://github.com/dotnet/corefx</a> </p><p>asp.net core 框架的地址 <a href="https://github.com/aspnet">https://github.com/aspnet</a></p><p>EF Core源码 <a href="https://github.com/aspnet/EntityFrameworkCore">https://github.com/aspnet/EntityFrameworkCore</a></p><p>配置模块源码 <a href="https://github.com/aspnet/Configuration">https://github.com/aspnet/Configuration</a> </p><p>路由模块 <a href="https://github.com/aspnet/Routing">https://github.com/aspnet/Routing</a></p><p>认证及授权  <a href="https://github.com/aspnet/Security">https://github.com/aspnet/Security</a></p><p>依赖注入 <a href="https://github.com/aspnet/DependencyInjection">https://github.com/aspnet/DependencyInjection</a></p><p> 这个一定要看，有很多的一些HTTP管道的抽象接口都定义在这里 <a href="https://github.com/aspnet/HttpAbstractions">https://github.com/aspnet/HttpAbstractions</a> </p><p><a href="https://github.com/aspnet/Options">https://github.com/aspnet/Options</a></p><p><a href="https://github.com/aspnet/Mvc">https://github.com/aspnet/Mvc</a> </p><p><a href="https://github.com/aspnet/Hosting">https://github.com/aspnet/Hosting</a></p>]]></content>
      
      
      <categories>
          
          <category> .NetCore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NetCore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开通自己的博客</title>
      <link href="2016/04/01/helleword/"/>
      <url>2016/04/01/helleword/</url>
      
        <content type="html"><![CDATA[<p>从hexo切换到vuepress又切回hexo啦！！！</p><a id="more"></a><p>::: tip 大家好<br>我是谢新根，网名:<code>程序有Bug</code> 性别:男 爱好:代码、生活、自行车、羽毛球 性格:沉稳而不活泼、内敛而不明骚、随和而不暴力、帅气中带点闷骚,好啦好啦 第一天开通自己的博客，到此为止吧<br>:::</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
