{"meta":{"title":"程序有Bug技术栈","subtitle":"代码让世界更美好","description":"专注于.NET CORE、大前端技术栈、爬虫、微信体系、客户端应用","author":"谢新根","url":"http://blog.xxgtalk.cn","root":"/"},"pages":[{"title":"关于我","date":"2018-08-14T21:44:14.000Z","updated":"2020-12-25T13:56:07.175Z","comments":false,"path":"about/index.html","permalink":"http://blog.xxgtalk.cn/about/index.html","excerpt":"","text":"个人信息姓名: 谢新根昵称: 程序有Bug （英名:XXG）地址：目前浪迹于大长沙QQ: 1002275364自我描述: 爱代码爱生活 技术星级 技术点 星级 .NET、.NETCore、js、SqlServer Dapper、EF、PetaPoco Signalr、ABP、DDD、Redis、RabbitMQ、IdentityServer CAP、Consul、Ocelot、微服务、Polly、OChars、微信公众号、微信小程序 React、Antd、Vue、ElementUI、TypeScript、Webpack、umi、dva、taro Docker、CICD、GitLab、Linux 第三方支付、第三方登录、快递接口、短信接口、web快递单打印、条码打印、导出excel,word,pdf等常用第三的东西 puppeteer、electronjs、egg、谷歌浏览器插件等一些好玩的 做过的系统 临床试验平台 跨境电商物流系统 外贸ERP 其他(懒得写了) 个人链接 个人博客、之前的博客 个人Github、公司Github demo –(服务器比较弱) 其他"},{"title":"所有分类","date":"2018-08-14T21:42:41.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"categories/index.html","permalink":"http://blog.xxgtalk.cn/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2018-08-14T09:28:57.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"tags/index.html","permalink":"http://blog.xxgtalk.cn/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-21T09:16:30.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"friends/index.html","permalink":"http://blog.xxgtalk.cn/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx开篇","slug":"nginx/01-introduct","date":"2019-11-30T01:10:10.000Z","updated":"2020-12-25T13:02:18.694Z","comments":true,"path":"2019/11/30/nginx/01-introduct/","link":"","permalink":"http://blog.xxgtalk.cn/2019/11/30/nginx/01-introduct/","excerpt":"Docker基础开篇","text":"Docker基础开篇 centos 7安装nginx 更新yum yum -y update 通过yum安装 yum install epel-release yum install nginx 配置nginx自动启动 systemctl start nginx systemctl enable nginx systemctl status nginx 配置防火墙bash firewall-cmd --zone=public --permanent --add-service=http firewall-cmd --zone=public --permanent --add-service=https firewall-cmd --reload bash nginx 配置文件 worker_processer配置支持的并发数量 events 配置网络连接数量 events:&amp;#123; worker_connections:1024 &amp;#125; http 反向代理# 基础案例 server &amp;#123; listen 80; server_name test.xxgtalk.cn; # listen [::]:80 ipv6only=on; # root /var/www/mywebsite2; # index index.html index.htm; location / &amp;#123; proxy_pass http://localhost:9001; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &amp;#125; # error_page 404 /404.html; # error_page 500 502 503 504 /50x.html; # location = /50x.html &amp;#123; # root /var/www/mywebsite1; # &amp;#125; &amp;#125; 负载均衡# 负载均衡案例 upstream myserver &amp;#123; server 192.168.20.23:8080; server 192.168.20.23:8081; &amp;#125; server &amp;#123; listen 80; server_name test.xxgtalk.cn; # listen [::]:80 ipv6only=on; # root /var/www/mywebsite2; # index index.html index.htm; location / &amp;#123; proxy_pass http://myserver; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection 'upgrade'; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &amp;#125; # error_page 404 /404.html; # error_page 500 502 503 504 /50x.html; # location = /50x.html &amp;#123; # root /var/www/mywebsite1; # &amp;#125; &amp;#125; 动静分离(跟基础类似)高可用 需要在轮胎服务器安装nginx 需要再两台服务器上安装keepalived` bashyum install keepalived -y 修改每台机器上的keepalived配置文件检测是否安装成功rpm -q -q keepalived 目录位置/etc/keepalived`","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.xxgtalk.cn/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.xxgtalk.cn/tags/Nginx/"}]},{"title":".net core 3.0 Signalr - 09 待改进&交流","slug":"dotnetcore/signalr/09-todo","date":"2019-10-05T20:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/05/dotnetcore/signalr/09-todo/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/05/dotnetcore/signalr/09-todo/","excerpt":".net core 3.0 Signalr - 09 待改进&amp;交流","text":".net core 3.0 Signalr - 09 待改进&amp;交流 个人心得写博客真的比写代码累，膜拜那些坚持写博客的大佬！有时候零散的片段比较多，没写之前感觉有千千万万要写的东西，实际写的时候发现， 好像这个没啥说的，然后就帖了个图，或者一笔带过了 待改进&amp;交流 使用消息队列替换目前的api调用形式，同时消息队列支持定义推送优先级 使用polly来重试失败的调用 将连接中传递的userId改成token 多个客户端同时关闭，IsLast不准确 服务器端需要有定时任务去清除redis中的无效数据(看造化) 连接的监控 连接的并发数量测试 更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 08 业务实现-客户端demo 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 08 业务实现-客户端demo","slug":"dotnetcore/signalr/08-clientdemo","date":"2019-10-05T20:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/05/dotnetcore/signalr/08-clientdemo/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/05/dotnetcore/signalr/08-clientdemo/","excerpt":".net core 3.0 Signalr - 08 业务实现-客户端demo","text":".net core 3.0 Signalr - 08 业务实现-客户端demo 由于signalr作为一个单独的推送系统，跟业务系统是分离开的，所以此处模拟一个业务系统，新建一个.net core app项目 模拟实现一个登录功能我们的登录很简单，当进入系统，如果检测到用户未登录则跳转到登录页面，用户只需要输入用户名点击登录即算登录成功 配置ConfigServices方法 查看代码services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme) .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, cookieOption => &#123; cookieOption.LoginPath = \"/Account/Login\"; cookieOption.AccessDeniedPath = \"/Account/Login\"; &#125;); 配置Config方法，配置认证、授权的请求管道 查看代码app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); 接收登录的post请求，写cookie，跳转 查看代码 前端页面实现首先在Layout页面引入需要的js文件(vue、signalr、msgpack5、signalr-protocol-msgpack) 查看代码 封装signalr连接相关jssignalr客户端js的操作就是，创建连接、监听推送,封装后端js如下 查看代码 /** * 初始化连接 * @param &amp;#123;object&amp;#125; option 参数 * @param &amp;#123;string&amp;#125; option.url 连接的url地址 * @param &amp;#123;string&amp;#125; option.loggingLevel 日志级别,默认为 Error * @param &amp;#123;number&amp;#125; option.delay 延迟连接 默认为3000毫秒 * @param &amp;#123;function&amp;#125; option.onStarted 启动时触发 * @param &amp;#123;function&amp;#125; option.onLine 启动时触发 * @param &amp;#123;function&amp;#125; option.offLine 启动时触发 * @returns &amp;#123;object&amp;#125; 连接的实例 */ function initSignalr(option) &amp;#123; var config = Object.assign(true, &amp;#123; loggingLevel: signalR.LogLevel.Error, delay: 3000, url: '' &amp;#125;, option); var connection = new signalR.HubConnectionBuilder() .configureLogging(config.loggingLevel) .withUrl(config.url, &amp;#123; accessTokenFactory: option.accessTokenFactory &amp;#125;) .withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol()) .withAutomaticReconnect([0, 2000, 5000, 10000, 20000]) .build(); connection.onreconnecting(function (info) &amp;#123; console.info('----------------------------------signalr-- onreconnecting', info); &amp;#125;); connection.onclose(function (err) &amp;#123; console.info('--------------------------------signalr-- onclose', err); &amp;#125;); connection.on('OnNotify', config.onNotify); connection.on('OnLine', config.onLine); connection.on('OffLine', config.offLine); setTimeout(function () &amp;#123; connection.start().then(function (data) &amp;#123; option.onStarted &amp;&amp; option.onStarted(data); &amp;#125;).catch(function (error) &amp;#123; console.error(error.toString()); &amp;#125;); &amp;#125;, option.delay); return connection; &amp;#125; 调用封装的js初始化连接 查看代码 然后在Home/Index.cshtml中引入上面的js 在页面加载完后，调用初始化(案例中使用了vue)在进入页面后会弹窗让用户输入加入的组，可以不输入也可以多个 function initConnect() &amp;#123; $(\"#collectionUserInfo\").modal(&amp;#123; keyboard: false, show: true, backdrop: 'static' &amp;#125;) $('#collectionUserInfo').on('hidden.bs.modal', function () &amp;#123; var groups = $(\"#groups\").val()||''; connect=initSignalr(&amp;#123; delay: 0, url:`$&amp;#123;notifyUrl&amp;#125;notify-hub?userId=$&amp;#123;vm.userInfo.userName&amp;#125;&amp;group=$&amp;#123;groups&amp;#125;`, loggingLevel: signalR.LogLevel.Error, onNotify: dealNotify, onLine: function (data) &amp;#123; if (data.IsFirst) &amp;#123; getOnlineUsers(); &amp;#125; getOnlineGroups(); vm.logs.push(`新连接上线：$&amp;#123;JSON.stringify(data)&amp;#125;`); &amp;#125;, offLine: function (data) &amp;#123; if (data.IsLast) &amp;#123; getOnlineUsers(); &amp;#125; getOnlineGroups(); vm.logs.push(`连接下线：$&amp;#123;JSON.stringify(data)&amp;#125;`); &amp;#125;, onStarted: function () &amp;#123; getOnlineUsers(); getOnlineGroups(); vm.$set(vm.userInfo, 'connectionId', connect.connectionId); vm.$set(vm.userInfo, 'groups', groups); vm.logs.push('连接成功'); &amp;#125; &amp;#125;); &amp;#125;) &amp;#125; onNotify方法，如果仔细的话会看到里面的onNotify方法，所有的推送最终都会调用到该方法来进行分发。查看代码offLine，当有客户端下线的时候会触发，data里面包含有用户Id、连接Id、是否该用户的最后一个连接,可根据需要使用查看代码onLine,当用户连接的时候会触发，data里面包含有用户Id、连接Id、是否该用户的第一个连接(用于用户上线后的逻辑处理)，可根据需要使用 查看代码onStarted，当成功连接后触发，可用于做一些连接后的业务逻辑处理，可根据需要使用 查看代码 获取当前用户信息、在线列表在用户连接成功后，获取当前在线用户、用户组、当前用户信息,并设置到vue的data中 查看代码 模拟一个任务分配在项目中心中，点击”模拟推送待办”按钮，将会向当前用户所在组中推送一条代码消息，可以登录不同账号、开多个tab页体验点击事件代码位置 查看代码 assignTaskToUser: function () &amp;#123; var that = this; $.ajax(&amp;#123; type: 'POST', url: '/api/ServerProxy/AssignTaskToUser', data: &amp;#123; groups:that.userInfo.groups &amp;#125; &amp;#125;) &amp;#125;, 对应的推送解析代码 首先当有推送过来的时候，会首先进到onNotify方法，然后根据不同类型在分配到不同的js方法中查看代码效果图 模拟发送消息消息发送，可以选定组、人进行消息发送发送端代码解析端 登录互斥登录互斥是指，当一个账号在A电脑登录，然后再在B电脑登录，最后的登录会排斥掉开始的登录，即，将A上的挤下线首先用谷歌浏览器登录，输入用户名：xiexingen，然后连接接着使用360急速浏览器登录，输入用户名:xiexingen 这个时候会发现谷歌浏览器中的登录已经退出，如图 必要条件: 不同浏览器、同一用户,比如:同一个浏览器，不同tab就不算(能共用cookie) 文件下载(指定连接推送)文件下载的场景，用户在操作页面上选择了上千个文件，然后点击打包下载，这个时候可能需要很久时间才反应回来，那么这段时间如果让用户一直等待显然不妥，所以，当用户点击打包下载的时候，后端启用一个后台线程去打包、压缩，然后立即返回；用户可以继续操作，当服务器端打包好后推送给用户端，用户点击下载即可。此处分两种情况 单连接推送用户开了多个tab页，在其中一个上下载文件，如果后端推送的时候，直接给该用户推，显然不妥；正确的做法一个是只给操作的那个tab页推，这就需要，调用服务器端业务api的时候，需要把当前tab页对应的连接id发送到服务器端，服务器端处理完业务后，调用推送服务器，告诉推送服务器只推我给你的这个连接的客户端，这样就能指定连接推送。 单用户排除某个连接的其他连接推送这种情况比较少见，告诉推送服务器，给这个用户，除了某个连接外的其他所有连接推送 模拟操作点击第一个图中的”打包下载文件” 按钮，当前页面会受到文件下载的推送在点击图二中的”推送当前用户其他页面更新操作”按钮，会发现出了当前tab页外，其他tab也都收到了推送消息，如下图 至此，signalr相关文章算是到此结束了，下一篇谈谈个人的一点心得以及里面存着的一些问题。 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接 下一篇 .net core 3.0 Signalr - 09 待改进&amp;交流 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接","slug":"dotnetcore/signalr/07-self-manager","date":"2019-10-04T20:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/04/dotnetcore/signalr/07-self-manager/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/04/dotnetcore/signalr/07-self-manager/","excerpt":".net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接","text":".net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接 Hub的管理 重写OnConnectedAsync从连接信息中获取UserId、Groups,ConnectId，并实现这三者的关系，存放于redis中代码请查看 using CTS.Signalr.Server.Cores; using CTS.Signalr.Server.Dtos; using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.SignalR; using Microsoft.Extensions.Logging; using System; using System.Linq; using System.Threading.Tasks; namespace CTS.Signalr.Server.Hubs &#123; /// /// 服务端接口 /// public interface IServerNotifyHub &#123; &#125; /// /// 客户端使用的接口 /// public interface IClientNotifyHub &#123; Task OnNotify(object data); Task OnLine(object data); Task OffLine(object data); &#125; [Authorize] public class NotifyHub : Hub&lt;IClientNotifyHub&gt;,IServerNotifyHub &#123; private readonly SignalrRedisHelper _signalrRedisHelper; private readonly ILogger _logger; public NotifyHub(SignalrRedisHelper signalrRedisHelper, ILogger&lt;NotifyHub&gt; logger) &#123; _signalrRedisHelper = signalrRedisHelper; _logger = logger; &#125; public override async Task OnConnectedAsync() &#123; //await Clients.All.OnNotify(new &#123; UserId= Context.User.Identity.Name, Name=Context.User.Identity.Name, ConnectId = Context.ConnectionId &#125;); var userId= Context.User.Identity.Name; var groups=Context.GetHttpContext().Request.Query[&quot;group&quot;].FirstOrDefault(); _logger.LogDebug($&quot;OnConnectedAsync----userId:&#123;userId&#125;,groups:&#123;groups&#125;,connectionId:&#123; Context.ConnectionId&#125;&quot;); if (!string.IsNullOrWhiteSpace(userId)) &#123; await _signalrRedisHelper.AddConnectForUserAsync(userId, Context.ConnectionId); await JoinToGroup(userId, Context.ConnectionId, groups?.Split(&#39;,&#39;)); await DealOnLineNotify(userId, Context.ConnectionId); &#125; await base.OnConnectedAsync(); &#125; public override async Task OnDisconnectedAsync(Exception exception) &#123; var userId = Context.User.Identity.Name; var groups = Context.GetHttpContext().Request.Query[&quot;group&quot;].FirstOrDefault(); _logger.LogDebug($&quot;OnDisconnectedAsync----userId:&#123;userId&#125;,groups:&#123;groups&#125;,connectionId:&#123; Context.ConnectionId&#125;&quot;); if (!string.IsNullOrWhiteSpace(userId)) &#123; await _signalrRedisHelper.RemoveConnectForUserAsync(userId, Context.ConnectionId); await DealOffLineNotify(userId,Context.ConnectionId); &#125; await LeaveFromGroup(Context.ConnectionId, groups?.Split(&#39;,&#39;)); await base.OnDisconnectedAsync(exception); &#125; /// &lt;summary&gt; /// 加入组 /// &lt;/summary&gt; /// &lt;param name=&quot;groupName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task JoinToGroup(string userId,string connectionId,params string[] groups) &#123; if (!string.IsNullOrWhiteSpace(userId)&amp;&amp; groups!=null&amp;&amp;groups.Length&gt;0) &#123; foreach (var group in groups) &#123; await Groups.AddToGroupAsync(connectionId, group); await _signalrRedisHelper.AddUserForGroupAsync(group, connectionId, userId); // await Clients.Group(group).OnJoinGroup(new &#123; ConnectId = connectionId, UserId = userId, GroupName = group &#125;); &#125; &#125; &#125; /// &lt;summary&gt; /// 从组中移除 /// &lt;/summary&gt; /// &lt;param name=&quot;groupName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task LeaveFromGroup(string connectionId,params string[] groups) &#123; if (groups != null &amp;&amp; groups.Length &gt; 0) &#123; foreach (var group in groups) &#123; await Groups.RemoveFromGroupAsync(connectionId, group); await _signalrRedisHelper.RemoveConnectFromGroupAsync(group,connectionId); // await Clients.Group(group).OnLeaveGroup(new &#123; ConnectId = connectionId, GroupName = group &#125;); &#125; &#125; &#125; /// &lt;summary&gt; /// 处理上线通知(只有用户第一个连接才通知) /// &lt;/summary&gt; /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;connectionId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task DealOnLineNotify(string userId,string connectionId) &#123; var userConnectCount = await _signalrRedisHelper.GetConnectsCountByUserAsync(userId); await Clients.All.OnLine(new OnLineData() &#123; UserId = userId, ConnectionId = connectionId, IsFirst = userConnectCount == 1 &#125;); &#125; /// &lt;summary&gt; /// 处理下线通知(只有当用户一个连接都没了 才算下线) /// &lt;/summary&gt; /// &lt;param name=&quot;userId&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;connectionId&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private async Task DealOffLineNotify(string userId,string connectionId) &#123; var userConnectCount = await _signalrRedisHelper.GetConnectsCountByUserAsync(userId); await Clients.All.OffLine(new OffLineData() &#123; UserId = userId, ConnectionId = connectionId, IsLast = userConnectCount == 0 &#125;); &#125; &#125; } ## 提供给业务系统调用的API - [POST] api/notify/post application/json形式 提交，数据格式如下 ``` json &#123; GroupIds:&#39;&#39;, // [可空] 组id集合，多个用,隔开 UserIds:&#39;&#39;,// [可空] 用户id集合，多个用,隔开 ExcludeUsers:boolean, // 是否排除用户列表中的用户 NotifyObj:Object // 通知的对象，任意类型(总大小不要超过36k) &#125; 有GroupIds ExcludeUsers=true推送给指定的组中所有用户(排除掉UserIds部分) ExcludeUsers=false推送给组中指定(UserIds中指定的)的这些用户 无GroupIds ExcludeUsers=true推送给当前所有连接(排除掉UserIds部分的用户) ExcludeUsers=false推送给指定用户(UserIds中指定的用户) [POST] api/notify/postConnectsapplication/json提交，数据格式如下 &amp;#123; Connects:'', // 连接Id集合，多个用，隔开 NotifyObj:Object // 通知的对象，任意类型(总大小不要超过36k) &amp;#125; 有UserId ExcludeConnectId=true给改用户除指定的ConnectId外的所有连接端推送 ExcludeConnectId=false跟没指定UserId一致 无UserId给指定连接Id推送 [GET] api/users获取在线用户Id列表 [GET] api/groups获取在线组列表 增加日志记录为了方便分析和定位问题，使用log4net来作为日志记录器。 nuget 安装log4netnuget 搜索 log4net，安装 Config中配置在Config中注入ILoggerFactory，然后使用添加Log4Net,代码如下所示 public void Configure(IApplicationBuilder app, ILoggerFactory loggerFactory) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseHsts(); loggerFactory.AddLog4Net(); ... &#125; 添加log4net配置文件更多配置请自行查找log4net官方配置文档 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?> &lt;!--LOG4日志级别 0：TRACE；记录一些对程序员调试问题有帮助的信息, 其中可能包含一些敏感信息, 所以应该避免在生产环境中启用Trace日志。 1：DEBUG；记录一些在开发和调试阶段有用的短时变量(Short-term usefulness), 所以除非为了临时排除生产环境的故障，开发人员应该尽量避免在生产环境中启用Debug日志。 2：INFO；信息日志，记录应用程序的一些流程, 例如，记录当前api请求的url，请求参数等。 3：WARN；警告日志；记录应用程序中发生的不正常或者未预期的事件信息。这些信息中可能包含错误消息或者错误产生的条件, 例如, 文件未找到，用户不存在。 4：ERROR；错误日志；记录应用程序中某个操作产生的错误和异常信息，如对空值进行操作等。 5：FATAL；毁灭性错误；记录一些需要立刻修复的问题。例如数据丢失，磁盘空间不足。 trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal --> &lt;log4net> &lt;appender name=\"ErrorRollingFileAppender\" type=\"log4net.Appender.RollingFileAppender\"> &lt;file value=\"AppData\\\\logs\\\\\" /> &lt;appendToFile value=\"true\" /> &lt;rollingStyle value=\"Date\"/> &lt;datePattern value=\"yyyy-MM-dd-'error.log'\"/> &lt;maxSizeRollBackups value=\"100\" /> &lt;staticLogFileName value=\"false\" /> &lt;encoding value=\"utf-8\" /> &lt;layout type=\"log4net.Layout.PatternLayout\"> &lt;conversionPattern value=\"%-5level %date [%-5.5thread] %-40.40logger - %message%newline\" /> &lt;/layout> &lt;filter type=\"log4net.Filter.LevelRangeFilter\"> &lt;levelMin value=\"ERROR\" /> &lt;levelMax value=\"FATAL\" /> &lt;/filter> &lt;/appender> &lt;root> &lt;level value=\"All\" /> &lt;appender-ref ref=\"ErrorRollingFileAppender\" /> &lt;/root> &lt;/log4net> 至此，log4net配置完毕 更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 06 业务实现-业务分析 下一篇 .net core 3.0 Signalr - 08 业务实现-客户端demo 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 06 业务实现-业务分析","slug":"dotnetcore/signalr/06-analysis","date":"2019-10-03T20:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/03/dotnetcore/signalr/06-analysis/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/03/dotnetcore/signalr/06-analysis/","excerpt":".net core 3.0 Signalr - 06 业务实现-业务分析","text":".net core 3.0 Signalr - 06 业务实现-业务分析 业务需求 人-项目关系一个人可以属于多个项目，一个项目可以有多个人加入，通知的时候，可以通知项目内的所有人，也可以通知部分人或者某个责任人。 登录互斥同一个人不允许登录两次(不同浏览器或者不同电脑登)，后面登录的会将前面登录的人挤下线。 聊天可以私聊、也可以创建群聊、上线通知(多个连接的情况) 文件下载用户在界面上选择了多个文件，然后选择批量打包下载，后端后台线程进行压缩、压缩完成后通过signalr通知该用户(的某个连接,比如当前用户开了多个tab页，应该只能推送给操作的那个tab页) 功能设计 名词解释: 业务系统:具体业务功能的系统 推送系统:实际的Signalr系统，跟业务系统分开部署 将推送单独成一个子系统；支持单独部署，可一台服务器也可以多台，通过redis作为底板来分发到服务器 推送子系统端自定义管理用户、连接、组，业务系统调用的时候 推送系统开发一个api，给业务系统直接调用(当然这不是最佳选择，可以通过消息队列，支持重试、优先级等，性能会比http形式好很多)业务系统调用推送系统的时候传递参数包括，组、用户、推送数据对象，比如如下代码 var send = new Send() &#123; // 推送的组，多个用,隔开 GroupId = GroupId, // 关联的UserId 多个用,隔开 UserIds= UserIds, // 是否排除用户 ExcludeUsers=ExcludeUsers, // 实际推送的对象 NotifyObj = new NotifyObj() &#123; Data = Data, NotifyType = NotifyType, OpType= OpType &#125;, &#125;; 有GroupId ExcludeUsers=true推送给指定的组中所有用户(排除掉UserIds部分) ExcludeUsers=false推送给组中指定(UserIds中指定的)的这些用户 无GroupId ExcludeUsers=true推送给当前所有连接(排除掉UserIds部分的用户) ExcludeUsers=false推送给指定用户(UserIds中指定的用户) 架构设计 组、用户、连接的关系 用户:[连接Id]一个用户用多个连接、以Set形式存redis中 组:[连接Id:用户Id]以Redis中的Hash格式存储，以Group为Key，以连接Id为Name，以UserId为值，一个用户在组中可能多个连接(开多个浏览器tab页),这样设计的好处是可以满足以下的几种情况 给某个人推送从redis中直接根据该用户的UserId查询该用户的所有连接，然后通过连接推送即可 给某个组推送从redis中根据组名查询出所有的连接Id，通过连接直接推送 给某个组中的某些人推这个时候不能根据人查连接Id，需要先根据组得到组中的人、连接Id，然后只给组中这些人对应的连接推送 用户上线的时候在redis中存储一份用户与连接的关系；如果有组的情况，同时以Hash形式存储组、连接Id、用户Id 用户再开一个浏览器tab页在redis中该用户对应的连接中增加新的连接Id；如果有组的情况，同时以Hash形式存储组、连接Id、用户Id(因为是一连接Id为name的，然而连接Id是不重复的，所以是可以存着同一个组、同一个用户不同连接这种情况的) 用户退出页面在redis中找到该用户，从redis中删除改用户的找个连接Id，组的情况同样处理 给某个用户的某个连接Id推送比如:用户点击打包下载，服务器端后台线程进行打包、压缩，完成后推送给指定的连接Id，前端界面再进行处理下载 至此，业务分析完毕，更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联 下一篇 .net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联","slug":"dotnetcore/signalr/05-jwt","date":"2019-10-02T18:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/02/dotnetcore/signalr/05-jwt/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/02/dotnetcore/signalr/05-jwt/","excerpt":".net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联","text":".net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联 Signalr是以Group、Connect为核心来进行推送，比如，给某个组、某个连接来推送，但实际场景中，核心应该是某个组、某个人；然而一个人可以对应多个连接(浏览器多个tab页)；本节就来介绍下自行管理人、组、连接这些关系由于signalr连接的时候不那么方便附带header和cookie(因为推送独立成一个子系统了)，实际实现中采用以url query的形式附带上token，然后服务器端自定义解析token得到用户信息； 服务器端实现 ConfigureServices中添加服务相关方法，代码如下,完整代码 public void ConfigureServices(IServiceCollection services) &#123; var appSection = Configuration.GetSection(\"App\"); services.Configure(option => appSection.Bind(option)); var appSetting = appSection.Get(); services.AddSingleton(); // services.AddHostedService(); services.AddAuthentication(options => &#123; options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme; options.DefaultForbidScheme = JwtBearerDefaults.AuthenticationScheme; &#125;) .AddJwtBearer(option => &#123; option.SecurityTokenValidators.Clear(); option.SecurityTokenValidators.Add(new UserTokenValidation()); ; option.Events = new JwtBearerEvents() &#123; OnMessageReceived = context => &#123; var userId = context.Request.Query[\"userId\"].FirstOrDefault(); if (!string.IsNullOrWhiteSpace(userId)) &#123; context.Token = userId; &#125; return Task.CompletedTask; &#125; &#125;; &#125;); services.AddCors(options => options.AddPolicy(corsPolicy, builder => &#123; builder .SetIsOriginAllowedToAllowWildcardSubdomains() .WithOrigins(appSetting.CORS.Split(\",\")) .AllowAnyMethod() .AllowCredentials() .AllowAnyHeader() .Build(); &#125;)); services.AddControllers() .AddNewtonsoftJson(options => options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver()) .ConfigureApiBehaviorOptions(options => &#123; options.InvalidModelStateResponseFactory = context => &#123; var result = new BadRequestObjectResult(context.ModelState); result.ContentTypes.Add(MediaTypeNames.Application.Json); // result.ContentTypes.Add(MediaTypeNames.Application.Xml); return result; &#125;; &#125;) .SetCompatibilityVersion(CompatibilityVersion.Version_3_0); // 添加Signalr services.AddSignalR(config => &#123; if (_webEnv.IsDevelopment()) &#123; config.EnableDetailedErrors = true; &#125; &#125;) // 支持MessagePack .AddMessagePackProtocol() // 使用redis做底板 支持横向扩展 Scale-out .AddStackExchangeRedis(o => &#123; o.ConnectionFactory = async writer => &#123; var config = new ConfigurationOptions &#123; AbortOnConnectFail = false, // Password = \"changeme\", ChannelPrefix = \"__signalr_\", &#125;; //config.EndPoints.Add(IPAddress.Loopback, 0); //config.SetDefaultPorts(); config.DefaultDatabase = appSetting.SignalrRedisCache.DatabaseId; var connection = await ConnectionMultiplexer.ConnectAsync(appSetting.SignalrRedisCache.ConnectionString, writer); connection.ConnectionFailed += (_, e) => &#123; Console.WriteLine(\"Connection to Redis failed.\"); &#125;; if (connection.IsConnected) &#123; Console.WriteLine(\"connected to Redis.\"); &#125; else &#123; Console.WriteLine(\"Did not connect to Redis\"); &#125; return connection; &#125;; &#125;); &#125; 其中，SignalrRedisHelper 为redis辅助方法，详情请参见UserTokenValidation 为自定义token解析方法，详情请参见,由于历史遗留问题，此处直接使用了userId，建议的做法是传递jwttoken，然后服务器端解析jwt token得到用户信息 Hub中跟用户关联在Hub中通过Context.User.Identity.Name可以获取到解析的值，通过这种关系来跟用户关联上，当然，也可以自定义修改使用其他信息，比如Email或其他自定义的名称，具体请google 更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展 下一篇 .net core 3.0 Signalr - 06 业务实现-业务分析 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展","slug":"dotnetcore/signalr/04-redis","date":"2019-10-01T16:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/10/01/dotnetcore/signalr/04-redis/","link":"","permalink":"http://blog.xxgtalk.cn/2019/10/01/dotnetcore/signalr/04-redis/","excerpt":".net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展","text":".net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展 在实际的系统中，可能需要多台机器部署;然而，Signalr的连接信息是跟站点走的，举个例子推送系统部署了A、B两个服务器，张三访问A服务器，李四访问B服务器，当张三通过A服务器向李四推送的时候，A服务器上是找不到李四的连接信息的，自然也就推送不过了，这个时候就需要有一个统一协调的玩意，signalr支持多种，Azure、Redis等，本节以Redis作为底板，介绍如何在Signalr中使用Redis作为底板来支持横向扩展。 引入Redis 先引入NuGet包Microsoft.AspNetCore.SignalR.StackExchangeRedis 修改Startup中的ConfigureServices方法 var appSection = Configuration.GetSection(\"App\"); services.Configure(option => appSection.Bind(option)); var appSetting = appSection.Get(); // 添加Signalr services.AddSignalR(config => &#123; if (_webEnv.IsDevelopment()) &#123; config.EnableDetailedErrors = true; &#125; &#125;) // 支持MessagePack .AddMessagePackProtocol() // 使用redis做底板 支持横向扩展 Scale-out .AddStackExchangeRedis(o => &#123; o.ConnectionFactory = async writer => &#123; var config = new ConfigurationOptions &#123; AbortOnConnectFail = false, ChannelPrefix = \"__signalr_\", &#125;; config.DefaultDatabase = appSetting.SignalrRedisCache.DatabaseId; var connection = await ConnectionMultiplexer.ConnectAsync(appSetting.SignalrRedisCache.ConnectionString, writer); connection.ConnectionFailed += (_, e) => &#123; Console.WriteLine(\"Connection to Redis failed.\"); &#125;; if (connection.IsConnected) &#123; Console.WriteLine(\"connected to Redis.\"); &#125; else &#123; Console.WriteLine(\"Did not connect to Redis\"); &#125; return connection; &#125;; &#125;); 可以自定义Redis相关配置，此处的appSetting为已经定义好的配置实体，包括了，主要配置、CROS配置、Jwt配置、redis配置等详情如下 /// /// 对应appsettings中的App节点的配置信息 /// public class AppSetting &#123; public JwtSetting JwtSetting &#123; set;get;&#125; public RedisCache RedisCache &#123; set;get;&#125; public RedisCache SignalrRedisCache &#123; set; get; &#125; public string CORS &#123; set;get;&#125; /// /// 是否主站点(用于运行清理任务等) /// public bool MainSite &#123; set;get;&#125; &#125; /// /// JWT设置 /// public class JwtSetting &#123; /// /// 发行者 表示token是谁颁发的 /// public string Issuer &#123; set; get; &#125; /// /// 表示哪些客户端可以使用这个token /// public string Audience &#123; set; get; &#125; /// /// 加密的Key 必须大于16位 /// public string SecretKey &#123; set; get; &#125; &#125; public class RedisCache &#123; public string ConnectionString &#123; set;get;&#125; public int DatabaseId &#123; set; get; &#125; &#125; 对应的配置文件如下 &amp;#123; \"Logging\": &amp;#123; \"LogLevel\": &amp;#123; \"Default\": \"Debug\", \"System\": \"Information\", \"Microsoft\": \"Information\", \"Microsoft.AspNetCore.SignalR\": \"Trace\", \"Microsoft.AspNetCore.Http.Connections\": \"Trace\" &amp;#125; &amp;#125;, \"App\": &amp;#123; \"RedisCache\": &amp;#123; \"ConnectionString\": \"127.0.0.1:6379,password=#####,ssl=false,abortConnect=true,connectTimeout=5000\", \"DatabaseId\": 10 &amp;#125;, \"SignalrRedisCache\": &amp;#123; \"ConnectionString\": \"127.0.0.1:6379,password=#####,ssl=false,abortConnect=true,connectTimeout=5000\", \"DatabaseId\": 10 &amp;#125;, \"CORS\": \"https://localhost:60000,http://localhost:60001\", \"MainSite\": true, \"JwtSetting\": &amp;#123; \"Issuer\": \"http://localhost:50000\", //颁发者 \"Audience\": \"http://localhost:50000\", //使用者 \"SecretKey\": \"Wetrial20196666666\" // key 大于16位 &amp;#125; &amp;#125; &amp;#125; 首先，将配置文件跟实体对象映射，下次在其他地方使用的时候可以直接通过DI注入，然后通过AddStackExchangeRedis配置使用redis作为底板 更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 03 使用MessagePack压缩传输内容 下一篇 .net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 03 使用MessagePack压缩传输内容","slug":"dotnetcore/signalr/03-message-pack","date":"2019-09-29T14:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/09/29/dotnetcore/signalr/03-message-pack/","link":"","permalink":"http://blog.xxgtalk.cn/2019/09/29/dotnetcore/signalr/03-message-pack/","excerpt":".net core 3.0 Signalr - 03 使用MessagePack压缩传输内容","text":".net core 3.0 Signalr - 03 使用MessagePack压缩传输内容 MessagePack基础介绍Signalr默认使用的是json形式传递数据，但是signalr提供了灵活的扩展，支持MessagePack形式序列化数据，以增加性能降低网络传输的效果，极大的提高响应速度。 先看一个MessagePack自定义序列化的例子,以一个自定义的实体对象为例，可以使用MessagepackObject标记为序列化的对象，同时定义使用属性名作为key(区分大小写)，同时可以定义忽略某个属性等、以及自定义key等 [MessagePackObject(keyAsPropertyName: true)] public class OffLineData &#123; /// /// 用户Id /// public string UserId &#123; set; get; &#125; /// /// 连接Id /// public string ConnectionId &#123; set; get; &#125; /// /// 是否该用户的最后一个连接 /// public bool IsLast &#123; set; get; &#125; [IgnoreMember] public string Test &#123; set;get;&#125; &#125; // 比如对象，new OffLineData()&#123;UserId=\"1000\",ConnectionId=\"AZDEFASDFASDF\",IsLast:true&#125;通过MessagePack序列化后应该会是&#123;UserId:\"1000\",ConnectionId:\"AZDEFASDFASDF\",IsLast:true&#125;,这个跟常用的json基本相同 同时MessagePack还可以定义序列化成数组形式，代码如下 [MessagePackObject] public class OffLineData &#123; /// /// 用户Id /// [Key(0)] public string UserId &#123; set; get; &#125; /// /// 连接Id /// [Key(0)] public string ConnectionId &#123; set; get; &#125; /// /// 是否该用户的最后一个连接 /// [Key(0)] public bool IsLast &#123; set; get; &#125; &#125; // 比如对象，new OffLineData()&#123;UserId=\"1000\",ConnectionId=\"AZDEFASDFASDF\",IsLast:true&#125;通过MessagePack序列化后应该会是[\"10000\",\"AZDEFASDFASDF\",true] 更多MessagePack的内容可以自行结尾的文档，此处不再过多介绍. 为Signalr添加MessagePack支持 引入需要的Nuget包Microsoft.AspNetCore.SignalR.Protocols.MessagePack 修改之前的ConfigureServices // 添加Signalr services.AddSignalR(config => &#123; if (_webEnv.IsDevelopment()) &#123; config.EnableDetailedErrors = true; &#125; &#125;) // 支持MessagePack .AddMessagePackProtocol(); 前端引入messagepack解析库由于MessagePack传输是以二进制形式进行传输，降低了带宽，但是同时也增加到了代码的复杂度，原本直接获取数据就可以用的，现在需要先将二进制数据转换成正常数据，好在官方提供了对应的js库msgpack5、signalr-protocol-msgpack可以通过vs的包管理工具或者npm安装，然后拷贝需要的文件到项目的lib文件夹,比如我的结构是 signalr-protocol-msgpack |-msgpack5.js |-msgpack5.min.js |-signalr-protocol-msgpack.js |-signalr-protocol-msgpack.min.js 前端页面引入这两个js(注意顺序:signalr、msgpack5、signalr-protocol-msgpack) 修改js连接对象，支持上MessagePack new signalR.HubConnectionBuilder() .configureLogging(signalR.LogLevel.Error) // 前端控制台的日志级别，根据需要配置 .withUrl('http://localhost:50001/notify-hub') // 连接地址,这个地址是signalr项目的地址 .withHubProtocol(new signalR.protocols.msgpack.MessagePackHubProtocol()) // 使用Messagepack来解析推送的数据 .withAutomaticReconnect([0, 2000, 5000, 10000, 20000]) // 配置重连的时间 .build(); // 重连的时候触发 connection.onreconnecting(function (info) &amp;#123; console.info('----------------------------------signalr-- onreconnecting', info); &amp;#125;); //连接关闭的回调 connection.onclose(function (err) &amp;#123; console.info('--------------------------------signalr-- onclose', err); &amp;#125;); connection.start().then(function (data) &amp;#123; console.log('已成功连接到signalr服务器') &amp;#125;).catch(function (error) &amp;#123; console.error(error.toString()); &amp;#125;); 尚未解决问题发现通过json.net序列化得到的对象，直接传递给MessagePack序列化会报错，没找着解决方法，直接改成字符串传递，然后在前端解析了，有遇到过的大佬欢迎指点下 至此，MessagePack介绍算结束了，更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 02 使用强类型的Hub 下一篇 .net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展 源码地址 源码 官方文档 官方文档 MessagePack-CSharp MessagePack-CSharp MessagePack MessagePack","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 02 使用强类型的Hub","slug":"dotnetcore/signalr/02-type-hub","date":"2019-09-22T10:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/09/22/dotnetcore/signalr/02-type-hub/","link":"","permalink":"http://blog.xxgtalk.cn/2019/09/22/dotnetcore/signalr/02-type-hub/","excerpt":".net core 3.0 Signalr - 02 使用强类型的Hub","text":".net core 3.0 Signalr - 02 使用强类型的Hub 强类型的优缺点 优点强类型的Hub可以避免魔法函数名，相比弱类型更容易维护和发现问题，直接上代码 缺点特么的得多些好几行代码 代码接口定义 /// /// 服务端接口 /// public interface IServerNotifyHub &#123; &#125; /// /// 客户端使用的接口 /// public interface IClientNotifyHub &#123; // 这里我们定义一个统一的客户端通知方法 Task OnNotify(object data); &#125; 实现 对之前的Hub进行修改,暂时就先通过OnNotify给当前所有客户端推送一个信息public class NotifyHub : Hub,IServerNotifyHub &#123; public override async Task OnConnectedAsync() &#123; await Clients.All.OnNotify(new &#123; ConnectId = Context.ConnectionId &#125;); await base.OnConnectedAsync(); &#125; &#125; 在api中调用Hub推送大部分情况下，是通过客户端某个操作，比如:将任务分配给张三，那么在分配任务的这个api中会调用推送 推送给张三一个通知，xxx分配了一个任务给你，在Controller中注入强类型的Hub，代码如下 ... private readonly IHubContext _notifyHub; public NotifyController(IHubContext notifyHub) &#123; _notifyHub = notifyHub; &#125; 至此，强类型的Hub介绍完毕，更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 上一篇 .net core 3.0 Signalr - 01 基础篇 下一篇 .net core 3.0 Signalr - 03 使用MessagePack压缩传输内容 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 01 基础篇","slug":"dotnetcore/signalr/01-base","date":"2019-09-21T10:34:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/09/21/dotnetcore/signalr/01-base/","link":"","permalink":"http://blog.xxgtalk.cn/2019/09/21/dotnetcore/signalr/01-base/","excerpt":".net core 3.0 Signalr - 01 基础篇 以最简洁的方式介绍如何创建一个可连接的hub","text":".net core 3.0 Signalr - 01 基础篇 以最简洁的方式介绍如何创建一个可连接的hub 因为将signalr作为单独的站点，此处需要建立两个项目，一个专门用于signalr作为推送项目，一个客户端(实际的业务项目) 基础知识速览Clients对象属性 属性 描述 All 在所有连接的客户端上调用方法 Caller 在调用集线器方法的客户端上调用方法 Others 除当前连接外的所有连接 Clients对象方法 方法 描述 AllExcept 在所有连接的客户端（指定的连接除外）上调用方法 Client 在特定连接的客户端上调用方法(单个) Clients 在特定连接的客户端上调用方法(多个) Group 对指定组中的所有连接调用方法 GroupExcept 对指定组中的所有连接调用方法，指定的连接除外 Groups 在多组连接上调用方法 OthersInGroup 对一组连接调用方法，而不包括调用该集线器方法的客户端 User 对与特定用户关联的所有连接调用方法 Users 对与指定用户相关联的所有连接调用方法 Signalr推送端 通过命令行或者vs 2019新建.netcore web项目，选择.net core 3.0、webapi 建立一个Hub public class NotifyHub : Hub &#123; &#125; 修改Startup中的ConfigServices方法，注册对应的服务 // 添加Signalr services.AddSignalR(config => &#123; // _webEnv为通过依赖注入在Startup的构造函数中注入的 IWebHostEnvironment if (_webEnv.IsDevelopment()) &#123; config.EnableDetailedErrors = true; &#125; &#125;); 修改Configure配置HTTP请求的管道 ... app.UseRouting(); app.UseEndpoints(endpoints =>&#123; endpoints.MapHub(\"/notify-hub\"); &#125;); 业务端相关文档 创建连接对象 var connection=new signalR.HubConnectionBuilder() .configureLogging(signalR.LogLevel.Error) // 前端控制台的日志级别，根据需要配置 .withUrl('http://localhost:50001/notify-hub') // 连接地址,这个地址是signalr项目的地址 .withAutomaticReconnect([0, 2000, 5000, 10000, 20000]) // 配置重连的时间 .build(); // 重连的时候触发 connection.onreconnecting(function (info) &amp;#123; console.info('----------------------------------signalr-- onreconnecting', info); &amp;#125;); //连接关闭的回调 connection.onclose(function (err) &amp;#123; console.info('--------------------------------signalr-- onclose', err); &amp;#125;); connection.start().then(function (data) &amp;#123; console.log('已成功连接到signalr服务器') &amp;#125;).catch(function (error) &amp;#123; console.error(error.toString()); &amp;#125;); 更多内容请通过快速导航查看下一篇 快速导航 标题 内容 索引 .net core 3.0 Signalr - 实现一个业务推送系统 下一篇 .net core 3.0 Signalr - 02 使用强类型的Hub 源码地址 源码 官方文档 官方文档","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":".net core 3.0 Signalr - 实现一个业务推送系统","slug":"dotnetcore/signalr/00-introduct","date":"2019-09-20T20:00:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/09/20/dotnetcore/signalr/00-introduct/","link":"","permalink":"http://blog.xxgtalk.cn/2019/09/20/dotnetcore/signalr/00-introduct/","excerpt":"","text":"介绍ASP.NET Core SignalR 是一个开源代码库，它简化了向应用添加实时 Web 功能的过程。 实时 Web 功能使服务器端代码能够即时将内容推送到客户端。SignalR 的适用对象： 需要来自服务器的高频率更新的应用。 例如：游戏、社交网络、投票、拍卖、地图和 GPS 应用。 仪表板和监视应用。 示例包括公司仪表板、销售状态即时更新或行程警示。 协作应用。 协作应用的示例包括白板应用和团队会议软件。 需要通知的应用。 社交网络、电子邮件、聊天、游戏、行程警示以及许多其他应用都使用通知。SignalR 提供了一个用于创建服务器到客户端远程过程调用（RPC）的 API。 RPC 通过服务器端 .NET Core 代码调用客户端上的 JavaScript 函数。以下是 ASP.NET Core SignalR 的一些功能： 自动管理连接。 同时向所有连接的客户端发送消息。 例如，聊天室。 将消息发送到特定的客户端或客户端组。 扩展以处理增加的流量。 业务需求 一个人可以开多个tab有多个连接 给指定的一个、一批人推送(以User为中心对该用户的所有连接进行推送(浏览器多个tab)) 给指定的组中某些人推送(群聊) 给指定的人某些Connect推送(登录排斥，不允许多台电同时脑登录) 改进部分 优先使用socket进行通信 支持一个用户多个连接 使用MessagePack进行传输 使用Redis作为底板来支持横向扩展 本系列共分为10篇，包括基础知识介绍，项目实战等，目录如下 .net core 3.0 Signalr - 01 基础篇.net core 3.0 Signalr - 02 使用强类型的Hub.net core 3.0 Signalr - 03 使用MessagePack压缩传输内容.net core 3.0 Signalr - 04 使用Redis做底板来支持横向扩展.net core 3.0 Signalr - 05 使用jwt将用户跟signalr关联.net core 3.0 Signalr - 06 业务实现-业务分析.net core 3.0 Signalr - 07 业务实现-服务端 自定义管理组、用户、连接.net core 3.0 Signalr - 08 业务实现-客户端demo.net core 3.0 Signalr - 09 待改进&amp;交流 Demo源码地址 https://github.com/xiexingen/CTS.Signalr 强烈推荐的参考文档 微软官方文档:https://docs.microsoft.com/zh-CN/aspnet/core/signalr/introduction?view=aspnetcore-3.0发现写的不错的博客: https://www.cnblogs.com/cgzl/p/9509207.html发现写的不错的博客:https://www.cnblogs.com/cgzl/p/9515516.html","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"}]},{"title":"Flutter-01 环境搭建","slug":"flutter/01-environment","date":"2019-09-09T19:40:22.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/09/09/flutter/01-environment/","link":"","permalink":"http://blog.xxgtalk.cn/2019/09/09/flutter/01-environment/","excerpt":"Flutter-01 环境搭建","text":"Flutter-01 环境搭建 文档地址 https://developer.android.google.cn/studio/intro Window10环境搭建Flutter开发环境前置条件 磁盘空间足够 git 2.x 安装Android Studio(建议3.0及以上) 下载 https://developer.android.google.com/studio(需要翻墙) https://developer.android.google.cn/studio如果过程提示是否安装一些东西，点同意即可,会自动安装java jdk 为Android Studio安装Flutter和Dart插件File-&gt;Settings-&gt;Plugins 然后搜索Flutter点击安装，这个时候会提示安装Dart插件，点安装 然后重启Android Studio如图 Flutter SDK 配置flutter临时镜像(非必须) // 增加如下变量到用户环境变量中 PUB_HOSTED_URL=https://pub.flutter-io.cn FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn // 注:这些镜像为临时镜像，并不保证一直可用，可以从https://flutter.dev/community/china 查看最新的网址 下载并安装 通过 git 克隆flutter项目代码到本地，比如我的是D:\\Program Files\\Flutter不建议放到高级目录，比如C:\\Program Files 然后在Flutter安装目录的flutter文件下找到flutter_console.bat 双击运行 设置环境变量 系统环境PATH添加 D:\\Program Files\\Flutter\\bin Android环境变量配置 添加系统环境变量// 键和值，其中目录为Android SDK的目录，可以通过android studio菜单File->Settings 然后搜索SDK 可查看SDK的安装目录 ANDROID_HOME:C:\\Users\\xiexingen\\AppData\\Local\\Android\\Sdk 在系统环境变量中的Path中添加%ANDROID_HOME%\\emulator 在系统环境变量中的Path中添加%ANDROID_HOME%\\platform-tools 在系统环境变量中的Path中添加%ANDROID_HOME%\\tools 配置完成后，需要重启电脑 在Android模拟器上运行Flutter 机器上需要启用VM acceleration 启动android studio 菜单 Tools-&gt;AVD Manager 并选择 Create Virtual Device 选择一个设备 然后点 Next 为要模拟的Android版本选择一个或多个系统镜像，然后选择Next(建议使用x86) 在Emulated Performance下，选择 Hardware-GLES 2.0 以启用硬件加速 验证AVD配置是否正确，然后选Finish,更多问题可以参考文档 在Android Virtual Device Manager中，点击工具栏的 Run,启动模拟器并显示所选择的操作系统版本或设备的启动画面 通过 flutter run 命令行运行启动项目 如何在Android真机运行要准备在Android设备上运行并测试Flutter，需要安装Android4.1 (API level 16)或者更高低版本 在设备上启用 开发人员选项和USB调试，可自行google 使用USB将手机插入电脑，如果有授权提示则点同意 在终端中，运行 flutter devices命令以验证Flutter是否识别你连接的Android设备 通过 flutter run 启动项目 Mac 环境搭建Flutter开发环境 由于没有mac电脑，所以特地在VM下安装了一个mac系统 前置条件 磁盘空间足够 安装了命令行工具: bash、curl、git 2.x、mkdir、rm、unzip、which 由于国内访问Flutter可能受限，Flutter官方为中国地区待见了临时镜像，可添加如下环境变量到用户的环境变量中// Macintosh HD->Users->用户名->.bash_profile export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn // 注:这些镜像为临时镜像，并不保证一直可用，可以从https://flutter.dev/community/china 查看最新的网址 安装Flutter SDK 下载并安装 下载stable版本的sdk，然后解压到~/flutter 添加flutter路径到path中 cd ~ vim .bash_profile // 然后添加下面行,;wq 保存，然后重启bash export PATH=/Users/xiexingen/flutter/bin:$PATH 运行flutter doctor来检查flutter会有很多xx 比如xcode，android相关的工具 Android Studio(建议3.0及以上) 下载 https://developer.android.google.com/studio(需要翻墙) https://developer.android.google.cn/studio如果过程提示是否安装一些东西，点同意即可,会自动安装java jdk 为Android Studio安装Flutter和Dart插件File-&gt;Settings-&gt;Plugins 然后搜索Flutter点击安装，这个时候会提示安装Dart插件，点安装 然后重启Android Studio如图 设置环境变量 添加系统环境变量// 电脑/Users/用户名/.bash_profile # Android 环境变量 xiexingen为我的用户名 export ANDROID_HOME=/Users/xiexingen/Library/Android/sdk # Android 模拟器路径 export PATH=$&amp;#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/emulator # Android tools 路径 export PATH=$&amp;#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/tools # Android 平台工具路径 export PATH=$&amp;#123;PATH&amp;#125;:$&amp;#123;ANDROID_HOME&amp;#125;/platform-tools # Android NDK路径 ANDROID_NDK_HOME=/Users/xiexingen/Library/Android/ndk/android-ndk-r10e # Flutter镜像 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn # Flutter 环境变量 export PATH=/Users/xiexingen/flutter/bin:$PATH 配置完成后，需要重启电脑 安装Xcode 通过苹果应用商店安装 配置Xcode命令行工具以使用最新安装的Xcode版本sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 设置IOS模拟器 在终端输入如下命令行打开一个ios模拟器open -a Simulator 通过模拟器菜单的 硬件-&gt;设备,确保是64位的iphone5s或更新的模拟器 如何将Flutter安装到IOS真机上要通过flutter run 将Flutter应用安装到ios整机设备，需要一些额外的工具和一个Apple账号，还需要在Xcode中进行设置： 当然，用XCode来讲Flutter运行在真机上更简单，只需要点 run按钮即可，可以根据需要进行两种不同的运行方式； 安装 Homebrew 确保homebrew最新 brew update 打开终端并运行如下命令来安装用于将Flutter应用安装到IOS设备的工具 brew install --HEAD usbmuxd brew link usbmuxd brew install --HEAd libimobiledevice brew install ideviceinstaller ios-deploy cocoapods pod setup 如果这些命令中的任何一个失败并出现错误，可运行brew doctor并按照说明来解决问题 遵循Xcode前面流程来配置项目 在你Flutter项目目录中通过open ios/Runner.xcworkspace打开默认的Xcode workspace 在Xcode中，选择导航面板左侧中的Runner项目 在Runner target设置页面中，确保在 常规&gt;前面&gt;团队 下选择了您的开发团队。当你选择一个团队时，Xcode会创建并下载开发证书，向您的设备注册您的账户，并创建和下载配置文件(如果需要) 要开始您的第一个IOS开发项目，您可能需要使用您的APP ID登录Xcode 任何App Id都支持开发和测试，但是如想法不到App Store则需要支付99到的开发者账号 当你第一次attach真机设备进行ios开发时，需要同时信任你的Mac和该设备上的开发证书。首次将IOS设备连接到Mac时，请在对话中选择 信任,然后，转到IOS设备上的设置应用程序，选择 常规&gt;设备管理 并信任您的证书 如果Xcode中的自动签名失败，请验证项目的 General&gt;Identity&gt;Bundle Identifier值是否唯一. 通过flutter run 运行启动项目flutter run 其他验证 运行 adb // 检测android相关 运行flutter doctor // 检测flutter相关 第一次运行flutter命令(如 flutter doctor)，它会下载自己的依赖项目并自动编译，并缓存 FAQ无法启动模拟器 emulator: ERROR:x86 emulation currently requires hardware acceleration! Please ensure Windows Hypervisor Platform (WHPX) is properly installed and usable. CPU acceleration status: HAXM is not installed on this machine解决方案:选择 Tools-&gt; SDK Manager -&gt; SDK Tools,安装 HAXM 即可 创建flutter项目 通过android studio创建File-&gt;Create-&gt;New Flutter Project 通过命令行flutter create my_first_app 运行flutter项目 通过android studio 启动按钮 命令行运行android模拟器 // hw1 表示模拟器的名称 emulator -avd hw1 命令行 flutter run前置条件，需要一个已经启动的android模拟器或者连接到电脑的android设备","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.xxgtalk.cn/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.xxgtalk.cn/tags/Flutter/"}]},{"title":"写博客的神器-图床篇","slug":"other/blog_image_lib","date":"2019-08-26T20:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/08/26/other/blog-image-lib/","link":"","permalink":"http://blog.xxgtalk.cn/2019/08/26/other/blog-image-lib/","excerpt":"vscode下使用 PicGo自动上传图片","text":"vscode下使用 PicGo自动上传图片 前言 PicGo github地址PicGo 文档地址 纯手工时代 类型 优点 缺点 站内 1.图片自定义命名 2.方便管理迁移 1.增加博客服务器压力(一般都是比较弱的机器) 2. 操作麻烦 外部资源服务器比如(七牛、微博、腾讯云、阿里云等) 1. 减轻服务器压力 1.操作麻烦，不好管理图片 工业1.0时代今天的重点是，vscode下的PicGo插件,通过简单的配置可以实现切换 七牛、微博、腾讯云COS、又拍云、github、阿里云oss、imgur等，与vscode很方便的集成，综合对比了下 腾讯云、阿里云皆收费，github国内又有点慢，最后选择了七牛，每个月10G 博客应该够用，配置如下:","categories":[{"name":"其他","slug":"其他","permalink":"http://blog.xxgtalk.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://blog.xxgtalk.cn/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"DIY一个集搜索、排序、分页功能的列表组件","slug":"front/react/diy-component-pagedquery","date":"2019-05-22T20:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/05/22/front/react/diy-component-pagedquery/","link":"","permalink":"http://blog.xxgtalk.cn/2019/05/22/front/react/diy-component-pagedquery/","excerpt":"DIY一个集搜索、排序、分页功能的列表组件","text":"DIY一个集搜索、排序、分页功能的列表组件 源码地址: https://github.com/wetrial/wetrial-template效果 背景在中控台系统中经常需要带条件过滤、分页、排序等的列表页面，antd提供了表格、排序、分页等，多个页面中使用会发现里面其实有很多重复的代码，自己捣腾下最后有了这个组件， 使用说明 列表使用如图所示: 引入高阶组件pagedQuery 引入封装的TableList 基本上跟Antd table组件用法一致，只是初始化了许多默认参数 用高阶组件包裹组件，并传参 // type为必须参数，一般对应dva中model的effects &amp;#123; type: string; // 类型 一般指获取数据源的action page?: number; // 当前页 从1开始 defaultPageSize?:number; // 每页默认显示的条数 pageSize?: number; // 每页显示数量 record?: boolean; // 是否记录搜索状态 &amp;#125; 请求附带的基础参数，通过getQueryParams返回一个对象，用于一些特殊场景，一般为空 处理搜索按钮的点击事件，将搜索表单中的值收集并传递给onSearchData方法 处理重置按钮，将重置按钮的点击事件绑定来源于高阶组件给组件的onResetData 获取数据源并给到table 详情页面回退到列表页面有两种形式，1.通过浏览器上的回退按钮2.详情页面放置一个回退按钮，代码层面实现路由跳转到列表页一般情况都使用第二种方式，因为如果编辑页面比较负责，可能里面有子页面，子页面又可以进入这一通过浏览器上的回退按钮需要点击N多次，再者，浏览器的回退有数量限制同样，如图所示： 引入方法backRouter 在需要跳转路由的地方调用一下backRoute方法，并将路由传递给方法，该方法会返回之前记录的列表路由 思路 实现思路，通过高阶组件实现，代码 、 api文档 记录搜索状态，通过sessionStorage来实现，考虑到sessionStore的一个优势，关闭当前tab页就失效了 省去还得去手动清除记录状态的麻烦(比如放到localStorage)，再者 这种查询状态不需要持久记录 回退方法backRouter，由于高阶组件中会在组件的componentWillUnmount方法中记录搜索状态，以location的pathname为key，以location的search为值存放，所以通过backRouter方法匹配的时候会从sessionStorage中查询，如果有则带上查询串，以此来达到记录页面状态的效果 更多请参观：https://www.yuque.com/wetrial/front-end/","categories":[{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"}]},{"title":"优质文章收集(持续更新中...)","slug":"tools/articleCollections","date":"2019-04-26T09:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/04/26/tools/articlecollections/","link":"","permalink":"http://blog.xxgtalk.cn/2019/04/26/tools/articlecollections/","excerpt":"各大优质文章收集(持续更新中…)","text":"各大优质文章收集(持续更新中…) 前端可能是最全的前端动效库汇总 常用前端库 awesome-tools 前端工程化-5:你所需要的npm知识储备都在这了 正则相关 flex布局-语法篇、flex布局-实战篇ES6 Chrome插件开发chrome插件开发 博客文章 官方资料 其他NAS 私有文件服务器","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"使用umi-library来打包组件","slug":"front/react/umi-library-self","date":"2019-04-02T21:35:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2019/04/02/front/react/umi-library-self/","link":"","permalink":"http://blog.xxgtalk.cn/2019/04/02/front/react/umi-library-self/","excerpt":"通过umi-library将自己的组件打包成各种类型的包…","text":"通过umi-library将自己的组件打包成各种类型的包… 文件格式说明esm 用途es6语法格式(也叫AMD)，主要用在浏览器中 export default …；可以做 tree-shaking(打包成一个文件，但是项目中使用时只引入需要的那一部分) cjs 用途es5的语法(也叫CommonJS)，目前主要给node用； module.exports=… umd 用途兼容esm和cjs，先判断是否支持node模块module.exports 步骤 安装umi-library yarn add umi-library -D 配置.umirc.library.js文件export default &amp;#123; // 使用babel方式打包 将按照源代码的文件目录进行打包，默认为rollup方式(将文件合并成一个) esm: 'babel', cjs: 'babel', autoprefixer: &amp;#123; browsers: ['ie>8', 'Safari >= 6'], &amp;#125;, extraBabelPlugins: [ [ 'babel-plugin-import', &amp;#123; libraryName: 'antd', libraryDirectory: 'es', style: true, &amp;#125;, ], ], &amp;#125;; 执行打包可以参考github项目 https://github.com/wetrial/wetrial umi-library地址","categories":[{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"},{"name":"umi","slug":"umi","permalink":"http://blog.xxgtalk.cn/tags/umi/"}]},{"title":"使用travis自动部署到github","slug":"tools/travis","date":"2019-03-16T09:10:15.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"2019/03/16/tools/travis/","link":"","permalink":"http://blog.xxgtalk.cn/2019/03/16/tools/travis/","excerpt":"使用github+travis+ant-design-pro-site打造自己公司的前端开发文档站点","text":"使用github+travis+ant-design-pro-site打造自己公司的前端开发文档站点 开篇 插播一条小广告，我们公司招人.net、前端(react栈) ；有求职意向可以私我内推(qq:1002275364) 目前公司的系统是基于.net web mvc开发，由于历史原因吧，里面有razor写的，也有公司自定义的前端单页框架jui写的一部分，在后续的开发、维护过程中愈发困难；基于各方面考虑以最后打算后端基于.netcore；前端基于react+antd+dva+umi栈重构； 为什么用.net core其实吧，我跟后端是有很大的渊源的，做了好几年后端吧，发现.net后端其实蛮苦逼的，不仅得写后端api还得写前端页面(没办法，你让美工去写razor页面感觉有点过分)，这也是为什么要前后端分离的原因之一(虽然分离之后前端页面还是后端开发人员兼职写^_^)；.net core 天生为了跨平台、高性能、微服务、云而生；作为一个后端黑带6道的我，中小型项目里面玩的还是蛮顺手的(像什么abp、DI、dapper、ef、NPOI、itextsharp、quartznet、CAP、SignalR、Polly、DotnetSpider等还是玩过一些些的，只要别跟我扯什么动不动就双十一的场景，还是可以聊的下去的)其次，.net core生态圈目前虽然不如java等，但是还是可以看到一直在进步；像什么桌面应用、Xamarin、ML.NET、爬虫、Xamarin、区块链、IoT、Unity3D、等都有涉及到;微服务方向，有Ocelot、Consul、Polly 等等等等等等等等等等等等等… 为啥用react+antd+dva+umi【+ts】栈目前开发人员以后端人员为主力，对jquery栈比较熟悉；切换到react后需要比较大的转变，需要接触很多新知识，比如es6的析构赋值、rest、箭头函数、Generate、Promise、模板字符串;再比如 react的生命周期、redux的数据流等 这些都是新的东西；考虑到各方面，最终打算数据量方案使用dva(简单明了以model为单位集reducers、effects、subscribe等)，至于antd不用过多介绍，业界公认前端ui库 好像有点跑题了~~~~~ 工作准备 注册账号github、travis github上创建仓库(wetrial-site) github上生成一个token(记得保存下来)，用于travis推送代码到gh-pages分支记得将tokens保存下来，稍后要用到，仓库权限选择第一项 repo即可 travis设置点击头像、然后选择项目，默认是用户，如果你的项目是组织项目的，需要切换到组织，如图所示 进入项目配置页面，如图添加环境变量相关东西，包括域名、token等 回到实际的项目从ant-design-pro-site拉取代码，然后根据自己的实际情况做修改；比如我去掉了尾栏的一些东西，增加了css相关的大栏(这里不具体介绍) 在根目录下添加travis的配置文件.travis.yml 内容如下所示language: node_js node_js: “8” 缓存依赖cache: directories: - node_modules before_install: export TZ=’Asia/Shanghai’ # 更改时区 依赖安装install: npm install 构建脚本script: npm run build-site 分支白名单branches: only: - master # 只对 master 分支进行构建 GitHub Pages 部署deploy: provider: pagesskip_cleanup: true在项目仪表盘的 Settings -&gt; Environment Variables 中配置github_token: $GITHUB_TOKEN将 build 目录下的内容推送到默认的 gh-pages 分支上，并不会连带 build 目录一起local_dir: _site绑定自定义域名，根据自己的情况来fqdn: $CUSTOM_DOMAINname: $GIT_NAMEemail: $GIT_EMAIL然后提交并同步到github,回到travis将会看到如下一幕 ![配置](http://qiniu.xxgtalk.cn/blog/images/tools/travis_log.jpg) 你也可以从日志里面看到具体的执行过程，等待执行完成后回到github中将会看到里面多了一个gh-pages分支，没错 这个分支就是travis中的deploy推送过去的，里面就是编译后的代码，再回到setting里面，将会看到已经默认配置好站点地址了，这里我们改改 使用自己的域名，如图所示: ![](http://qiniu.xxgtalk.cn/blog/images/tools/travis_github_config.jpg) 最后，去域名管理页，将自己的这个子域名一定一个类型为CNAME的，地址为:wetrial.github.io 结尾访问刚配置的地址:http://ant.xxgtalk.cn 可以看到部署好的文档 此外,打算写一篇这块的手册，地址:https://www.yuque.com/wetrial/front-end/xuyan 欢迎 FORK","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"利用ngrok来做内网穿透","slug":"tools/ngrok","date":"2018-12-17T11:10:12.000Z","updated":"2020-12-25T13:02:18.711Z","comments":true,"path":"2018/12/17/tools/ngrok/","link":"","permalink":"http://blog.xxgtalk.cn/2018/12/17/tools/ngrok/","excerpt":"我有很多自己的个人代码是跑在家里的服务器中的.一般来说都是自动化的处理我的一些生活问题,与数据收集等相关活动. 所以一般没有客户端访问家里服务器的需求. 但是很多时候脑子突发奇想.有一些小点子,一些小的bug或者小的优化,代码修改完成之后,有一个部署到需求. 因为家里服务器没有一个稳定的外网IP的,外网不能直接连接服务器. 所以我们需要 内网穿透.","text":"我有很多自己的个人代码是跑在家里的服务器中的.一般来说都是自动化的处理我的一些生活问题,与数据收集等相关活动. 所以一般没有客户端访问家里服务器的需求. 但是很多时候脑子突发奇想.有一些小点子,一些小的bug或者小的优化,代码修改完成之后,有一个部署到需求. 因为家里服务器没有一个稳定的外网IP的,外网不能直接连接服务器. 所以我们需要 内网穿透. 用法 首先你需要去官网注册一个账号 下载ngrok,并且解压到一个你喜欢的目录下面 去官网复制你的授权码 授权ngrokngrok authtoken 授权码 httpngrok http 8080 tcpngrok tcp 22 最终你会得到,一个外网可以访问的地址. 用这个地址就可以直接访问到你\b本机的端口了. 当我们拥有这样一个公网地址之后,我们就可以ssh来控制家里的机器 或者使用github的webhook来做一切你想要做的事情.","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"React社区精选组件","slug":"front/react/components","date":"2018-12-10T09:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/12/10/front/react/components/","link":"","permalink":"http://blog.xxgtalk.cn/2018/12/10/front/react/components/","excerpt":"ReactReact社区精选组件","text":"ReactReact社区精选组件 其他地址：https://ant.design/docs/react/recommendation-cn| 类型 | 推荐组件 | 描述| :— | :— | :—|滚动条 |react-perfect-scrollbar reactScrollbar | 虚拟滚动条|图片缩放|react-viewer | 图片缩放|媒体查询|react-media|媒体查询|标题修改|react-document-title| 修改标题|浏览器存储|store | 浏览器存储技术|pdf|react-pdf | pdf|react-virtualized|react-virtualized | 大数据渲染 其他类型 类型 推荐组件 描述 生成pdf jsPDF 前端生成pdf 谷歌浏览器API puppeteer 可以用来写爬虫 一个无界面的谷歌浏览器","categories":[{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"}]},{"title":"redis-config常用点介绍","slug":"redis/01-config","date":"2018-12-03T01:10:10.000Z","updated":"2020-12-25T13:02:18.728Z","comments":true,"path":"2018/12/03/redis/01-config/","link":"","permalink":"http://blog.xxgtalk.cn/2018/12/03/redis/01-config/","excerpt":"redis-config常用点介绍","text":"redis-config常用点介绍 参考文档:http://redisdoc.com/ 是否以守护进程方式运行，redis默认不是守护进程方式运行，可以修改该配置项来使用守护进程方式运行daemonizo:yes pidfile 指定守护进程方式的写入文件当redis以守护进程方式运行时，redis默认会吧pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid 指定redis端口配置文件里面找port，默认是6379 bind 绑定的主机ip bind 127.0.0.1 timeout超时时间,默认为0 表示关闭该功能 loglevel 设置日志级别 debug verbose notice warning syslog-enabled:是否将日志输出到系统日志syslog里头 syslog-indent: 指定syslog里的日志标志 syslog-facility： 指定syslog设备，值可以是USER或者LOCAL0-LOCAL7 日志记录方式，默认为标志输出，如果配置redis为守护进程方式运行，而这里又配置日志记录方式为标准输出，则日志将会发送给/dev/nullllogfile stdout databases 数据库数量 databases 16 指定多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件适配 save &lt;seconds> &lt;changes> # redis 默认配置文件提供了三个条件 # save 900 1 # 900秒内有一个更改 # save 300 10 # 300秒内有10个更改 # save 60 10000 # 60秒内有10000个更改 指定存储至本地数据库时是否压缩数据，默认为yes，redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，单会大致数据库文件变得巨大 rdbcompression yes 指定本地数据库文件名，默认为dump.rdb dbfilename dump.rdb 指定本地数据库存放目录 dir ./ 设置当本机为slav服务是，设置master服务的ip地址及端口，在redis启动时，他会自动从master进行数据同步 slaveof &lt;masterip> &lt;masterport> 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password> 设置redis连接密码，如果设置了密码，客户端在连接的时候需要通过 auth 提供密码，默认为关闭 requirepass Abcd1234 设置同一时间最大客户端连接数，默认无限制，redis可以同时打开的客户端连接数为redis经常可以打开的最大文件描述符数，如果设置maxclients 0,表示不作限值。当客户端连接数达到限制时，redis会关闭新的连接并向客户端返回 max number of clients reached错误信息 maxclients 128 指定redis最大内存限制，redis在启动时会把数据加载到内存中，达到最大内存后，redis会尝试清除已到期或即将到期的key，当次方法处理后，仍然达到最大内存设置，将无法进行写入操作，但仍可以读，redis新的vm机制，会把key存放内存，value存放在swap区 maxmemory &lt;bytes> 指定是否每次更新操作后进行日志记录，redis在默认情况下是异步吧数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失，因为redis本身同步数据文件是按上面save条件来同步的，所有的数据会在一段时间内只存在于内存中。默认为 no appendonly no 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof 指定更新日志条件，共有3个可选值no: 表示等操作系统镜像数据缓存同步到磁盘(块)always: 表示每次更新操作后手动调用fsync()将数据写到磁盘(慢，安全)everysec:表示每秒同步一次(折中，默认值) appendfsync everysec 指定是否启用虚拟内存机制，默认为no，简单的介绍下，VM机制将数据分页存放，有redis将访问量较少的页即冷水机swap到磁盘上，访问多的页由磁盘自动换出到内存中 vm-enabled no 虚拟内存文件路径，默认值为/temp/redis.swap，不可多个redis实例共享 vm-swap-file /tmp/redis.swap 将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(redis的所有数据就是keys)，也就是说 当vm-max-memory设置为0的时候，其实就是所有的value都存在于磁盘。默认值为0 vm-max-memory 0 redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但是一个page上不能被多个对象共享，vm-page-size是要根据存储的数据大小来设定的，建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大对象，可以使用更大的page，如果不确定，就是用默认值 vm-max-size 32 设置swap文件中的page数量，由于页表(一种表示页面空闲或使用bitmap)是放在内存中的，在磁盘上每8个pages将消耗1bytes内存。 vm-pages 1342177289 设置访问swap文件的线程数，最好不要超过机器的核数，如果设置为0，那么对所有swap文件的操作都是串行的，可能会造成比较长的延迟，美容是4 vm-max-thread:4 设置在想客户端应答时，是否吧较小的包合并为一个包发送，默认为开启 glueoutputbuf yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 # hash-max-zipmap-entries 64 # has-max-zipmap-value 512 指定是否激活重置哈希，默认为开启 activerehashing yes 指定包含其他的配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf SNAPSHOTTING快照REPLICATION复制SECURITY安全 requirepass节点config get requirepassconfig set requirepass [v] LIMITS限值 maxclients :最大连接数 maxmemory :最大内存 maxmemory-policy : 默认为noevictionvolatile-lru: 使用LRU算法移除key，只对设置了过期时间的键 allkeys-lru:使用LRU算法移除key volatile-random:在过期集合中随机移除，值对设置了过期时间的键有效 allkeys-random: 随机移除key volatile-ttl: 移除那些TTL值最小的key，也就是最近要过期的key noeviction: 永不过期，不进行移除，针对写操作，直返回错误信息 maxmemory-samples APPEND ONLY MODE追加","categories":[{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/tags/redis/"}]},{"title":"redis-cli基础","slug":"redis/02-cmd","date":"2018-12-02T01:10:10.000Z","updated":"2020-12-25T13:02:18.747Z","comments":true,"path":"2018/12/02/redis/02-cmd/","link":"","permalink":"http://blog.xxgtalk.cn/2018/12/02/redis/02-cmd/","excerpt":"redis-cli基础","text":"redis-cli基础 参考文档:http://redisdoc.com/ 命令 说明 参数说明 案例 redis-cli -h [host] -p [port] -a [password] 通过redis-cli连接redis host:地址port:端口号,默认为6379 password:密码 redis-cli -h localhost -p 7379 -a test ping 测试是否通 如果返回pong，表示通了 FLUSHALL 清空所有db FLUSHDB 清空当前db select [index] 切换到第几个db index：从0开始的db下标 select 0 DBSIZE 显示当前db中的key个数 keys [pattern] 显示当前db中的所有key pattern：匹配符(如：？) keys * get [key] 查询指定key的值 key:键名 get name del [key] 删除指定key的值 key:键名 del name EXISTS [key] 判断是否存在指定的key key:键名 EXISTS name move [key] [db] 移动指定的key到指定的db key:键名 db:db下标 ttl [key] 查看过期时间 key:键名,返回值(-1:永不过期 -2:已过期，会移除) ttl name EXPIRE [key] [time] 设置带过期时间的键值 key:键名time:过期时间(秒) EXPIRE name 10 type [key] 查看指定key的数据类型 key:键名 String append [key]:追加 STRLEN [key]:字符串长度 INCR [key]:数值增加 INCRBY [key] v:数值增加v DECR [key] :数值减少 DECRBY [key] v:数值减少v GETRANGE [key] [start] [end]:字符串截取 SETRANGE [key] [start] [end]:字符串截取 setnx [key] [v]: 如果不存在才设置 msetnx [key] […v] : 设置多个 List LPUSH [key] […v] :依次往左边插入多个 RPUSH [key] […v] :依次往右边插入多个 LRANGE [key] [start] [end] :列出多个 lpop [key] :删除第一个 rpop [key] :删除第一个 LINDEX [key] [index] :查看指定下标的值 LLEN [key] :查看list长度 LREM [key] [count] [v]:删除指定列表中指定的count个v LTRIM [key] [start] [end]: 从start开始删除到end为止 rpoplpush [source] [destination]: 移除source的最后一项 并插入到destination的第一项 lset [key] [index] [value] : 用value替换指定下标的值 linsert [key] [before/after] [value1] [value2]: 在value1前/后插入value2 Set SMEMBERS [key] :查看set中数据集合 sadd [key] […v]:添加多个值，去重复的 scard [key] :查看元素中的数量 SREM [key] [v] :删除指定集合中的指定的值 srandmember [key] [count]: 随机生成count个整数 spop [key]:随机删除一个 smove [key1] [key2] [v] :将set集合key1中的v移到key2中 sdiff [key1] [key2]: 查询key1中有，key2中没有的 sinter [key1] [key2]: 查询两个中都有的 sunion [key1] [key2]：查询两个的去重后的合并集合 Hash =&gt; K/V模式不变，V是一个键值对 hget [key] [vKey]:查询key中v的值 hmget [key] […vKey]: 一次查询多个 hset [key] [vKey] [value]：设置key中v的值为value,例:hset user id 1 hmset [key] […[vKey] [value]]: 一次设置多个，例:hmset user name xxg age 28 id HGETALL [key] :查询key中所有的键值对，得到数组[‘属性’,’值’]形式 hdel [key] […vKey] :删除多个指定的vKey hlen [key] :查询指定key中的数量 hexists [key] [vKey]:判断key里面是否存在某个值的key HKEYS [key] : 查看指定key中所有的值的key hvals [key] : 查看指定key中所有的值 HINCRYBY/HINCRYBYFLOAT [key] [vKey] [v] :给指定key增加指定的整数/小数 hsetnx [key] [vKey] [value]：设置值，如果不存在 Zset卧槽，实在不想写了，参考: http://redisdoc.com/sorted_set/index.html","categories":[{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/tags/redis/"}]},{"title":"umi文件拆分","slug":"front/react/umi-split-chunks","date":"2018-11-11T11:35:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/11/11/front/react/umi-split-chunks/","link":"","permalink":"http://blog.xxgtalk.cn/2018/11/11/front/react/umi-split-chunks/","excerpt":"umi文件拆分","text":"umi文件拆分 前言 在umi群里有群友在问umi打包后umi.js文件有1M多甚至更多，那么网站加载的时候会等待这个文件加载完成 可能需要好些时间 这个是比较难忍受的,其实umi有提供代码拆分的功能 只是文档不是很全 这里写了个片博客 谈谈怎么拆分的 使用命令yarn run analyze 打开分析页面，运行后会打开如图的页面 analyze是package.js中定义好的命令’cross-env ANALYZE=1 umi build’ 可以自行添加或者查看umi文档 如图所示，目前umi文件比较大，现在来做拆分，比如这：把@ant-design和antd这两个拆分为antdesigns文件、把react|react-dom|react-router|react-router-dom|lodash|lodash-decorators|redux-saga|re-select|dva|moment这些拆分为wendors文件2. 编写拆分规则 在umi.js||config.js文件的chainWebpack 中加入 config.optimization.splitChunks(&amp;#123; chunks: 'async', minSize: 30000, maxSize: 0, minChunks: 1, maxAsyncRequests: 5, maxInitialRequests: 3, automaticNameDelimiter: '~', name: true, cacheGroups: &amp;#123; vendors: &amp;#123; name: 'vendors', chunks: 'all', test: /[\\\\/]node_modules[\\\\/](react|react-dom|react-router|react-router-dom|lodash|lodash-decorators|redux-saga|re-select|dva|moment)[\\\\/]/, priority: -10, &amp;#125;, antdesigns: &amp;#123; name: 'antdesigns', chunks: 'all', test: /[\\\\/]node_modules[\\\\/](@ant-design|antd)[\\\\/]/, priority: -11, &amp;#125; &amp;#125;, &amp;#125;); 在umi.js或者config.js 的umi-plugin-react中的chunks属性中配置配置如下chunks: ['vendors','antdesigns', 'umi'] 重新执行 yarn run analyze 查看拆分后的情况，如图 致次 拆分完成","categories":[{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"},{"name":"umi","slug":"umi","permalink":"http://blog.xxgtalk.cn/tags/umi/"}]},{"title":"vscode下调试es6编写的npm包","slug":"front/other/VSCodeDebug","date":"2018-09-22T21:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":false,"path":"2018/09/22/front/other/vscodedebug/","link":"","permalink":"http://blog.xxgtalk.cn/2018/09/22/front/other/vscodedebug/","excerpt":"","text":"前置条件 安装好node环境 创建一个文件夹 执行npm init 更具需要选择 通过yarn安装babel-preset-es2015 (也可以通过npm等)yarn add -d babel-cli babel-preset-es2015 //安装babel-cli与babel-preset-es2015 yarn add -d babel-preset-stage-1 //支持babel-preset-stage-1 //yarn add -d babel-preset-react //如果需要支持react //yarn add -d babel-plugin-transform-object-assign //适用于Object.assign() //yarn add -d babel-plugin-transform-object-rest-spread //适用于展开运算符 在package.json文件夹中添加一个scripts 如下所示:scripts: &#123; &quot;build&quot;: &quot;babel src --watch --source-maps --presets=es2015,stage-1 --out-dir dist&quot; //切记 --source-maps一定要加上 &#125; 跟目录下添加.babelrc 内容如下&#123; &quot;presets&quot;: [ &quot;es2015&quot; //,&quot;react&quot; //如果有使用react ] //, //&quot;plugins&quot;:[ // &quot;transform-object-assign&quot;, //适用于Object.assign() // &quot;transform-object-rest-spread&quot; //适用于展开运算符 ... //] &#125; 编写自己的代码，整体项目结构如下|-src&emsp;|–cores&emsp;&emsp;|–math.js –被引用的js文件&emsp;|–index.js –主入口js文件|.babelrc|.package.json 切到vscode左侧的调试窗口，点击添加配置这个时候会生成一个launch.json文件，修改内容如下&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch App.js&quot;, &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;/src/index.js&quot;, &quot;outFiles&quot;: [ &quot;$&#123;workspaceRoot&#125;/dist/**/*.js&quot; ] &#125; ] &#125; 先生成在运行调试npm run build会生成一个dist目录，然后点击调试上的运行按钮 执行调试","categories":[{"name":"前端-其他","slug":"前端-其他","permalink":"http://blog.xxgtalk.cn/categories/%E5%89%8D%E7%AB%AF-%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"前端-其他","slug":"前端-其他","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF-%E5%85%B6%E4%BB%96/"}]},{"title":"资料收集(持续更新中...)","slug":"tools/collections","date":"2018-09-13T09:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/09/13/tools/collections/","link":"","permalink":"http://blog.xxgtalk.cn/2018/09/13/tools/collections/","excerpt":"各大组件、工具收藏夹(持续更新中…)","text":"各大组件、工具收藏夹(持续更新中…) 后端 类型 推荐组件 爬虫 puppeteer、puppeteer-sharp、DotnetSpide、Hawk 工业物联网 HslCommunication 斗地主 FightLandlord 规则引擎 NRules 机器人 BotDemo 定时任务 quartzui、Topshelf 机器学 machinelearning 导出pdf jsPDF、wkhtmltopdf、itextsharp redis桌面管理器 RedisPlus host切换工具 SwitchHosts 异常收集框架 Exceptionless 容器监管 portainer 工具 类型 推荐组件 redis桌面管理器 RedisPlus host切换工具 SwitchHosts 纯前端库 类型 推荐组件 数字转大写 nzh js帮助库 lodash 时区 moment 3D动画 Three.js 动画 Anime.js、GreenSock 打字机 ityped 悬停效果 Hover 快捷键 hotkeys 拖拽 react-dnd、react-beautiful-dnd 推荐.neter常用优秀开源项目 Domain-Driven-Design-ExampleDDD 示例 挺不错的.github https://github.com/zkavtaskin/Domain-Driven-Design-Example SmartStoreNET开源的电商项目github https://github.com/smartstore/SmartStoreNET abpABP框架全称为“ASP.NET Boilerplate Project”，中文翻译为“ ASP.NET样板项目”，ABP是一个开源应用程序框架,专注于基于ASP.NET Core 的Web应用程序开发,但也支持开发其他类型的应用程序github https://github.com/abpframework/abp grpcgRPC 是一个由Google开源的，跨语言的，高性能的远程过程调用（RPC）框架。gRPC使客户端和服务端应用程序可以透明地进行通信，并简化了连接系统的构建。它使用HTTP/2作为通信协议，使用 Protocol Buffers 作为序列化协议。并且微软官方 ASP.NET 项目的人员进行维护，良好的接入 .NET Core 生态github https://github.com/grpc/grpc-dotnet AutofacIOC容器github https://github.com/autofac/Autofac Hangfire非常容易地在.NET或者.NETcore应用程序中执行后台任务，无需windows服务或者单独的进程。且任务信息可以被持久保存。github https://github.com/HangfireIO/Hangfire quartz任务调度github https://github.com/quartznet/quartznet pollyPolly 是一个 .NET 弹性和瞬态故障处理库，允许开发人员以 Fluent 和线程安全的方式来实现重试、断路、超时、隔离和回退策略。github https://github.com/App-vNext/Polly redis 命令《Redis Command Reference》全文的中文翻译版。 http://RedisDoc.comgithub https://github.com/huangz1990/redis orleans一种构建分布式、 高规模（伸缩）的应用程序， 奥尔良是一个框架，提供一个简单的方法来构建分布式的高规模计算应用程序，而无需了解并应用复杂并发或其他伸缩模式。它是由微软研究院创建和设计在云计算中使用。github https://github.com/dotnet/orleans rabbitmq-dotnet-clientrabbitmq 客户端类库github https://github.com/rabbitmq/rabbitmq-dotnet-client AutoMapper将一个对象映射到另一个对象的代码。摆脱了繁琐的赋值过程github https://github.com/AutoMapper/AutoMapper 程序员一般可以从什么平台接私活国内 程序员客栈：https://www.proginn.com程序员客栈中国非常领先的自由工作平台，为中高端程序员、产品经理和设计师等等互联网相关人员提供稳定的线上工作机会，包括自由工作、远程工作和兼职工作，还支持按需雇佣，工作模式非常多，感兴趣的推荐大家尝试一下。虽然名称叫程序员客栈，但是除了程序员，像产品经理，设计师等等互联网相关人员，都能在上面找到适合自己的项目。感兴趣的可以体验一下https://www.proginn.com CODING 码市：https://mart.coding.netCoding 旗下的互联网软件外包服务平台，平台以外包为主。 开源众包：zb.oschina.net/projects开源中国的众包平台，主要是以众包为主。 猪八戒：https://zbj.com找兼职的地方，主要是入门级项目，不适合专业程序员，只适合新手。 英选：linktion.cn平台以定制开发外包服务为主，也是外包项目平台。 快码众包：kuaima.co 码易众包平台：mayigeek.com 一早一晚平台：yizaoyiwan.com/ 开发邦：http://www.kaifabang.com 人人开发：rrkf.com 厘米脚印：http://www.limijiaoyin.com Sxsoft：https://www.sxsoft.com/ 猿急送：https://www.yuanjisong.com/ 实现网传送门：shixian.com/ 智城外包网：http://www.taskcity.com/ 国外 Upwork：https://www.upwork.com/Upwork 是全球最大的、最优秀的、最规范的综合类人力外包服务平台，由著名的 Elance 和 oDesk 合并。这里聚集 900 万来自全球各地的自由工作者，你肯定可以在找到适合你的职位 Freelancer：https://www.freelance.com/工作类型覆盖了很多不同的领域，由程序开发到市场营销、广告、会计、法务等一系列的可以远程的工作 Dribbble：https://dribbble.com/jobs你没看错，Dribbble 不只是全球最受欢迎的设计师社区，同样是设计师寻找远程工作的好出处。自从被 Tiny 收购后，Dribbble 的招聘属性正在慢慢增强，试着持续 PO 出自己的好作品，等待你的伯乐，同样你可以关注 Jobs 页面，给心仪的 Team 提交简历 Stackoverflow：https://stackoverflow.com/jobs被广大程序员熟知的 Stackoverflow 本身就是一个全民远程工作的公司，程序员在远程工作中有很大的先天优势，Stackoverflow Jobs 里有远程职位的筛选，这里有丰富的远程技术职位 99designs：https://99designs.com/99designs 是一个专门针对设计师的雇佣平台，你可以在这里参加设计竞赛给公开的项目投标，也可以给雇主提供一对一的专业服务 Remoteok：https://remoteok.io/Remoteok 不仅提供最初的兼职类远程工作，还有全职类，签署合同类和实习类的工作。网站创始人 Pieter Levels 本身就是一名数字游民，他同样是 Nomadlist 的创始人 Toptal：https://www.toptal.com/Toptal 是一个高端一些的自由职业者平台，适合比较有经验和工作尽力的远程工作者。它将企业与全球的软件工程师，设计师和业务顾问联系起来 Ange：https://angel.co/job-collections/remoteAngelList 主要是服务于初创公司和天使投资人的平台，这里还有初创公司提供的远程工作的机会，如果对远程加入初创公司感兴趣的，可以尝试一下 Topcoder：https://www.topcoder.com/Topcoder 通过算法比赛吸引世界顶级的程序员，他会将一下大型项目分割成很多小模块，通过竞赛的模式交给用户来做，优胜者可以拿到制定模块的奖金 react相关","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Docker中安装Consul","slug":"dotnetcore/consul/docker中安装Consul","date":"2018-09-04T21:48:20.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/09/04/dotnetcore/consul/docker-zhong-an-zhuang-consul/","link":"","permalink":"http://blog.xxgtalk.cn/2018/09/04/dotnetcore/consul/docker-zhong-an-zhuang-consul/","excerpt":"Docker中安装Consul","text":"Docker中安装Consul Consul Docker镜像地址:https://hub.docker.com/_/consul Docker中启动Consul docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul1 consul agent -server -bind=119.29.92.252 -bootstrap-expect=3 -node=consul1 -node：节点的名称 -bind：绑定的一个地址，用于节点之间通信的地址，可以是内外网，必须是可以访问到的地址 -server：这个就是表示这个节点是个SERVER -bootstrap-expect：这个就是表示期望提供的SERVER节点数目，数目一达到，它就会被激活，然后就是leader节点了 启动节点2、3 docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul2 consul agent -server -bind=172.17.0.3 -join=119.29.92.252 -node-id=$(uuidgen | awk &#39;&#123;print tolower($0)&#125;&#39;) -node=consul2 docker run -d -e &#39;CONSUL_LOCAL_CONFIG=&#123;&quot;skip_leave_on_interrupt&quot;: true&#125;&#39; --name=consul3 consul agent -server -bind=172.17.0.4 -join=119.29.92.252 -node-id=$(uuidgen | awk &#39;&#123;print tolower($0)&#125;&#39;) -node=consul3 -client=172.17.0.4 -join：这个表示启动的时候，要加入到哪个集群内，这里就是说要加入到*节点1的集群 -node-id：这个貌似版本8才加入的，这里用这个来指定唯一的节点ID，可以查看这个issue -client：这个表示注册或者查询等一系列客户端对它操作的IP，如果不指定这个IP，默认是127.0.0.1。","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":"Consul","slug":"Consul","permalink":"http://blog.xxgtalk.cn/tags/Consul/"},{"name":".NetCore微服务","slug":"NetCore微服务","permalink":"http://blog.xxgtalk.cn/tags/NetCore%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"React资料收集","slug":"front/react/collection","date":"2018-08-01T09:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/08/01/front/react/collection/","link":"","permalink":"http://blog.xxgtalk.cn/2018/08/01/front/react/collection/","excerpt":"React资料收集","text":"React资料收集 开发工具vscode、Rekit ESLinteslint-config-airbnb 最最最完整的javascript eslint规则 Prettier代码格式化工具,vscode支持 安装插件 添加.prettier文件 React DevTool、Redux DevToolchrome浏览器插件 单元测试相关 Jest:Facebook开源的JS单元测试狂阿基 JS DOM浏览器环境的NodeJS模拟 Enzyme:React组件渲染和测试 nock:模拟http请求 sinon：函数模拟和调用跟踪 istanbul:单元测试覆盖率 其他请查看","categories":[{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"}]},{"title":"Docker安装RabbitMQ","slug":"docker/12docker-rabbitmq","date":"2018-06-08T11:30:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/08/docker/12docker-rabbitmq/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/08/docker/12docker-rabbitmq/","excerpt":"Docker安装RabbitMQ","text":"Docker安装RabbitMQ 参考地址:https://hub.docker.com/_/rabbitmq/ 运行命令 docker run -d -p 8092:15672 -p 5672:5672 --restart always --hostname my-rabbit --name rabbit -e RABBITMQ_DEFAULT_USER=xxg -e RABBITMQ_DEFAULT_PASS=Abcd1234 rabbitmq:3-management 说明 e RABBITMQ_DEFAULT_USER=xxg –默认用户名 e RABBITMQ_DEFAULT_PASS=Abcd1234 –默认密码rabbitmq:3-management –表示使用带插件版本的(可以通过http://host-ip:8092 访问管理控制台)4369/tcp 服务器 需要开放这个端口5671/tcp 服务器 需要开放这个端口","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker安装redis","slug":"docker/11docker-redis","date":"2018-06-06T11:15:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/06/docker/11docker-redis/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/06/docker/11docker-redis/","excerpt":"Docker下安装redis","text":"Docker下安装redis 创建网络docker network create net_redis 创建redis配置文件(/docker/redis/config/redis.conf) #redis的databases数量 databases 32 #redis密码 requirepass 123 通过docker-compose安装docker-compose -f redis-docker-compose.yml up -d文件链接","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"ASP.NET Core + Docker + Jenkins + gogs + CentOS 从零开始搭建持续集成","slug":"docker/10docker-jenkins-gogs-cicd","date":"2018-06-06T11:01:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/06/docker/10docker-jenkins-gogs-cicd/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/06/docker/10docker-jenkins-gogs-cicd/","excerpt":"ASP.NET Core + Docker + Jenkins + gogs + CentOS 从零开始搭建持续集成","text":"ASP.NET Core + Docker + Jenkins + gogs + CentOS 从零开始搭建持续集成 参考地址：https://www.cnblogs.com/stulzq/p/8629165.htmlhttps://www.jianshu.com/p/64e9708c23e7前置条件 安装了docker、配置了加速镜像(参考01) 使用docker安装免费https证书 sudo docker run -it --rm --name certbot \\ -v &quot;/etc/letsencrypt:/etc/letsencrypt&quot; \\ -v &quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot; \\ certbot/certbot certonly 按照提示进行操作 docker安装Gogs (一个gitserver，类似于gitlab)创建文件/docker/gogs 然后运行如下命令docker run -d –name=gogs -p 23:22 -p 8090:3000 –mount type=bind,src=/docker/gogs,dst=/data –restart always gogs/gogs 参考地址 https://github.com/gogits/gogs/tree/master/docker docker 安装jenkins自定义镜像 FROM jenkins USER root #清除了基础镜像设置的源，切换成腾讯云的jessie源 #使用非腾讯云环境的需要将 tencentyun 改为 aliyun RUN echo '' > /etc/apt/sources.list.d/jessie-backports.list \\ && echo \"deb http://mirrors.tencentyun.com/debian jessie main contrib non-free\" > /etc/apt/sources.list \\ && echo \"deb http://mirrors.tencentyun.com/debian jessie-updates main contrib non-free\" >> /etc/apt/sources.list \\ && echo \"deb http://mirrors.tencentyun.com/debian-security jessie/updates main contrib non-free\" >> /etc/apt/sources.list #更新源并安装缺少的包 RUN apt-get update && apt-get install -y libltdl7 && apt-get update ARG dockerGid=999 RUN echo “docker:x:${dockerGid}:jenkins” &gt;&gt; /etc/group 安装 docker-compose 因为等下构建环境的需要RUN curl -L https://github.com/docker/compose/releases/download/1.20.1/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose RUN chmod +x /usr/local/bin/docker-compose docker build -t auto-jenkins . 创建目录/docker/jenkins/docker.sock、/docker/jenkins/jenkins_home ``` yml docker run --name jenkins -p 8091:8080 -p 50000:50000 \\ --mount type=bind,src=/docker/jenkins/docker.sock,dst=/var/run/docker.sock \\ --mount type=bind,src=$(which docker),dst=/bin/docker \\ --mount type=bind,src=/docker/jenkins/jenkins_home,dst=/var/jenkins_home \\ --restart always \\ -d auto-jenkins docker run –name jenkins -p 8091:8080 -p 50000:50000 –mount type=bind,src=/docker/jenkins/docker.sock,dst=/var/run/docker.sock –mount type=bind,src=$(which docker),dst=/bin/docke –mount type=bind,src=/docker/jenkins/jenkins_home,dst=/var/jenkins_home –restart always -d auto-jenkins ASP.NET Core 持续集成 Jenkins配置Gogs webhook插件 Jenkins持续集成演示","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Centos7.x 安装gitlab-runner","slug":"docker/07gitlab01-runner","date":"2018-06-05T10:35:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/05/docker/07gitlab01-runner/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/05/docker/07gitlab01-runner/","excerpt":"Centos7.x 安装gitlab-runner","text":"Centos7.x 安装gitlab-runner 说明：开始尝试过在docker中安装gitlab-runner注册gitlab-runner啥的都没问题 但是gitlab-ci.yml文件中使用docker的时候提示xxxx daemon文件问题 折腾了好几天没能解决(大概的意思就是在容器内部使用使用docker访问不了外面的啥东西最后放弃了，该用在centos中直接安装gitlab-runner形式)参考地址: http://www.cnblogs.com/xishuai/p/ubuntu-gitlab-ci-docker-aspnet-core-part-2.html【前置条件】 系统安装了docker、docker-compose、git、dotnetcoredocker 这个必须要git 必须，因为需要通过git获取代码docker-compose根据情况 因为我的ci中使用了docker-compose所以要dotnetcore 因为我是微软的铁杆粉丝 安装docker、docker-compose参考01 gitlab-runner 安装命令sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-linux-amd64 给予其权限sudo chmod +x /usr/local/bin/gitlab-runner 注册sudo gitlab-runner register根据提示输入gitlab地址、token、描述信息、tag、[true|false]、[true|false]、shell 添加一个用于跑 GitLab Runner 的gitlab-runner用户sudo useradd –comment ‘GitLab Runner’ –create-home gitlab-runner –shell /bin/bash 指定 GitLab Runner 执行的用户和工作目录sudo gitlab-runner install –user=gitlab-runner –working-directory=/home/gitlab-runner 启动gitlab-runnersudo gitlab-runner start 把 GitLab Runner 服务器中的gitlab-runner账户，添加到docker用户组中sudo usermod -aG docker gitlab-runner 在 GitLab Runner 服务器中，切换到gitlab-runner用户下，配置 SSH su gitlab-runner ssh-keygen -t rsa -P &#39;&#39; ssh-copy-id root@你的ip地址 安装gitcd ~yum -y install git","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker安装GitLab","slug":"docker/07gitlab","date":"2018-06-05T10:30:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/05/docker/07gitlab/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/05/docker/07gitlab/","excerpt":"Docker下安装GitLab","text":"Docker下安装GitLab 前置条件 安装好docker docker运行gitlab(由于22端口被ssh占用 改用23) 在/docker/gitlab 目录下分别创建data、config、logs三个文件夹 执行命令sudo docker run --detach --hostname gitlab.xxgtalk.cn --publish 443:443 --publish 8090:80 --publish 23:22 --name gitlab --restart always -v /docker/gitlab/config:/etc/gitlab -v /docker/gitlab/logs:/var/log/gitlab -v /docker/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce * * * * * * 介绍 * * * * * * sudo docker run --detach \\ --hostname gitlab.xxgtalk.cn \\ --publish 443:443 --publish 8090:80 --publish 23:22 \\ --name gitlab \\ --restart always \\ -v /docker/gitlab/config:/etc/gitlab \\ 配置文件映射到config文件夹 -v /docker/gitlab/logs:/var/log/gitlab \\ -v /docker/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce ::: warning 注意 因为配置的ssh端口是23 所以需要修改/docker/gitlab/config/gitlab.rb文件中修改或增加gitlab_rails[‘gitlab_shell_ssh_port’] = 23 查看日志docker logs –follow gitlab::: docker下安装gitlab runner [2.1] 安装gitlab runnersudo docker run -d --name gitlab-runner --restart always -v /srv/gitlab-runner/config:/docker/gitlab-runner/config -v /var/run/docker.sock:/docker/gitlab-runner/run/docker.sock gitlab/gitlab-runner:latest * * * * * * 介绍 * * * * * * sudo docker run -d --name gitlab-runner --restart always \\ v /srv/gitlab-runner/config:/docker/gitlab-runner/config \\ -v /var/run/docker.sock:/docker/gitlab-runner/run/docker.sock \\ gitlab/gitlab-runner:latest [2.2] 注册gitlab runner(官方建议跟gitlab不要放在同一个服务器上)【最后没有成功,改用07Gitlab01-runner 】参考地址:https://docs.gitlab.com.cn/runner/register/index.html 运行下面命令启动注册程序sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register 输入 GitLab 实例 URLgitlab的域名 输入获取到的用于注册 Runner 的 token:y8R7nLY4x3mdBiZt9AQV 输入该 Runner 的描述，稍后也可通过 GitLab’s UI 修改: 给该 Runner 指派 tags, 稍后也可以在 GitLab’s UI 修改: 选择 Runner 是否接收未指定 tags 的任务（默认值：false）， 稍后可以在 GitLab’s UI 修改： true 选择是否为当前项目锁定该 Runner， 之后也可以在 GitLab’s UI 修改。 该功能通常用于被指定为某个项目的 Runner （默认值：true）： 选择 Runner executor: 我们使用docker 如果你选择 Docker 作为你的 executor，注册程序会让你设置一个默认的镜像， 作用于.gitlab-ci.yml中未指定镜像的项目输入: microsoft/dotnet 搭建私有仓库 在docker中创建文件夹registry 用来存放仓库镜像，然后运行命令 docker run -d -v /docker/registry:/var/lib/registry -p 8091:5000 --restart=always --name registry registry 使用docker-compose安装请查看docker-compose文件","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"使用docker-compose","slug":"docker/06docker-compose","date":"2018-06-04T10:01:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/04/docker/06docker-compose/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/04/docker/06docker-compose/","excerpt":"使用docker-compose按照webapi&amp;mysql","text":"使用docker-compose按照webapi&amp;mysql 接Docker制作WebApi&amp;MySql 创建docker-compose.yml文件 version '1' services: db: image: mysql/mysql-server container_name: 'db' command: mysqld --character-set-server=utf8 --collaction-server=utf8_general_ci restart: always ports: -'3306:3306' environment: MYSQL_ROOT_PASSWORD: Abcd1234 MYSQL_USER: sa MYSQL_PASWORD: Abcd1234 volumes: - /docker/mysql/db-init:/docker-entrypoint-initdb.d webapi: build: . container_name: 'webapi01' ports: -'5000:80' depends_on: - db 【注意】由于db需要初始化用户角色 所以在资料卷中指定目录下放入sql 内容GRANT ALL PRIVILEGES ON . TO ‘sa’@’%’ WITH GRANT OPTION; 执行命令docker-compose builddocker up //docker down 与docker up相反 docker-compose文件","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[]},{"title":"Docker制作WebApi&MySql","slug":"docker/05docker-webapi-mysql","date":"2018-06-03T09:30:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":false,"path":"2018/06/03/docker/05docker-webapi-mysql/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/03/docker/05docker-webapi-mysql/","excerpt":"Docker制作WebApi&amp;MySql 直接上图","text":"Docker制作WebApi&amp;MySql 直接上图 docker文件 FROM microsoft/aspnetcore-build as build-env WORKDIR /code COPY *.csproj ./ RUN dotnet restore COPY . ./ RUN dotnet publish -c Release -o out FROM microsoft/aspnetcore WORKDIR /app COPY --from=build-env /code/out ./ EXPOSE 50000 ENTRYPOINT [\"dotnet\",\"WebApiDocker.dll\"] 编译docker文件 docker build -t xxg/aspnetcore:1.0 . 使用该镜像启动一个容器a. docker run -d -p 5000:80 –name api01 –link mysql01:db xxg/aspnetcore:1.0b. 使用bridge形式docker network create -d bridge mybridge //创建一个网络docker run -d -p 5000:5000 –net mybridge –name api1 xxg/aspnetcore:1.0docker network connect mysql01 mybridge //表示将mysql01跟mybridge网络连接起来 –link mysql01:db –表示将mysql01取个别名db并连接到当前容器–net mybridge –表示使用指定网络","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker安装MsSqlserver","slug":"docker/04docker-mssqlserver","date":"2018-06-02T09:25:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/02/docker/04docker-mssqlserver/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/02/docker/04docker-mssqlserver/","excerpt":"Docker安装MsSqlserver","text":"Docker安装MsSqlserver 未成功 执行命令``` sqldocker run -e ‘ACCEPT_EULA=Y’ -e ‘MSSQL_SA_PASSWORD=Abcd1234’ -v=/docker/mssql:/var/opt/mssql -p 1433:1433 –name sqlserver -d microsoft/mssql-server-linux:2017-latest 备注 * * * * * * * * *docker run -e ‘ACCEPT_EULA=Y’ –是否接受协议 -e ‘MSSQL_SA_PASSWORD=&lt;YourStrong!Passw0rd&gt;’ –设置密码-p 1433:1433 –端口–name sqlserver –用户 -d microsoft/mssql-server-linux:2017-latest –2017latest版本","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker 安装MySql","slug":"docker/04docker_install_mysql","date":"2018-06-02T01:20:10.000Z","updated":"2020-12-25T13:02:18.651Z","comments":true,"path":"2018/06/02/docker/04docker-install-mysql/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/02/docker/04docker-install-mysql/","excerpt":"Docker 安装MySql","text":"Docker 安装MySql 将docker容器中的实例中的文件跟物理文件链接起来 即使删掉容器 数据还在 再创建容器的时候 任然可以对应上之前的数据 一、安装篇 使用docker-compose安装 [1.1] 在目录/docker/data/mysql/mysql-init下创建init-user.sql文件 内容如下 use mysql; CREATE USER &#39;sa&#39;@&#39;%&#39; IDENTIFIED BY &#39;Abcd1234&#39;; GRANT ALL PRIVILEGES ON *.* TO &#39;sa&#39;@&#39;%&#39;; [1.2]docker-compose -f mysql-compose.yml up -d对应的mysql-compose.yml文件` ymlversion: ‘2.3’ services: db: image: mysql/mysql-server container_name: mysql01 restart: always command: mysqld –character-set-server=utf8 –collation-server=utf8_general_ci ports: - 3306:3306 networks:- net_mysqlenvironment: MYSQL_ROOT_PASSWORD: Abcd1234 volumes: - /docker/data/mysql/mysql-init:/docker-entrypoint-initdb.d - /docker/data/mysql/data:/var/lib/mysql volumes:mysql-data:external: truenetworks:net_mysql:external: true 2. mount【推荐使用】 docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=Abcd1234 –name mysql01 –restart always –mount type=bind,src=/docker/mysql/config/my.cnf,dst=/etc/my.cnf –mount type=bind,src=/docker/mysql/data,dst=/var/lib/mysql mysql &gt; /docker/mysql/config/my.cnf &amp;nbsp;&amp;nbsp;对应物理磁盘位置 需要新建my.cnf 内容如下 [mysqld]user=rootcharacter-set-server=utf8[client]default-character-set=utf8[mysql]default-character-set=utf8 &gt; /etc/my.cnf --docker创建mysql后该mysql容器对应的配置文件 /docker/mysql/data --对应物理磁盘位置 表示docker中数据映射到的物理文件位置 /var/lib/mysql mysql/mysql-server &amp;nbsp;&amp;nbsp;对应docker中mysql实例容器的文件位置 -e MYSQL_ROOT_PASSWORD=Abcd1234 &amp;nbsp;设置初始密码 1. volume[后期废用] 推荐使用mount形式 docker run -d -p 3306:3306 –name mysql01 -v=/docker/mysql/config/my.cnf:/etc/my.cnf -v=/docker/mysql/data:/var/lib/mysql mysql/mysql-server` 二、使用篇 docker 操作mysql 连接mysqldocker exec -it mysql01 bashmysql -u root -p [密码] –密码可以待mysql容器启动后通过docker logs mysql01 找到生成的随机密码 密码在一段类型： 设置mysql密码SET PASSWORD FOR ‘root‘@’localhost’ = PASSWORD(‘Abcd1234’); –用户名为root 密码为Abcd1234 实验一下 【–exit 退出当前】use mysql; –使用数据库查询select user,host from user; –查询用户信息show variables like ‘%char%’; –查看当前使用的字符集在mysql中创建网络用户 这样可以非本机访问mysql&gt; CREATE USER ‘sa‘@’%’ IDENTIFIED BY ‘Abcd1234’;mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘sa‘@’%’;docker run -d -p 3306:3306 -e”MYSQL_USER=Zarc” -e”MYSQL_PASSWORD=pwd123456” -e”MYSQL_ROOT_PASSWORD=password123” -e”MYSQL_RANDOM_ROOT_PASSWORD=true” –name mysql01 mysql/mysql-server –character-set-server=utf8 –collation-server=utf8_general_ci备注： : When this is true (which is its default state, unless MYSQL_ROOT_PASSWORD is set or MYSQL_ALLOW_EMPTY_PASSWORD is set to true), a random password for the server’s root user is generated when the Docker container is started 当这个MYSQL_RANDOM_ROOT_PASSWORD 为true 时 为root用户设置密码是没有作用的还是会生成随机的密码，设置为false 或者不加这个环境变量","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker安装mongodb","slug":"docker/03docker-mongodb","date":"2018-06-01T09:15:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/06/01/docker/03docker-mongodb/","link":"","permalink":"http://blog.xxgtalk.cn/2018/06/01/docker/03docker-mongodb/","excerpt":"Docker安装mongodb","text":"Docker安装mongodb 配置好docker的加速镜像[参考02Docker安装及配置] docker pull mongo 拉去mongo镜像 启动docker实例 方式一docker run -d -p 27017:27017 –name mongodb mongo方式二 将容器的文件挂在到Host Volume –首先创建文件夹 /docker/mongo/config 以及/docker/mongo/data 用于与docker中mongo实例链接 然后运行命令 docker run -d -p 27017:27017 --name mongo01 -v /docker/mongo/config:/data/configdb -v=/docker/mongo/data:/data/db mongo","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker安装及配置加速镜像","slug":"docker/01docker-config","date":"2018-05-30T09:15:08.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/30/docker/01docker-config/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/30/docker/01docker-config/","excerpt":"Docker安装及配置加速镜像","text":"Docker安装及配置加速镜像 个人阿里云加速镜像个人地址&nbsp; https://noe4mlw6.mirror.aliyuncs.com CentOS 7 (使用yum进行安装)如果之前安装过】先卸载依赖 sudo yum remove docker \\ docker-common \\ container-selinux \\ docker-selinux \\ docker-engine \\ docker-engine-selinux 直接安装curl -sSL https://get.docker.com/ | sh 启动 并设置开机启动 sudo systemctl start docker sudo systemctl enable docker 配置docker使用国内镜像如何配置镜像加速器您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器： &#123; &quot;registry-mirrors&quot;: [&quot;https://noe4mlw6.mirror.aliyuncs.com&quot;] &#125; 重启docker sudo systemctl daemon-reload sudo systemctl restart docker 安装docker-compose sudo curl -L https://github.com/docker/compose/releases/download/1.20.0/docker-compose-`uname -s-uname -m` -o /usr/local/bin/docker-compose sudo chmod a+x /usr/local/bin/docker-compose 卸载sudo rm /usr/local/bin/docker-compose","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Dockerfile解析","slug":"docker/02docker-dockerfile","date":"2018-05-30T01:15:09.000Z","updated":"2020-12-25T13:02:18.686Z","comments":true,"path":"2018/05/30/docker/02docker-dockerfile/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/30/docker/02docker-dockerfile/","excerpt":"Dockerfile解说","text":"Dockerfile解说 关键字 说明 例子 FROM 以此为基础来构建 FROM debian:buster-slim MAINTAINER 镜像维护着的项目和邮箱地址 MAINTAINER The CentOS Project &#x78;&#x78;&#x78;&#x78;&#64;&#99;&#101;&#x6e;&#x74;&#111;&#115;&#46;&#x6f;&#114;&#x67; RUN 容器构建时运行的命令 EXPOSE 当前容器对外暴露的端口 WORKDIR 指定容器创建后，终端默认进来的工作目录 ENV 用来在构建镜像过程中设置环境变量 ADD 将宿主机目录下的文件拷贝到镜像且ADD命令会自动处理URL和解压tar压缩包 ADD c48-docker.tar.xz / COPY 跟ADD类似，但是不会解压 copy src desc、copy [“src”,”desc”] VOLUME 容器数据卷，用于数据保存和持久化工作 VOLUME [“/xxg-data1”,”/xxg-data2”] CMD 指定一个容器启动时要运行的命令，Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换 CMD /bin/bash ENTRYPOINT 指定一个容器启动时要运行的命令，和CMD一样，都是指定容器启动程序及参数 ENTRYPOINT netcore.dll ONBUILD 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发 # 案例一 构建一个自己的centos系统 FROM centos ENV mypath /tmp WORKDIR $mypath RUN yum -y install vim RUN yum -y install net-tools EXPORT 80 CMD /bin/bash","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"Docker常用命令","slug":"docker/00command","date":"2018-05-28T01:10:10.000Z","updated":"2020-12-25T13:05:37.420Z","comments":true,"path":"2018/05/28/docker/00command/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/28/docker/00command/","excerpt":"Docker常用命令","text":"Docker常用命令 命令 说明 参数 docker –version 查看当前docker版本 docker ps 查看当前正在运行的容器 docker images 查看本地所有镜像 docker pull [镜像名称] 拉取一个镜像到本地 docker run [容器名称] 运行一个容器 docker rm [容器名称] 删除本地使用过的容器 docker start [Name] 启动指定容器 docker stop [Name] 关闭指定容器 docker kill [Name] 强制关闭指定容器 docker pause [Name] 暂停指定容器 docker unpause [Name] 恢复指定容器 docker rmi -f $(docker images -a -q) 移除所有images docker rmi $(docker images -f ‘dangling=true’ -q) 移除none的images docker inspect [容器名称] 查看容器的信息 docker exec -it [容器名称] bash 在容器内执行bash 比如执行后可以执行ls查看目录 也可以创建文件等 docker rm -fv [容器Id] 停止、删除容器、清除数据 docker images -f [option] 过滤查询 docker logs -f [container-name] 查看日志 docker history [container-name] 查看镜像的构建历史 数据卷-v 主机目录:容器目录docker run -it -v /docker/data:/config [–privileged=true] 表示将宿主机中的/docker目录跟容器中的/config目录做一个映射，如果没有将自动创建 如果遇到数据卷没权限访问，则在后面增加 –privileged=true即可 数据卷容器–volumns-form containerId|name 表示容器数据卷从name容器同步 docker run -it –name xxg2 –volumns-from xxg1 nginx warning 温馨提示 docker run -p 8001:80 &nbsp;&nbsp;–运行 指定端口 8001外部端口 80表示内部端口 docker run -d &nbsp;&nbsp;–detach 还可以继续操作 不会阻塞 docker run –name &nbsp;&nbsp;–运行的docker镜像的名称 docker run -p 8001:80 &nbsp;&nbsp;–name myapi helloapi:latest表示运行docker中名为helloapi的容器 版本为latest docker的端口为80 本机的端口8001 名字为myapi docker ps -a &nbsp;&nbsp;–查看所有容器 不管有没运行 过滤查询docker images –filter “before=image1” 查询image1之后的docker images –filter “since=image3” 查询image3之前的docker images “wechat:v1.3.“ 查询wechat:1.3.x的docker rmi -f $(docker images “wechat:v1.2.“ -q) 移除wechat:v1.2.*版本的 docker logs查看日志docker logs -f gitlab 查看gitlab容器所有日志docker logs –tail 20 -f gitlab 查看gitlab最近20条的日志docker logs –since 30s -f gitlab 查看gitlab最近30s的日志 docker inspect 查看日志文件位置 docker inspect --format='&amp;#123;&amp;#123;.LogPath&amp;#125;&amp;#125;' mysql 清空docker实例的日志内容 $(docker inspect --format='&amp;#123;&amp;#123;.LogPath&amp;#125;&amp;#125;' &lt;容器ID>) 退出 -itexit 或者ctrl+p+q:::","categories":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"}]},{"title":"windows使用相关","slug":"tools/windows","date":"2018-05-20T09:10:15.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"2018/05/20/tools/windows/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/20/tools/windows/","excerpt":"window技巧-长期更新","text":"window技巧-长期更新 一、技巧篇 查看占用端口netstat -aon [|findstr “1005”] 查找1005端口被那个占用 windows下删除多层级文件夹：安装rimraf包：npm install -g rimraf然后通过：rimraf &lt;目录名称&gt; 来删除 *#06#:查看IphoneCMD 如何下载到本地，而不是边下载边更新：创建一个快捷方式，在快捷方式的后面加 “-layout” 双击后就是下载到本地 而不是安装 打开本地连接：ncpa.cpl 查看系统支持的最大内存：wmic memphysical get maxcapacity 修改hosts文件后刷新 ipconfig -flushdns 二、快捷键 comexp.msc:打开window组件服务，可以查看事务 netplwiz :修改用户组相关 inetmgr:打开IIS ssms:SQLServer数据库 SQLServerManager11.msc 数据库管理工具 devenv:VS mstsc:远程 Alt+Enter 显示所选项的属性 Alt+Esc 以项目打开的顺序循环切换项目 Alt+向上键 在 Windows 资源管理器中查看上一级文件夹 Win + M：最小化所有窗口 Windows 徽标键 + 加号或减号 放大或缩小 Windows 徽标键 输入mspaint 打开画图 Windows 徽标键 输入psr打开系统视频录制 Windows 徽标键 snippingtool win7自带截图工具 notepad 打开记事本 write———-写字板 perfmon.msc—-计算机性能监测程序 services.msc 服务 f10或alt键 激活当前程序的菜单栏 osk————打开屏幕键盘 结束进程：cmd—taskkill /im`notepad.exe /t cdm常用命令：具体参考（http://www.51xue8.com/e/DownSys/play/?classid=31&amp;id=1001&amp;pathid=4&amp;jishu=26） ver====显示系统版本······ver/? =帮助 dir====显示驱动版本 · ·······dir/? =帮助 copy（用法4，全部复制）如：copy c:\\新建文件夹*.* ()d:\\txt chkdsk/?=====查看磁盘文件报告 chkdsk===检查磁盘 dir====C盘文件夹目录（详细，时间，大小··） dir/w =====显示C盘文件夹 （不显示时间，大小） dir/l 显示子文件夹 dir/p======屏幕显示不完时加p format====格式化磁盘（慎用）如：format g: format/?====格式化帮助 del=====删除文件 如：del c:\\··· del/?===删除帮助 md====创建文件夹 ipconfig ====查看ip等信息 ren=====文件重命名 nslookup======ip地址查询 exit=====退出 rd======删除目录 tasklist =====显示进程 type=======显示文本内容 tree=======显示所有文件名····显示D盘则tree d:\\ ping=======检测网络···如ping（必须空格）-f net user=========更改用户 net share====== 查看共享文件 help==============显示所有命令 gpedit.msc—–组策略 sndrec32——-录音机 Nslookup——-IP地址侦测器 explorer——-打开资源管理器 logoff———注销命令 tsshutdn——-60秒倒计时关机命令 lusrmgr.msc—-本机用户和组 services.msc—本地服务设置 oobe/msoobe /a—-检查XP是否激活 cleanmgr——-垃圾整理 net start messenger—-开始信使服务 compmgmt.msc—计算机管理 net stop messenger—–停止信使服务 conf———–启动netmeeting dvdplay——–DVD播放器 charmap——–启动字符映射表 diskmgmt.msc—磁盘管理实用程序 calc———–启动计算器 dfrg.msc——-磁盘碎片整理程序 chkdsk.exe—–Chkdsk磁盘检查 devmgmt.msc— 设备管理器 regsvr32 /u *.dll—-停止dll文件运行 drwtsn32—— 系统医生 rononce -p —-15秒关机 dxdiag———检查DirectX信息 regedt32——-注册表编辑器 Msconfig.exe—系统配置实用程序 rsop.msc——-组策略结果集 mem.exe——–显示内存使用情况 regedit.exe—-注册表 winchat——–XP自带局域网聊天 progman——–程序管理器 winmsd———系统信息 perfmon.msc—-计算机性能监测程序 winver———检查Windows版本 sfc /scannow—–扫描错误并复原 taskmgr—–任务管理器（2000／xp／2003 winver———检查Windows版本 wmimgmt.msc—-打开windows管理体系结构(WMI) wupdmgr——–windows更新程序 wscript——–windows脚本宿主设置 write———-写字板 winmsd———系统信息 wiaacmgr——-扫描仪和照相机向导 winchat——–XP自带局域网聊天 mem.exe——–显示内存使用情况 Msconfig.exe—系统配置实用程序 mplayer2——-简易widnows media player mspaint——–画图板 mstsc———-远程桌面连接 mplayer2——-媒体播放机 magnify——–放大镜实用程序 mmc————打开控制台 mobsync——–同步命令 dxdiag———检查DirectX信息 drwtsn32—— 系统医生 devmgmt.msc— 设备管理器 dfrg.msc——-磁盘碎片整理程序 diskmgmt.msc—磁盘管理实用程序 dcomcnfg——-打开系统组件服务 ddeshare——-打开DDE共享设置 dvdplay——–DVD播放器 net stop messenger—–停止信使服务 net start messenger—-开始信使服务 notepad——–打开记事本 nslookup——-网络管理的工具向导 ntbackup——-系统备份和还原 narrator——-屏幕“讲述人” ntmsmgr.msc—-移动存储管理器 ntmsoprq.msc—移动存储管理员操作请求 netstat -an—-(TC)命令检查接口 syncapp——–创建一个公文包 sysedit——–系统配置编辑器 sigverif——-文件签名验证程序 sndrec32——-录音机 shrpubw——–创建共享文件夹 secpol.msc—–本地安全策略 syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 services.msc—本地服务设置 Sndvol32——-音量控制程序 sfc.exe——–系统文件检查器 sfc /scannow—windows文件保护 tsshutdn——-60秒倒计时关机命令 tourstart——xp简介（安装完成后出现的漫游xp程序） taskmgr——–任务管理器 eventvwr——-事件查看器 eudcedit——-造字程序 explorer——-打开资源管理器 packager——-对象包装程序 perfmon.msc—-计算机性能监测程序 progman——–程序管理器 regedit.exe—-注册表 rsop.msc——-组策略结果集 regedt32——-注册表编辑器 rononce -p —-15秒关机 regsvr32 /u *.dll—-停止dll文件运行 regsvr32 /u zipfldr.dll——取消ZIP支持 cmd.exe——–CMD命令提示符 chkdsk.exe—–Chkdsk磁盘检查 certmgr.msc—-证书管理实用程序 calc———–启动计算器 charmap——–启动字符映射表 cliconfg——-SQL SERVER 客户端网络实用程序 Clipbrd——–剪贴板查看器 conf———–启动netmeeting compmgmt.msc—计算机管理 cleanmgr——-垃圾整理 ciadv.msc——索引服务程序 osk————打开屏幕键盘 odbcad32——-ODBC数据源管理器 oobe/msoobe /a—-检查XP是否激活 lusrmgr.msc—-本机用户和组 logoff———注销命令 iexpress——-木马捆绑工具，系统自带 Nslookup——-IP地址侦测器 fsmgmt.msc—–共享文件夹管理器 utilman——–辅助工具管理器 系统查看=========systeminfo 轻松访问键盘快捷方式 按住右Shift 八秒钟： 启用和关闭筛选键 按左 Alt+左 Shift+PrtScn(或 PrtScn)：启用或关闭高对比度 按左 Alt+左 Shift+Num Lock ：启用或关闭鼠标键 按 Shift 五次： 启用或关闭粘滞键 按住 Num Lock 五秒钟：启用或关闭切换键 Windows 徽标键 + U ： 打开轻松访问中心 常规键盘快捷方式 F1 显示帮助 Ctrl+C 复制选择的项目 Ctrl+X 剪切选择的项目 Ctrl+V 粘贴选择的项目 Ctrl+Z 撤消操作 Ctrl+Y 重新执行某项操作 F2 重命名选定项目 Ctrl+向右键 将光标移动到下一个字词的起始处 Ctrl+向左键 将光标移动到上一个字词的起始处 Ctrl+向下键 将光标移动到下一个段落的起始处 Ctrl+向上键 将光标移动到上一个段落的起始处 Ctrl+Shift 加某个箭头键 选择一块文本 Shift 加任意箭头键 在窗口中或桌面上选择多个项目，或者在文档中选择文本 Ctrl 加任意箭头键+空格键 选择窗口中或桌面上的多个单个项目 Ctrl+A 选择文档或窗口中的所有项目 F3 搜索文件或文件夹 Alt+Enter 显示所选项的属性 Alt+F4 关闭活动项目或者退出活动程序 Alt+空格键 为活动窗口打开快捷方式菜单 Ctrl+F4 关闭活动文档(在允许同时打开多个文档的程序中) Alt+Tab 在打开的项目之间切换 Ctrl+Alt+Tab 使用箭头键在打开的项目之间切换 Ctrl+鼠标滚轮 更改桌面上的图标大小 Windows 徽标键 + Tab 使用 Aero Flip 3-D 循环切换任务栏上的程序 Ctrl + Windows 徽标键 + Tab 通过 Aero Flip 3-D 使用箭头键循环切换任务栏上的程序 Alt+Esc 以项目打开的顺序循环切换项目 F6 在窗口中或桌面上循环切换屏幕元素 F4 在 Windows 资源管理器中显示地址栏列表 Shift+F10 显示选定项目的快捷菜单 Ctrl+Esc 打开「开始」菜单 Alt+加下划线的字母 显示相应的菜单 Alt+加下划线的字母 执行菜单命令(或其他有下划线的命令) F10 激活活动程序中的菜单栏 向右键 打开右侧的下一个菜单或者打开子菜单 向左键 打开左侧的下一个菜单或者关闭子菜单 F5 刷新活动窗口 Alt+向上键 在 Windows 资源管理器中查看上一级文件夹 Esc 取消当前任务 Ctrl+Shift+Esc 打开任务管理器 插入 CD 时按住 Shift 阻止 CD 自动播放 对话框键盘快捷方式 Ctrl+Tab 在选项卡上向前移动 Ctrl+Shift+Tab 在选项卡上向后移动 Tab 在选项上向前移动 Shift+Tab 在选项上向后移动 Alt+加下划线的字母 执行与该字母匹配的命令(或选择选项) Enter 对于许多选定命令代替单击鼠标 空格键 如果活动选项是复选框，则选中或清除该复选框 箭头键 如果活动选项是一组选项按钮，则选择某个按钮 F1 显示帮助 F4 显示活动列表中的项目 Backspace 如果在“另存为”或“打开”对话框中选中了某个文件夹，则打开上一级文件夹 Windows 徽标键相关的快捷键 Windows徽标键就是显示为Windows旗帜，或标有文字Win或Windows的按键，以下简称Win键。XP时代有4个经典的 Win 键组合：R/E/F/L。到了 Win7，花样更多了。 Win：打开或关闭开始菜单 Win + Pause：显示系统属性对话框 Win + D：显示桌面 Win + M：最小化所有窗口 Win + SHIFT + M：还原最小化窗口到桌面上 Win + E：打开我的电脑 Win + F：搜索文件或文件夹 Ctrl + Win + F：搜索计算机(如果您在网络上) Win + L：锁定您的计算机或切换用户 Win + R：打开运行对话框 Win + T：切换任务栏上的程序(感觉是和alt+ESC 一样 ) Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，新开一个实例。(感觉这个比较新颖，貌似快速启动。) Shift + Windows logo key +number：Start a new instance of the program pinned to the taskbar in the position indicated by the number Ctrl + Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，切换到上一次的活动窗口。 Ctrl+Windows logo key +number：Switch to the last active window of the program pinned to the taskbar in the position indicated by the number ALT + Win + 数字：让位于任务栏指定位置(按下的数字作为序号)的程序，显示跳转清单。 Alt+Windows logo key +number： Open the Jump List for the program pinned to the taskbar in the position indicated by the number Win + TAB：循环切换任务栏上的程序并使用的Aero三维效果 Ctrl + Win + TAB：使用方向键来循环循环切换任务栏上的程序，并使用的Aero三维效果 按Ctrl + Win + B：切换到在通知区域中显示信息的程序 Win + 空格：预览桌面 Win + ↑：最大化窗口 Win + ↓：最小化窗口 Win + ←：最大化到窗口左侧的屏幕上 Win + →：最大化窗口到右侧的屏幕上 Win + Home：最小化所有窗口，除了当前激活窗口 Win+ SHIFT + ↑：拉伸窗口的到屏幕的顶部和底部 Win+ SHIFT + →/←：移动一个窗口，从一个显示器到另一个 Win + P：选择一个演示文稿显示模式 Win + G：循环切换侧边栏的小工具 Win + U：打开轻松访问中心 Win + x：打开Windows移动中心 Windows Explorer相关快捷键 Ctrl+N 打开新窗口 Ctrl+Shift+N 新建文件夹","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"通过dotnet命令上传自己的nuget包","slug":"tools/nuget","date":"2018-05-16T09:10:13.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"2018/05/16/tools/nuget/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/nuget/","excerpt":"通过dotnet命令上传自己的nuget包","text":"通过dotnet命令上传自己的nuget包 通过dotnet命令上传自己的nuget包 编辑项目属性 在打包选项中设置各种东西 勾选’在版本中生成Nuget包’、设置其他东西 如包Id、版本等 通过vs发布该包 我生成的为:XXG.AutoMapper.AutoReg.1.1.0.nupkg 执行命令dotnet nuget push XXG.AutoMapper.AutoReg.1.1.0.nupkg -k oy2km5lmhmh4lnff32uadp2qudugxwce5jjamrh6xgx4vy -s https://api.nuget.org/v3/index.json","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"office笔记","slug":"tools/office","date":"2018-05-16T09:10:13.000Z","updated":"2020-12-25T13:56:07.175Z","comments":true,"path":"2018/05/16/tools/office/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/office/","excerpt":"office笔记-长期更新","text":"office笔记-长期更新 =INDIRECT(“Sheet1!C”&amp;ROW())&amp;””，引用下拉框，自动行号 字符串拼接：=$A1&amp;$B1，表示：输出A1和B1单元格的内容","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"nginx笔记","slug":"tools/nginx","date":"2018-05-16T09:10:12.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/16/tools/nginx/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/nginx/","excerpt":"linux安装nginx","text":"linux安装nginx nginx官网https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 命令启动:sudo nginx重启:sudo nginx -s reload关闭:sudo nginx -s stop","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"npm前端项目","slug":"tools/npm","date":"2018-05-16T09:10:12.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/16/tools/npm/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/npm/","excerpt":"npm相关前端操作","text":"npm相关前端操作 本地调试调试本地的包 cd 到包的文件夹下 将当前包link到全局npm link cd 到项目文件夹 将要使用的包link过来 命令如下npm link [package name] 示例： 包名称 xxg-uim-plugin-locale、项目名称 xxg-admin先在 xxg-uim-plugin-locale文件夹下将当前包link到全局，执行 :npm link在定位到xxg-admin项目下，执行: npm link xxg-umi-plugin-locale这样 如果通过yarn add xxg-umi-plugin-locale 安装包的时候会link到本地而不会从npm下载 这样方便本地开发调试 发布到npm续待更新…","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"开发中能提高工作效率的工具收集","slug":"tools/develop","date":"2018-05-16T09:10:11.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/16/tools/develop/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/develop/","excerpt":"开发工具收藏夹","text":"开发工具收藏夹 常用工具 sql对比工具：DiffUse BCompare 文件对比 ORC 图片文本识别 VS插件 Web Essentials web Extension Pack Productivity Power Tools 2015:方法开始结束标线 PicGo vscode的图床管理、github Settings Sync vscode 同步插件 前端 编辑器神器：webstrom、SubLime node 压缩合并混合：grunt、webpack 依赖管理工具：bower、npm、cnpm、yarn 轻量级服务器：httpserver 单元测试：karma 、jasmine karma是容器，jasmine是语法 angularJS专用测试工具：protractor 其他 Emmet：提供自动完成某些文档 DocBlockr DocBlockr可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++ 测试、分析工具 压力测试:Load Runner 服务器IIS分析:Visual Studio Profiler、WinDebug、opserver SQLtoad for mysql 欢迎补充","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"git常用命令(笔记)","slug":"tools/git","date":"2018-05-16T09:10:11.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/16/tools/git/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/git/","excerpt":"常用git命令","text":"常用git命令 创建一个版本库mkdir repository //创建一个文件夹git init [name] //把目录编程git可以管理的仓库,[name]可选 提交文件到版本库git add test.txt //添加文件到版本库,此时还没有提交到gitgit commit -m “提交注释” //告诉Git，把文件提交到仓库 远程查看当前git的状态: git status查看修改变的内容: git diff查看历史记录: git log查看修改的headid： git reflog查看分支： git branch [-a|-r] //-a 所有分支，-r:远程分支查看远程库信息 : git remote查看远程库详细信息: git remote -v查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]克隆远程仓库：git checkout [branchName] origin/[branchName] //如果远程分支有branchName而本地没git checkout -b [branchName] origin/[branchName] //如果远程分支有本地无，克隆并切换到删除本地仓库: git branch -d [branch-name]强制删除本地分支 git branch -D [branch-name]删除远程仓库：$ git push origin :[branch-name] //删除远程分支 git remote rm [branch-name] git push origin --delete [branchName] 修改远程仓库：$ git remote set-url –push [name] [newUrl]拉取远程仓库：$ git pull origin [remoteName]:[localBranchName] git fetch origin [remoteName]:[localBranchName] //获取到当前分支 推送远程仓库：$ git push origin [remoteName]:[localBranchName] //如果有冲突，需要先pull或者fetch远程的git push origin [remoteName]:[localBranchName] -f //强推，使用本地覆盖服务器的 与远程git关联a、在git上创建一个Repositoryb、在本地执行命令：git remote add origin &#103;&#x69;&#x74;&#64;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#x63;&#111;&#x6d;:xiexingen/learngit.git //将本地仓库与远程关联c、重新关联：git remote set-url origin git://git.coding.net/xxxx/yyyy.git 从远程下载到本地git clone [地址] [文件夹名称] //将远程项目复制到本地之地文件加下 分支创建分支：git branch [branch Name]切换分支：git checkout [branch Name]创建+切换分支：git checkout -b [branch Name]合并分支到当前分支：git merge [branch Name]重命名分支： git branch -m [new_branchName] [old_branchName]查看所有分支：git branch -a从指定分支创建并切换到分支:git checkout -b [local-branchName] [origin/branchName]删除分支: git branch [-d|-D] [local-branch] //-d 只能删除已经参与合并的分支,-D:可以删除为合并的分支，然后在git push origin :master 可以删除远程分支git merge命令用于合并指定分支到当前分支,注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交git merge dev :分两种情况一种是直接指向，另一种是生成另外一个将两个合并git merge –no-ff -m’comment’ [branch Name] //合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并git merge –abort //取消合并 Bug分支git stash //相当于tfs中的搁置git stash apply //取消搁置到本地git stash drp //删除搁置集git stash pop //取消搁置到本地并删除搁置集git stash list //查看搁置集git stash apply stash@{0} //恢复指定的搁置集 多人协作A、git push -u origin [local-branch][:remote-branch] //吧本地库推送到远程库上，-u，不但回吧本地的分支推送到远程新的master分支，还会把本地分支和远程分支关联起来，在以后的推送或者拉去时就可以简化命名后面如果有修改的话，只需要执行：git push origin [local-branch] //吧本地分支的最新修改推送到服务器B、从本地推送分支，使用git push origin [local_branch]:[remote-branch]，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；c、建立本地分支和远程分支的关联，使用git branch –set-upstream [local-branch] [origin/remote-branch]从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name 取消、回滚git -reflog 查看历史版本git reset –hard HEAD^ //回到上一次改动 (针对历史提交)git reset -hard 3628164 //3628164 headid 恢复到指定的记录(针对历史提交)git reset test.js //使用当前历史提交还原工作区git checkout – test.js //使用暂存区覆盖改动 cleangit clean -n //将当前非暂存区的文件移除git clean -f //强制移除 版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin –tags上传本地tag到远程仓库：$ git push origin –tags创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’ 忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如targetbin *.db13. 生成密钥 查看是否已经有了ssh密钥：cd ~/.ssh 如果提示：No such file or directory 说明你是第一次使用git如果不是第一次使用，请执行下面的操作,清理原有ssh密钥。$ mkdir key_backup $ cp id_rsa* key_backup $ rm id_rsa*生成新的密钥：$ ssh-keygen -t rsa -C “&#x31;&#48;&#48;&#50;&#x32;&#55;&#x35;&#x33;&#54;&#x34;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109;” 添加忽略文件git rm -f –cached [path] 移除单个文件，path表示全路径git rm -f –cached [path] -r 移除目录，path表示目录 从暂存区移除文件git rm –cached [file] //将file从暂存区移除 taggit tag -a v1.0 -m ‘version 1.0’git tag 列出已有标签git tag -l ‘v1.0’ //列出指定标签git checkout -b [branchName] [tagname] //在特定的标签上创建一个新分支git tag v0.9 [626262] //给上次提价的commit id为626262打上标签git push origin [v1.0] //将标签v1.0push到远程git push origin –tags //将本地的所有tag push到远程git push origin :refs/tags/[v1.0] //删除v1.0 .gitignore文件无效的解决方法git rm -r –cached [指定文件]提交 配置git使用BCompare来比对文件(用户目录.gitconfig里面)[user] name = xiexingen email = 1002275364@qq.com [diff] tool = bc4 [difftool] prompt = false [difftool \"bc4\"] cmd = \\\"D:/Program Files/Beyond Compare 4/BComp.exe\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" [merge] tool = bc4 [mergetool] prompt = false keepBackup = false [mergetool \"bc4\"] cmd = \\\"D:/Program Files/Beyond Compare 4/BComp.exe\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\" trustExitCode = true [alias] dt = difftool mt = mergetool 使用：git difftool ‘文件1’ ‘文件2’git mergetool 全局配置用户名 git config --global user.name xiexingen git config --global user.email 1002275364@qq.com git config --global alias.co checkout //用co代替checkout 日志 git log –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset’ –abbrev-commit –date=relative ** https带用户名密码形式迁出代码git clone http://用户名:密码@gitlab.xxgtalk.cn/WT/StudyNetCore.git github上游合并问题 首先指定上游地址：git remote add upstream [original repo url] 拉取上游代码:git fetch upstream 合并代码:git merge upstream/master","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Openssl生成免费证书","slug":"tools/cer","date":"2018-05-16T09:10:10.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/05/16/tools/cer/","link":"","permalink":"http://blog.xxgtalk.cn/2018/05/16/tools/cer/","excerpt":"使用Openssl生成免费证书","text":"使用Openssl生成免费证书 官网地址 openssl的windows官网: https://slproweb.com/products/Win32OpenSSL.html 下载安装 在自己目录下运行 openssl req -newkey rsa:2048 -nodes -keyout socialnetwork.key -x509 -days 365 -out socialnetwork.cer 生成pfx文件命令openssl pkcs12 -export -in socialnetwork.cer -inkey socialnetwork.key -out socialnetwork.pfx","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"IdentityServer4-使用密码授权模式","slug":"dotnetcore/identityserver4/02passport","date":"2018-03-11T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/11/dotnetcore/identityserver4/02passport/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/11/dotnetcore/identityserver4/02passport/","excerpt":"IdentityServer4-使用密码授权模式","text":"IdentityServer4-使用密码授权模式 一、IdentityServer 也叫服务端 新建.netcore web项目 设置启动端口为60000 并通过Nuget引用IdentityServer4 添加ApiResource和Client(此处方便测试固定了一些数据) 使用IdentityServer 启动项目 http://localhost:60000/.well-known/openid-configuration 可以看到相关json数据二、Api端 (与clientCredentials模式完全一致) 新建.netcore web项目 设置启动端口为60001通过Nuget引用IdentityServer4.AccessTokenValidation 此处只需要验证所以不需要引用IdentityServer4 配置 在controller上贴上属性[Authorize] 表示只允许登录用户访问 通过postman获取token(注意请求body中的参数) 请求需要登录的api 此处为api/values三、client 客户端也叫ThirPart【选修】 定义一个控制台程序 访问api获取数据 创建.net core控制台程序 通过Nuget引用包IdentityModel","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"http://blog.xxgtalk.cn/tags/IdentityServer4/"}],"author":"谢新根"},{"title":"IdentityServer4-ClientCredentials模式","slug":"dotnetcore/identityserver4/01client-credentials","date":"2018-03-10T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/10/dotnetcore/identityserver4/01client-credentials/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/10/dotnetcore/identityserver4/01client-credentials/","excerpt":"IdentityServer4-ClientCredentials模式","text":"IdentityServer4-ClientCredentials模式 一、IdentityServer端 也叫服务端 新建.netcore web项目 设置启动端口为60000 并通过Nuget引用IdentityServer4 添加ApiResource和Client(此处方便测试固定了一些数据) using IdentityServer4.Models; using System.Collections.Generic; namespace Api &#123; public class Config &#123; public static IEnumerable GetResources() &#123; return new List() &#123; new ApiResource(\"api\",\"My Api\") &#125;; &#125; public static IEnumerable GetClients() &#123; return new List() &#123; new Client()&#123; ClientId=\"client\", AllowedGrantTypes=GrantTypes.ClientCredentials, ClientSecrets=&#123; new Secret(\"secret\".Sha256()) &#125;, AllowedScopes=&#123;\"api\"&#125; &#125; &#125;; &#125; &#125; &#125; 使用IdentityServe4 public void ConfigureServices(IServiceCollection services) &#123; services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Config.GetResources()) .AddInMemoryClients(Config.GetClients()); &#125; public void Configure(IApplicationBuilder app,IHostingEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseIdentityServer(); &#125; 启动项目 http://localhost:60000/.well-known/openid-configuration 可以看到相关json数据 二、Api端 新建.netcore web项目 设置启动端口为60001通过Nuget引用IdentityServer4.AccessTokenValidation 此处只需要验证所以不需要引用IdentityServer4 配置StartUp using Microsoft.AspNetCore.Builder; using Microsoft.AspNetCore.Hosting; using Microsoft.Extensions.Configuration; using Microsoft.Extensions.DependencyInjection; namespace Api &#123; public class Startup &#123; public Startup(IConfiguration configuration) &#123; Configuration = configuration; &#125; public IConfiguration Configuration &#123; get; &#125; // This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) &#123; services.AddAuthentication(\"Bearer\") .AddIdentityServerAuthentication(options => &#123; options.Authority = \"http://localhost:60001\";//设置认证服务器地址 options.RequireHttpsMetadata = false;//不需要https options.ApiName = \"api\";//api resource的名字 对应定义的ApiResource中的name &#125;); services.AddMvc(); &#125; // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) &#123; if (env.IsDevelopment()) &#123; app.UseDeveloperExceptionPage(); &#125; app.UseAuthentication(); app.UseMvc(); &#125; &#125; &#125; 在controller上贴上属性[Authorize] 表示只允许登录用户访问 通过postman获取token(注意请求body中的参数) 请求需要登录的api 此处为api/values 三、client 客户端也叫ThirPart【选修】定义一个控制台程序 访问api获取数据 创建.net core控制台程序 通过Nuget引用包IdentityModel using IdentityModel.Client; using System; using System.Net.Http; namespace Client &#123; class Program &#123; static void Main(string[] args) &#123; var diso = DiscoveryClient.GetAsync(\"http://localhost:60000\").Result; if (diso.IsError) &#123; Console.WriteLine(diso.Error); &#125; var tokenClient = new TokenClient(diso.TokenEndpoint, \"client\", \"secret\"); var tokenResponse = tokenClient.RequestClientCredentialsAsync(\"api\").Result; if (tokenResponse.IsError) &#123; Console.WriteLine(tokenResponse.Error); &#125; else &#123; Console.WriteLine(tokenResponse.Json); &#125; var httpClient= new HttpClient(); httpClient.SetBearerToken(tokenResponse.AccessToken); var response = httpClient.GetAsync(\"http://localhost:60001/api/values\").Result; if (response.IsSuccessStatusCode) &#123; Console.WriteLine(response.Content.ReadAsStringAsync().Result); &#125; Console.ReadKey(); &#125; &#125; &#125; ```","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"http://blog.xxgtalk.cn/tags/IdentityServer4/"}],"author":"谢新根"},{"title":"IdentityServer4 资料收集","slug":"dotnetcore/identityserver4/article","date":"2018-03-09T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/09/dotnetcore/identityserver4/article/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/09/dotnetcore/identityserver4/article/","excerpt":"IdentityServer4 资料收集","text":"IdentityServer4 资料收集 IdentityServer4 endPoint查看地址：http://localhost:5000/.well-known/openId-configuration 博客推荐 http://www.cnblogs.com/stulzq/p/8119928.html 八幅漫画理解使用JSON Web Token设计单点登录系统http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/ JSON Web Token - 在Web应用间安全地传递信息http://blog.leapoahead.com/2015/09/06/understanding-jwt/ 纯OAuth2 授权码模式的实现 。 (不包含OICD）https://github.com/bayardw/IdentityServer4.Authorization.Code YAML语法介绍：http://www.ruanyifeng.com/blog/2016/07/yaml.html","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"http://blog.xxgtalk.cn/tags/IdentityServer4/"}],"author":"谢新根"},{"title":"基于JWT的认证模式","slug":"dotnetcore/core/03jwt-authorization","date":"2018-03-06T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/06/dotnetcore/core/03jwt-authorization/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/06/dotnetcore/core/03jwt-authorization/","excerpt":"基于JWT的认证模式","text":"基于JWT的认证模式 在项目目录下定义一个JwtSetting实体类 在appsettings.json中配置值 在StartUp中设置验证方式 在管道中加入认证 登录JwtSecurityToken 需要添加包Microsoft.AspNetCore.Authentication.JwtBearerusing Microsoft.IdentityModel.Tokens;using System.IdentityModel.Tokens.Jwt;using System.Security.Claims; 通过postman模拟登录获取token 将token以请求头形式放到请求中发送请求[注] 键:Authorization token值记得加”bearer “ 扩展 使用自定义验证以及自定义头部token定义MyTokenValidation 实现接口ISecurityTokenValidator 在ConfigureServices方法中 运行效果","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":"基于CookieBase认证的模式","slug":"dotnetcore/core/02cookie-base-authorization","date":"2018-03-05T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/05/dotnetcore/core/02cookie-base-authorization/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/05/dotnetcore/core/02cookie-base-authorization/","excerpt":"基于CookieBase认证的模式","text":"基于CookieBase认证的模式 说明 通过vs2017新建的.net core项目默认没有添加身份认证与授权以及路由等 在StartUp.ConfigureServices中addMvc之前添加AddAuthenticationusing Microsoft.AspNetCore.Authentication.Cookies; 在Configure方法中 模拟登陆using Microsoft.AspNetCore.Authentication;using Microsoft.AspNetCore.Authentication.Cookies;using System.Security.Claims; 在对应的Controller或者Action中贴上属性[Authorize]","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":".NetCore+centos环境搭建手摸手实战","slug":"dotnetcore/core/01dotnetcore-centos-install","date":"2018-03-03T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/03/dotnetcore/core/01dotnetcore-centos-install/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/03/dotnetcore/core/01dotnetcore-centos-install/","excerpt":".NetCore+centos环境搭建手摸手实战","text":".NetCore+centos环境搭建手摸手实战 安装VMware Workstation下载地址:https://my.vmware.com/cn/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0 下载安装 安装CentOS7安装好后发现不能使用网络 参考资料http://blog.csdn.net/wanz2/article/details/52820876 安装.net core参考官网步骤:https://www.microsoft.com/net/learn/get-started/linuxcentos 安装nginx同样参考官网步骤:https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-centos-7 vs2017新建项目发布成本地文件夹新建项目，使用mvc模板发布到本地文件夹 通过Xftp上传到centos通过Xftp将打包的文件直接粘贴到centos中(我是在root目录下建了个web文件夹专门用于存放部署的站点) 将dotnetcore站点运行起来在Xftp中点击新建终端打开XsHell 将路径定位到站点文件夹 cd /root/web/mvc 执行 dotnet HelloWord.dll 看到如下信息 表示你已经成功了这个时候你在外面访问是访问不了的 因为防火墙没有启用5000端口如果一定想看看 可以再开一个终端 输入如图 配置nginx将80端口指向dotnetcore站点这一步就是通过nginx将80请求转到上面的localhost:5000先找着nginx中的配置打开后会发现里面有个在如下目录中新建一个文件 输入配置 server &amp;#123; listen 80; location / &amp;#123; proxy_pass http://localhost:5000; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; &amp;#125; &amp;#125; 然后重启nginx ==》sudo nginx -s reload 查看成果在浏览器中输入192.168.2.105 如图 总结:过程中遇到一些问题，比如虚拟机中的centos系统中使用不了网络 这个折腾了劳资一个上午(如有碰到，第2点中有参考资料)","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":"EFCore相关资料","slug":"dotnetcore/core/efcore","date":"2018-03-01T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/01/dotnetcore/core/efcore/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/01/dotnetcore/core/efcore/","excerpt":"EFCore相关资料","text":"EFCore相关资料 命令行CMD形式 | VS中Package Manager形式 —- | —dotnet ef migrations add InitCreate [-o 路径] | Add-Migration InitCreatedotnet ef database update | Update-Databasedotnet ef migrations remove | Remove-Migrationsdonet ef database update [LastGoodMigration] | Update-Database LastGoodMigrationdotnet ef migrations script [-o 路径] | Script-Migration 生成 migrationName1 到 -migrationName2的脚本dotnet ef migrations script migrationName1 migrationName2不能使用dotnet ef命令行解决方式 在项目文件csproj文件中添加 &lt;DotNetCliToolReference Include=&quot;Microsoft.EntityFrameworkCore.Tools.DotNet&quot; Version=&quot;2.0.1&quot; /&gt;","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":"DotNetCore 备忘录","slug":"dotnetcore/core/remark","date":"2018-03-01T19:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/03/01/dotnetcore/core/remark/","link":"","permalink":"http://blog.xxgtalk.cn/2018/03/01/dotnetcore/core/remark/","excerpt":"DotNetCore 备忘录","text":"DotNetCore 备忘录 常用备忘录 docker run -d -p 8081:80 –name wechat -v /docker/wechat/App_Data/:/app/App_Data/ –restart always registry.cn-hangzhou.aliyuncs.com/xxg/wechat:v1.1.5 使用dotnet watch 在项目项目文件夹中添加(自.netcore2.1.0开始已经集成进去 不需要手动添加) 测试框架Moqfluentassertions 查看nuget目录通过dotnet dotnet nuget locals all –list JSON解析不适用首字母小写形式(默认会首字母小写)在ConfigureServices中配置 services.AddMvc() .AddJsonOptions(options => &#123; if (options.SerializerSettings.ContractResolver is DefaultContractResolver resolver) &#123; resolver.NamingStrategy = null; &#125; &#125;); 添加输出响应内容xml格式.net core中默认只返回json格式需要xml的话需要修改Output formatter services.AddMvc() .AddMvcOptions(options=> &#123; options.OutputFormatters.Add(new XmlDataContractSerializerOutputFormatter()); &#125;) 全局异常 [6.1] 往MVC Filters中添加过滤器添加一个全局异常类继承ExceptionFilterAttribute public class GlobalExceptionFilter : IExceptionFilter &#123; private readonly IHostingEnvironment _hostingEnvironment; private readonly ILogger _logger; public GlobalExceptionFilter( IHostingEnvironment hostingEnvironment, IModelMetadataProvider modelMetadataProvider, ILogger logger) &#123; _hostingEnvironment = hostingEnvironment; _logger = logger; &#125; public void OnException(ExceptionContext context) &#123; HttpStatusCode status = HttpStatusCode.InternalServerError; String message = String.Empty; var exceptionType = context.Exception.GetType(); if (exceptionType == typeof(UnauthorizedAccessException)) &#123; message = &quot;Unauthorized Access&quot;; status = HttpStatusCode.Unauthorized; &#125; else if (exceptionType == typeof(NotImplementedException)) &#123; message = &quot;A server error occurred.&quot;; status = HttpStatusCode.NotImplemented; &#125; else if (exceptionType == typeof(BusinessException)) &#123; message = context.Exception.ToString(); status = HttpStatusCode.InternalServerError; &#125; else &#123; message = context.Exception.Message; status = HttpStatusCode.NotFound; &#125; context.ExceptionHandled = true; HttpResponse response = context.HttpContext.Response; response.StatusCode = (int)status; response.ContentType = &quot;application/json&quot;; var ar = new AjaxResponse() &#123; Success = false, Message = message, Data = context.Exception &#125;; response.WriteAsync(JsonConvert.SerializeObject(ar)); //context.Result = new JsonNetResult(new AjaxResponse() &#123; // Success=false, // Message=context.Exception.Message, // Data=context.Exception //&#125;); &#125; &#125; ``` 在ConfigureServices方法AddMvc中 c# services.AddMvc(config=&gt; &#123; config.Filters.Add(typeof(GlobalExceptionFilter)); &#125;) [6.2] 在Configure方法中添加异常处理管道(注意在所有请求管道的最前面)app.UseExceptionHandler(options =&gt; &#123; options.Run(async context =&gt; &#123; context.Response.StatusCode = (int)HttpStatusCode.InternalServerError; context.Response.ContentType = &quot;application/json&quot;; var ex = context.Features.Get&lt;IExceptionHandlerFeature&gt;(); if (ex != null) &#123; var response = new AjaxResponse() &#123; Success = false, Message = ex.Error.Message, Data = ex.Error &#125;; await context.Response.WriteAsync(JsonConvert.SerializeObject(response)).ConfigureAwait(false); &#125; &#125;); &#125;);","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":"NetCore相关框架收集","slug":"dotnetcore/core/collections","date":"2018-02-27T21:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2018/02/27/dotnetcore/core/collections/","link":"","permalink":"http://blog.xxgtalk.cn/2018/02/27/dotnetcore/core/collections/","excerpt":".NetCore相关框架收集","text":".NetCore相关框架收集 .net core的 开源项目地址 https://github.com/dotnet/corefx asp.net core 框架的地址 https://github.com/aspnet EF Core源码 https://github.com/aspnet/EntityFrameworkCore 配置模块源码 https://github.com/aspnet/Configuration 路由模块 https://github.com/aspnet/Routing 认证及授权 https://github.com/aspnet/Security 依赖注入 https://github.com/aspnet/DependencyInjection 这个一定要看，有很多的一些HTTP管道的抽象接口都定义在这里 https://github.com/aspnet/HttpAbstractions https://github.com/aspnet/Options https://github.com/aspnet/Mvc https://github.com/aspnet/Hosting","categories":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"}],"tags":[{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"}],"author":"谢新根"},{"title":"开通自己的博客","slug":"helleword","date":"2016-04-01T08:01:01.000Z","updated":"2020-12-25T13:56:07.171Z","comments":true,"path":"2016/04/01/helleword/","link":"","permalink":"http://blog.xxgtalk.cn/2016/04/01/helleword/","excerpt":"从hexo切换到vuepress又切回hexo啦！！！","text":"从hexo切换到vuepress又切回hexo啦！！！ ::: tip 大家好我是谢新根，网名:程序有Bug 性别:男 爱好:代码、生活、自行车、羽毛球 性格:沉稳而不活泼、内敛而不明骚、随和而不暴力、帅气中带点闷骚,好啦好啦 第一天开通自己的博客，到此为止吧:::","categories":[],"tags":[],"author":"谢新根"}],"categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.xxgtalk.cn/categories/Nginx/"},{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/categories/NetCore/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.xxgtalk.cn/categories/Flutter/"},{"name":"其他","slug":"其他","permalink":"http://blog.xxgtalk.cn/categories/%E5%85%B6%E4%BB%96/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/categories/React/"},{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/categories/redis/"},{"name":"前端-其他","slug":"前端-其他","permalink":"http://blog.xxgtalk.cn/categories/%E5%89%8D%E7%AB%AF-%E5%85%B6%E4%BB%96/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/categories/Docker/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.xxgtalk.cn/tags/Nginx/"},{"name":"Signalr","slug":"Signalr","permalink":"http://blog.xxgtalk.cn/tags/Signalr/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.xxgtalk.cn/tags/Flutter/"},{"name":"其他","slug":"其他","permalink":"http://blog.xxgtalk.cn/tags/%E5%85%B6%E4%BB%96/"},{"name":"前端","slug":"前端","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"React","permalink":"http://blog.xxgtalk.cn/tags/React/"},{"name":"工具","slug":"工具","permalink":"http://blog.xxgtalk.cn/tags/%E5%B7%A5%E5%85%B7/"},{"name":"umi","slug":"umi","permalink":"http://blog.xxgtalk.cn/tags/umi/"},{"name":"redis","slug":"redis","permalink":"http://blog.xxgtalk.cn/tags/redis/"},{"name":"前端-其他","slug":"前端-其他","permalink":"http://blog.xxgtalk.cn/tags/%E5%89%8D%E7%AB%AF-%E5%85%B6%E4%BB%96/"},{"name":"Consul","slug":"Consul","permalink":"http://blog.xxgtalk.cn/tags/Consul/"},{"name":".NetCore微服务","slug":"NetCore微服务","permalink":"http://blog.xxgtalk.cn/tags/NetCore%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Docker","slug":"Docker","permalink":"http://blog.xxgtalk.cn/tags/Docker/"},{"name":".NetCore","slug":"NetCore","permalink":"http://blog.xxgtalk.cn/tags/NetCore/"},{"name":"IdentityServer4","slug":"IdentityServer4","permalink":"http://blog.xxgtalk.cn/tags/IdentityServer4/"}]}